{
  "version": 3,
  "sources": ["../../src/utils.js", "../../src/options.js", "../../src/unicode.js", "../../src/transform.js", "../../src/generate.js", "../../src/subclass.js", "../../src/index.js"],
  "sourcesContent": ["import {EsVersion, Target} from './options.js';\n\nconst cp = String.fromCodePoint;\nconst r = String.raw;\n\nconst envFlags = {\n  flagGroups: (() => {\n    try {\n      new RegExp('(?i:)');\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n  unicodeSets: (() => {\n    try {\n      new RegExp('', 'v');\n    } catch {\n      return false;\n    }\n    return true;\n  })(),\n};\n// Detect WebKit bug: <github.com/slevithan/oniguruma-to-es/issues/30>\nenvFlags.bugFlagVLiteralHyphenIsRange = envFlags.unicodeSets ? (() => {\n  try {\n    new RegExp(r`[\\d\\-a]`, 'v');\n  } catch {\n    return true;\n  }\n  return false;\n})() : false;\n// Detect WebKit bug: <github.com/slevithan/oniguruma-to-es/issues/38>\nenvFlags.bugNestedClassIgnoresNegation = envFlags.unicodeSets && new RegExp('[[^a]]', 'v').test('a');\n\nfunction getNewCurrentFlags(current, {enable, disable}) {\n  return {\n    dotAll: !disable?.dotAll && !!(enable?.dotAll || current.dotAll),\n    ignoreCase: !disable?.ignoreCase && !!(enable?.ignoreCase || current.ignoreCase),\n  };\n}\n\nfunction getOrInsert(map, key, defaultValue) {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key);\n}\n\n/**\n@param {keyof Target} target\n@param {keyof Target} min\n@returns {boolean}\n*/\nfunction isMinTarget(target, min) {\n  return EsVersion[target] >= EsVersion[min];\n}\n\nfunction throwIfNullish(value, msg) {\n  if (value == null) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cp,\n  envFlags,\n  getNewCurrentFlags,\n  getOrInsert,\n  isMinTarget,\n  r,\n  throwIfNullish,\n};\n", "import {envFlags} from './utils.js';\n/**\n@import {ToRegExpOptions} from './index.js';\n*/\n\nconst Accuracy = /** @type {const} */ ({\n  default: 'default',\n  strict: 'strict',\n});\n\nconst EsVersion = {\n  ES2025: 2025,\n  ES2024: 2024,\n  ES2018: 2018,\n};\n\nconst Target = /** @type {const} */ ({\n  auto: 'auto',\n  ES2025: 'ES2025',\n  ES2024: 'ES2024',\n  ES2018: 'ES2018',\n});\n\n/**\nReturns a complete set of options, with default values set for options that weren't provided.\n@param {ToRegExpOptions} [options]\n@returns {Required<ToRegExpOptions>}\n*/\nfunction getOptions(options = {}) {\n  if ({}.toString.call(options) !== '[object Object]') {\n    throw new Error('Unexpected options');\n  }\n  if (options.target !== undefined && !Target[options.target]) {\n    throw new Error(`Unexpected target \"${options.target}\"`)\n  }\n  // Set default values\n  const opts = {\n    // Sets the level of emulation rigor/strictness.\n    accuracy: 'default',\n    // Disables advanced emulation that relies on returning a `RegExp` subclass, resulting in\n    // certain patterns not being emulatable.\n    avoidSubclass: false,\n    // Oniguruma flags; a string with `i`, `m`, `x`, `D`, `S`, `W`, `y{g}` in any order (all\n    // optional). Oniguruma's `m` is equivalent to JavaScript's `s` (`dotAll`).\n    flags: '',\n    // Include JavaScript flag `g` (`global`) in the result.\n    global: false,\n    // Include JavaScript flag `d` (`hasIndices`) in the result.\n    hasIndices: false,\n    // Delay regex construction until first use if the transpiled pattern is at least this length.\n    lazyCompileLength: Infinity,\n    // JavaScript version used for generated regexes. Using `auto` detects the best value based on\n    // your environment. Later targets allow faster processing, simpler generated source, and\n    // support for additional features.\n    target: 'auto',\n    // Disables minifications that simplify the pattern without changing the meaning.\n    verbose: false,\n    ...options,\n    // Advanced options that override standard behavior, error checking, and flags when enabled.\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns.\n      allowOrphanBackrefs: false,\n      // Use ASCII `\\b` and `\\B`, which increases search performance of generated regexes.\n      asciiWordBoundaries: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // Change the recursion depth limit from Oniguruma's `20` to an integer `2`\u2013`20`.\n      recursionLimit: 20,\n      // `^` as `\\A`; `$` as`\\Z`. Improves search performance of generated regexes without changing\n      // the meaning if searching line by line. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...options.rules,\n    },\n  };\n  if (opts.target === 'auto') {\n    opts.target = envFlags.flagGroups ? 'ES2025' : (envFlags.unicodeSets ? 'ES2024' : 'ES2018');\n  }\n  return opts;\n}\n\nexport {\n  Accuracy,\n  EsVersion,\n  getOptions,\n  Target,\n};\n", "import {cp, r} from './utils.js';\nimport {slug} from 'oniguruma-parser/parser';\n\n// `\\t\\n\\v\\f\\r\\x20`\nconst asciiSpaceChar = '[\\t-\\r ]';\n\nconst CharsWithoutIgnoreCaseExpansion = new Set([\n  cp(0x130), // \u0130\n  cp(0x131), // \u0131\n]);\n\n// Different than `PosixClassMap`'s `word`\nconst defaultWordChar = r`[\\p{L}\\p{M}\\p{N}\\p{Pc}]`;\n\nfunction getIgnoreCaseMatchChars(char) {\n  // Some chars should not match the chars they case swap to\n  if (CharsWithoutIgnoreCaseExpansion.has(char)) {\n    return [char];\n  }\n  const set = new Set();\n  const lower = char.toLowerCase();\n  // Everything else is based on `lower`\n  const upper = lower.toUpperCase();\n  const title = LowerToTitleCaseMap.get(lower);\n  const altLower = LowerToAlternativeLowerCaseMap.get(lower);\n  const altUpper = LowerToAlternativeUpperCaseMap.get(lower);\n  // Exclude ucase if multiple chars; count code point length. Excludes ucase versions of German\n  // es-zed '\u00DF', ligatures like '\uFB00', and chars with no precomposed ucase like '\u0149'. See\n  // <unicode.org/Public/UNIDATA/SpecialCasing.txt>\n  if ([...upper].length === 1) {\n    set.add(upper);\n  }\n  altUpper && set.add(altUpper);\n  title && set.add(title);\n  // Lcase of '\u0130' is multiple chars, but it's excluded by `CharsWithoutIgnoreCaseExpansion`\n  set.add(lower);\n  altLower && set.add(altLower);\n  return [...set];\n}\n\n// The following set includes:\n// - All ES2024 general categories and their aliases (all are supported by Oniguruma). See\n//   <github.com/mathiasbynens/unicode-match-property-value-ecmascript/blob/main/data/mappings.js>\n// - All ES2024 binary properties and their aliases (all are supported by Oniguruma). See\n//   <tc39.es/ecma262/multipage/text-processing.html#table-binary-unicode-properties>\n// Unicode properties must be mapped to property names supported by JS, and must also apply JS's\n// stricter rules for casing, whitespace, hyphens, and underscores in Unicode property names. In\n// order to remain lightweight, this library assumes properties not in this list are Unicode script\n// names (which require a `Script=` or `sc=` prefix in JS). Unlike JS, Oniguruma doesn't support\n// script extensions, and it supports some properties that aren't supported in JS (including blocks\n// with an `In_` prefix). See also:\n// - Properties supported in Oniguruma: <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n// - Properties supported in JS by spec version: <github.com/eslint-community/regexpp/blob/main/src/unicode/properties.ts>\nconst JsUnicodePropertyMap = /* @__PURE__ */ new Map(\n`C Other\nCc Control cntrl\nCf Format\nCn Unassigned\nCo Private_Use\nCs Surrogate\nL Letter\nLC Cased_Letter\nLl Lowercase_Letter\nLm Modifier_Letter\nLo Other_Letter\nLt Titlecase_Letter\nLu Uppercase_Letter\nM Mark Combining_Mark\nMc Spacing_Mark\nMe Enclosing_Mark\nMn Nonspacing_Mark\nN Number\nNd Decimal_Number digit\nNl Letter_Number\nNo Other_Number\nP Punctuation punct\nPc Connector_Punctuation\nPd Dash_Punctuation\nPe Close_Punctuation\nPf Final_Punctuation\nPi Initial_Punctuation\nPo Other_Punctuation\nPs Open_Punctuation\nS Symbol\nSc Currency_Symbol\nSk Modifier_Symbol\nSm Math_Symbol\nSo Other_Symbol\nZ Separator\nZl Line_Separator\nZp Paragraph_Separator\nZs Space_Separator\nASCII\nASCII_Hex_Digit AHex\nAlphabetic Alpha\nAny\nAssigned\nBidi_Control Bidi_C\nBidi_Mirrored Bidi_M\nCase_Ignorable CI\nCased\nChanges_When_Casefolded CWCF\nChanges_When_Casemapped CWCM\nChanges_When_Lowercased CWL\nChanges_When_NFKC_Casefolded CWKCF\nChanges_When_Titlecased CWT\nChanges_When_Uppercased CWU\nDash\nDefault_Ignorable_Code_Point DI\nDeprecated Dep\nDiacritic Dia\nEmoji\nEmoji_Component EComp\nEmoji_Modifier EMod\nEmoji_Modifier_Base EBase\nEmoji_Presentation EPres\nExtended_Pictographic ExtPict\nExtender Ext\nGrapheme_Base Gr_Base\nGrapheme_Extend Gr_Ext\nHex_Digit Hex\nIDS_Binary_Operator IDSB\nIDS_Trinary_Operator IDST\nID_Continue IDC\nID_Start IDS\nIdeographic Ideo\nJoin_Control Join_C\nLogical_Order_Exception LOE\nLowercase Lower\nMath\nNoncharacter_Code_Point NChar\nPattern_Syntax Pat_Syn\nPattern_White_Space Pat_WS\nQuotation_Mark QMark\nRadical\nRegional_Indicator RI\nSentence_Terminal STerm\nSoft_Dotted SD\nTerminal_Punctuation Term\nUnified_Ideograph UIdeo\nUppercase Upper\nVariation_Selector VS\nWhite_Space space\nXID_Continue XIDC\nXID_Start XIDS`.\n  split(/\\s/).\n  map(p => [slug(p), p])\n);\n\nconst LowerToAlternativeLowerCaseMap = new Map([\n  ['s', cp(0x17F)], // s, \u017F\n  [cp(0x17F), 's'], // \u017F, s\n]);\n\nconst LowerToAlternativeUpperCaseMap = new Map([\n  [cp(0xDF), cp(0x1E9E)], // \u00DF, \u1E9E\n  [cp(0x6B), cp(0x212A)], // k, \u212A (Kelvin)\n  [cp(0xE5), cp(0x212B)], // \u00E5, \u212B (Angstrom)\n  [cp(0x3C9), cp(0x2126)], // \u03C9, \u2126 (Ohm)\n]);\n\n// See <github.com/node-unicode/unicode-16.0.0/tree/main/General_Category/Titlecase_Letter>\nconst LowerToTitleCaseMap = new Map([\n  titleEntry(0x1C5),\n  titleEntry(0x1C8),\n  titleEntry(0x1CB),\n  titleEntry(0x1F2),\n  ...titleRange(0x1F88, 0x1F8F),\n  ...titleRange(0x1F98, 0x1F9F),\n  ...titleRange(0x1FA8, 0x1FAF),\n  titleEntry(0x1FBC),\n  titleEntry(0x1FCC),\n  titleEntry(0x1FFC),\n]);\n\n// Unlike Onig's Unicode properties via `\\p` and `\\P`, these names are case sensitive and don't\n// allow inserting whitespace and underscores. Definitions at\n// <github.com/kkos/oniguruma/blob/master/doc/RE> (see: POSIX bracket: Unicode Case)\n// Note: Handling in the transformer assumes all values here are a single, negateable node that's\n// not pre-negated at the top level. It also uses ASCII versions of `graph` and `print` for target\n// `ES2018` (which doesn't allow intersection) if `accuracy` isn't `strict`\nconst PosixClassMap = new Map([\n  ['alnum', r`[\\p{Alpha}\\p{Nd}]`],\n  ['alpha', r`\\p{Alpha}`],\n  ['ascii', r`\\p{ASCII}`],\n  ['blank', r`[\\p{Zs}\\t]`],\n  ['cntrl', r`\\p{Cc}`],\n  ['digit', r`\\p{Nd}`],\n  ['graph', r`[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]`],\n  ['lower', r`\\p{Lower}`],\n  ['print', r`[[\\P{space}&&\\P{Cc}&&\\P{Cn}&&\\P{Cs}]\\p{Zs}]`],\n  ['punct', r`[\\p{P}\\p{S}]`], // Updated value from Onig 6.9.9; changed from Unicode `\\p{punct}`\n  ['space', r`\\p{space}`],\n  ['upper', r`\\p{Upper}`],\n  ['word', r`[\\p{Alpha}\\p{M}\\p{Nd}\\p{Pc}]`],\n  ['xdigit', r`\\p{AHex}`],\n]);\n\nfunction range(start, end) {\n  // const range = Array.from(Array(end + 1 - start), (_, i) => i + start);\n  // const range = Array(end + 1 - start).fill(start).map((x, i) => x + i);\n  const range = [];\n  for (let i = start; i <= end; i++) {\n    range.push(i);\n  }\n  return range;\n}\n\nfunction titleEntry(codePoint) {\n  const char = cp(codePoint);\n  return [char.toLowerCase(), char];\n}\n\nfunction titleRange(start, end) {\n  return range(start, end).map(codePoint => titleEntry(codePoint));\n}\n\nconst UnicodePropertiesWithSpecificCase = new Set([\n  'Lower', 'Lowercase',\n  'Upper', 'Uppercase',\n  'Ll', 'Lowercase_Letter',\n  'Lt', 'Titlecase_Letter',\n  'Lu', 'Uppercase_Letter',\n  // The `Changes_When_*` properties (and their aliases) could be included, but they're very rare.\n  // Some other properties include a handful of chars with specific cases only, but these chars are\n  // generally extreme edge cases and using such properties case insensitively generally produces\n  // undesired behavior anyway\n]);\n\nexport {\n  asciiSpaceChar,\n  defaultWordChar,\n  getIgnoreCaseMatchChars,\n  JsUnicodePropertyMap,\n  PosixClassMap,\n  UnicodePropertiesWithSpecificCase,\n};\n", "import {Accuracy, Target} from './options.js';\nimport {asciiSpaceChar, defaultWordChar, JsUnicodePropertyMap, PosixClassMap} from './unicode.js';\nimport {cp, getNewCurrentFlags, getOrInsert, isMinTarget, r} from './utils.js';\nimport {createAlternative, createAssertion, createBackreference, createCapturingGroup, createCharacter, createCharacterClass, createCharacterSet, createGroup, createLookaroundAssertion, createQuantifier, createSubroutine, createUnicodeProperty, hasOnlyChild, parse, slug} from 'oniguruma-parser/parser';\nimport {traverse} from 'oniguruma-parser/traverser';\n/**\n@import {CapturingGroupNode, OnigurumaAst, Node} from 'oniguruma-parser/parser';\n@import {Visitor} from 'oniguruma-parser/traverser';\n*/\n\n/**\n@typedef {\n  OnigurumaAst & {\n    options: {\n      disable: {[key: string]: boolean};\n      force: {[key: string]: boolean};\n    };\n    _originMap: Map<CapturingGroupNode, CapturingGroupNode>;\n    _strategy: string | null;\n  }\n} RegexPlusAst\n*/\n/**\nTransforms an Oniguruma AST in-place to a [Regex+](https://github.com/slevithan/regex) AST.\nAssumes target ES2025, expecting the generator to down-convert to the desired JS target version.\n\nRegex+'s syntax and behavior is a strict superset of native JavaScript, so the AST is very close\nto representing native ES2025 `RegExp` but with some added features (atomic groups, possessive\nquantifiers, recursion). The AST doesn't use some of Regex+'s extended features like flag x or\nsubroutines because they follow PCRE behavior and work somewhat differently than in Oniguruma. The\nAST represents what's needed to precisely reproduce Oniguruma behavior using Regex+.\n@param {OnigurumaAst} ast\n@param {{\n  accuracy?: keyof Accuracy;\n  asciiWordBoundaries?: boolean;\n  avoidSubclass?: boolean;\n  bestEffortTarget?: keyof Target;\n}} [options]\n@returns {RegexPlusAst}\n*/\nfunction transform(ast, options) {\n  const opts = {\n    // A couple edge cases exist where options `accuracy` and `bestEffortTarget` are used:\n    // - `CharacterSet` kind `text_segment` (`\\X`): An exact representation would require heavy\n    //   Unicode data; a best-effort approximation requires knowing the target.\n    // - `CharacterSet` kind `posix` with values `graph` and `print`: Their complex Unicode\n    //   representations would be hard to change to ASCII versions after the fact in the generator\n    //   based on `target`/`accuracy`, so produce the appropriate structure here.\n    accuracy: 'default',\n    asciiWordBoundaries: false,\n    avoidSubclass: false,\n    bestEffortTarget: 'ES2025',\n    ...options,\n  };\n  // Add `parent` properties to all nodes to help during traversal; also expected by the generator\n  addParentProperties(ast);\n  const firstPassState = {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    flagDirectivesByAlt: new Map(),\n    jsGroupNameMap: new Map(),\n    minTargetEs2024: isMinTarget(opts.bestEffortTarget, 'ES2024'),\n    passedLookbehind: false,\n    strategy: null,\n    // Subroutines can appear before the groups they ref, so collect reffed nodes for a second pass \n    subroutineRefMap: new Map(),\n    supportedGNodes: new Set(),\n    digitIsAscii: ast.flags.digitIsAscii,\n    spaceIsAscii: ast.flags.spaceIsAscii,\n    wordIsAscii: ast.flags.wordIsAscii,\n  };\n  traverse(ast, FirstPassVisitor, firstPassState);\n  // Global flags modified by the first pass\n  const globalFlags = {\n    dotAll: ast.flags.dotAll,\n    ignoreCase: ast.flags.ignoreCase,\n  };\n  // The interplay of subroutines (with Onig's unique rules/behavior for them; see comments in the\n  // parser for details) with backref multiplexing (a unique Onig feature), flag modifiers, and\n  // duplicate group names (which might be indirectly referenced by subroutines even though\n  // subroutines can't directly reference duplicate names) is extremely complicated to emulate in\n  // JS in a way that handles all edge cases, so we need multiple passes to do it\n  const secondPassState = {\n    currentFlags: globalFlags,\n    prevFlags: null,\n    globalFlags,\n    groupOriginByCopy: new Map(),\n    groupsByName: new Map(),\n    multiplexCapturesToLeftByRef: new Map(),\n    openRefs: new Map(),\n    reffedNodesByReferencer: new Map(),\n    subroutineRefMap: firstPassState.subroutineRefMap,\n  };\n  traverse(ast, SecondPassVisitor, secondPassState);\n  const thirdPassState = {\n    groupsByName: secondPassState.groupsByName,\n    highestOrphanBackref: 0,\n    numCapturesToLeft: 0,\n    reffedNodesByReferencer: secondPassState.reffedNodesByReferencer,\n  };\n  traverse(ast, ThirdPassVisitor, thirdPassState);\n  ast._originMap = secondPassState.groupOriginByCopy;\n  ast._strategy = firstPassState.strategy;\n  return ast;\n}\n\nconst /** @type {Visitor} */ FirstPassVisitor = {\n  AbsenceFunction({node, parent, replaceWith}) {\n    const {body, kind} = node;\n    if (kind === 'repeater') {\n      // Convert `(?~\u2026)` to `(?:(?:(?!\u2026)\\p{Any})*)`\n      const innerGroup = createGroup();\n      innerGroup.body[0].body.push(\n        // Insert own alts as `body`\n        createLookaroundAssertion({negate: true, body}),\n        createUnicodeProperty('Any')\n      );\n      const outerGroup = createGroup();\n      outerGroup.body[0].body.push(\n        createQuantifier('greedy', 0, Infinity, innerGroup)\n      );\n      replaceWith(setParentDeep(outerGroup, parent), {traverse: true});\n    } else {\n      throw new Error(`Unsupported absence function \"(?~|\"`);\n    }\n  },\n\n  Alternative: {\n    enter({node, parent, key}, {flagDirectivesByAlt}) {\n      // Look for own-level flag directives when entering an alternative because after traversing\n      // the directive itself, any subsequent flag directives will no longer be at the same level\n      const flagDirectives = node.body.filter(el => el.kind === 'flags');\n      for (let i = key + 1; i < parent.body.length; i++) {\n        const forwardSiblingAlt = parent.body[i];\n        getOrInsert(flagDirectivesByAlt, forwardSiblingAlt, []).push(...flagDirectives);\n      }\n    },\n    exit({node}, {flagDirectivesByAlt}) {\n      // Wait until exiting to wrap an alternative's nodes with flag groups that extend flag\n      // directives from prior sibling alternatives, because doing this at the end allows inner\n      // nodes to accurately check their level in the tree\n      if (flagDirectivesByAlt.get(node)?.length) {\n        const flags = getCombinedFlagModsFromFlagNodes(flagDirectivesByAlt.get(node));\n        if (flags) {\n          const flagGroup = createGroup({flags});\n          flagGroup.body[0].body = node.body;\n          node.body = [setParentDeep(flagGroup, node)];\n        }\n      }\n    },\n  },\n\n  Assertion({node, parent, key, container, root, remove, replaceWith}, state) {\n    const {kind, negate} = node;\n    const {asciiWordBoundaries, avoidSubclass, supportedGNodes, wordIsAscii} = state;\n    if (kind === 'text_segment_boundary') {\n      // Supported by the parser but not yet for transpilation\n      throw new Error(`Unsupported text segment boundary \"\\\\${negate ? 'Y' : 'y'}\"`);\n    } else if (kind === 'line_end') {\n      replaceWith(setParentDeep(createLookaroundAssertion({body: [\n        createAlternative({body: [createAssertion('string_end')]}),\n        createAlternative({body: [createCharacter(10)]}), // `\\n`\n      ]}), parent));\n    } else if (kind === 'line_start') {\n      // Onig's `^` doesn't match after a string-terminating line feed\n      replaceWith(setParentDeep(parseFragment(r`(?<=\\A|\\n(?!\\z))`, {skipLookbehindValidation: true}), parent));\n    } else if (kind === 'search_start') {\n      if (supportedGNodes.has(node)) {\n        root.flags.sticky = true;\n        remove();\n      } else {\n        const prev = container[key - 1]; // parent.body[key - 1]\n        // Not all ways of blocking the `\\G` from matching are covered here (ex: a node prior to\n        // the `prev` node could block), but blocked `\\G` is an edge case and it's okay if some\n        // blocked cases result in the standard error for being unsupported without a subclass\n        if (prev && isAlwaysNonZeroLength(prev)) {\n          replaceWith(setParentDeep(createLookaroundAssertion({negate: true}), parent));\n        } else if (avoidSubclass) {\n          throw new Error(r`Uses \"\\G\" in a way that requires a subclass`);\n        } else {\n          replaceWith(setParent(createAssertion('string_start'), parent));\n          state.strategy = 'clip_search';\n        }\n      }\n    } else if (kind === 'string_end' || kind === 'string_start') {\n      // Don't need transformation since JS flag m isn't used\n    } else if (kind === 'string_end_newline') {\n      replaceWith(setParentDeep(parseFragment(r`(?=\\n?\\z)`), parent));\n    } else if (kind === 'word_boundary') {\n      if (!wordIsAscii && !asciiWordBoundaries) {\n        const b = `(?:(?<=${defaultWordChar})(?!${defaultWordChar})|(?<!${defaultWordChar})(?=${defaultWordChar}))`;\n        const B = `(?:(?<=${defaultWordChar})(?=${defaultWordChar})|(?<!${defaultWordChar})(?!${defaultWordChar}))`;\n        replaceWith(setParentDeep(parseFragment(negate ? B : b), parent));\n      }\n    } else {\n      throw new Error(`Unexpected assertion kind \"${kind}\"`);\n    }\n  },\n\n  Backreference({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidJsGroupName(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n\n  CapturingGroup({node}, {jsGroupNameMap, subroutineRefMap}) {\n    let {name} = node;\n    if (name && !isValidJsGroupName(name)) {\n      name = getAndStoreJsGroupName(name, jsGroupNameMap);\n      node.name = name;\n    }\n    subroutineRefMap.set(node.number, node);\n    if (name) {\n      subroutineRefMap.set(name, node);\n    }\n  },\n\n  CharacterClassRange({node, parent, replaceWith}) {\n    if (parent.kind === 'intersection') {\n      // JS doesn't allow intersection with ranges without a wrapper class\n      const cc = createCharacterClass({body: [node]});\n      replaceWith(setParentDeep(cc, parent), {traverse: true});\n    }\n  },\n\n  CharacterSet({node, parent, replaceWith}, {accuracy, minTargetEs2024, digitIsAscii, spaceIsAscii, wordIsAscii}) {\n    const {kind, negate, value} = node;\n    // Flag D with `\\d`, `\\p{Digit}`, `[[:digit:]]`\n    if (digitIsAscii && (kind === 'digit' || value === 'digit')) {\n      replaceWith(setParent(createCharacterSet('digit', {negate}), parent));\n      return;\n    }\n    // Flag S with `\\s`, `\\p{Space}`, `[[:space:]]`\n    if (spaceIsAscii && (kind === 'space' || value === 'space')) {\n      replaceWith(setParentDeep(setNegate(parseFragment(asciiSpaceChar), negate), parent));\n      return;\n    }\n    // Flag W with `\\w`, `\\p{Word}`, `[[:word:]]`\n    if (wordIsAscii && (kind === 'word' || value === 'word')) {\n      replaceWith(setParent(createCharacterSet('word', {negate}), parent));\n      return;\n    }\n    if (kind === 'any') {\n      replaceWith(setParent(createUnicodeProperty('Any'), parent));\n    } else if (kind === 'digit') {\n      replaceWith(setParent(createUnicodeProperty('Nd', {negate}), parent));\n    } else if (kind === 'dot') {\n      // No-op; doesn't need transformation\n    } else if (kind === 'text_segment') {\n      if (accuracy === 'strict') {\n        throw new Error(r`Use of \"\\X\" requires non-strict accuracy`);\n      }\n      // Emoji pattern based on <github.com/slevithan/emoji-regex-xs> but adapted for our use case\n      // Note: Not using raw strings to work around Bun \u2264 1.1.34 issue <github.com/oven-sh/bun/issues/7540>\n      const eBase = '\\\\p{Emoji}(?:\\\\p{EMod}|\\\\uFE0F\\\\u20E3?|[\\\\x{E0020}-\\\\x{E007E}]+\\\\x{E007F})?';\n      const emoji = r`\\p{RI}{2}|${eBase}(?:\\u200D${eBase})*`;\n      replaceWith(setParentDeep(parseFragment(\n        // Close approximation of an extended grapheme cluster; see: <unicode.org/reports/tr29/>\n        r`(?>\\r\\n|${minTargetEs2024 ? r`\\p{RGI_Emoji}` : emoji}|\\P{M}\\p{M}*)`,\n        // Allow JS property `RGI_Emoji` through\n        {skipPropertyNameValidation: true}\n      ), parent));\n    } else if (kind === 'hex') {\n      replaceWith(setParent(createUnicodeProperty('AHex', {negate}), parent));\n    } else if (kind === 'newline') {\n      replaceWith(setParentDeep(parseFragment(negate ? '[^\\n]' : '(?>\\r\\n?|[\\n\\v\\f\\x85\\u2028\\u2029])'), parent));\n    } else if (kind === 'posix') {\n      if (!minTargetEs2024 && (value === 'graph' || value === 'print')) {\n        if (accuracy === 'strict') {\n          throw new Error(`POSIX class \"${value}\" requires min target ES2024 or non-strict accuracy`);\n        }\n        let ascii = {\n          graph: '!-~',\n          print: ' -~',\n        }[value];\n        if (negate) {\n          // POSIX classes are always nested in a char class; manually invert the range rather than\n          // using `[^\u2026]` so it can be unwrapped since ES2018 doesn't support nested classes\n          ascii = `\\0-${cp(ascii.codePointAt(0) - 1)}${cp(ascii.codePointAt(2) + 1)}-\\u{10FFFF}`;\n        }\n        replaceWith(setParentDeep(parseFragment(`[${ascii}]`), parent));\n      } else {\n        replaceWith(setParentDeep(setNegate(parseFragment(PosixClassMap.get(value)), negate), parent));\n      }\n    } else if (kind === 'property') {\n      if (!JsUnicodePropertyMap.has(slug(value))) {\n        // Assume it's a script; no error checking is the price for avoiding heavyweight Unicode\n        // data for all script names\n        node.key = 'sc';\n      }\n    } else if (kind === 'space') {\n      // Can't use JS's Unicode `\\s` since unlike Onig it includes `\\uFEFF` and excludes `\\x85`\n      replaceWith(setParent(createUnicodeProperty('space', {negate}), parent));\n    } else if (kind === 'word') {\n      replaceWith(setParentDeep(setNegate(parseFragment(defaultWordChar), negate), parent));\n    } else {\n      throw new Error(`Unexpected character set kind \"${kind}\"`);\n    }\n  },\n\n  Directive({node, parent, root, remove, replaceWith, removeAllPrevSiblings, removeAllNextSiblings}) {\n    const {kind, flags} = node;\n    if (kind === 'flags') {\n      if (!flags.enable && !flags.disable) {\n        // Flag directive without flags; ex: `(?-)`, `(?--)`\n        remove();\n      } else {\n        const flagGroup = createGroup({flags});\n        flagGroup.body[0].body = removeAllNextSiblings();\n        replaceWith(setParentDeep(flagGroup, parent), {traverse: true});\n      }\n    } else if (kind === 'keep') {\n      const firstAlt = root.body[0];\n      // Supporting a full-pattern wrapper around `\\K` enables use with flag modifiers\n      const hasWrapperGroup =\n        root.body.length === 1 &&\n        // Not emulatable if within a `CapturingGroup`\n        hasOnlyChild(firstAlt, {type: 'Group'}) &&\n        firstAlt.body[0].body.length === 1;\n      const topLevel = hasWrapperGroup ? firstAlt.body[0] : root;\n      if (parent.parent !== topLevel || topLevel.body.length > 1) {\n        throw new Error(r`Uses \"\\K\" in a way that's unsupported`);\n      }\n      const lookbehind = createLookaroundAssertion({behind: true});\n      lookbehind.body[0].body = removeAllPrevSiblings();\n      replaceWith(setParentDeep(lookbehind, parent));\n    } else {\n      throw new Error(`Unexpected directive kind \"${kind}\"`);\n    }\n  },\n\n  Flags({node, parent}) {\n    // Throw for flags supported by the parser but not yet for transpilation\n    if (node.posixIsAscii) {\n      throw new Error('Unsupported flag \"P\"');\n    }\n    if (node.textSegmentMode === 'word') {\n      throw new Error('Unsupported flag \"y{w}\"');\n    }\n    // Remove Onig flags that aren't available in JS\n    [ 'digitIsAscii', // Flag D\n      'extended', // Flag x\n      'posixIsAscii', // Flag P\n      'spaceIsAscii', // Flag S\n      'wordIsAscii', // Flag W\n      'textSegmentMode', // Flag y{g} or y{w}\n    ].forEach(f => delete node[f]);\n    Object.assign(node, {\n      // JS flag g; no Onig equiv\n      global: false,\n      // JS flag d; no Onig equiv\n      hasIndices: false,\n      // JS flag m; no Onig equiv but its behavior is always on in Onig. Onig's only line break\n      // char is line feed, unlike JS, so this flag isn't used since it would produce inaccurate\n      // results (also allows `^` and `$` to be used in the generator for string start and end)\n      multiline: false,\n      // JS flag y; no Onig equiv, but used for `\\G` emulation\n      sticky: node.sticky ?? false,\n      // Note: Regex+ doesn't allow explicitly adding flags it handles implicitly, so leave out\n      // properties `unicode` (JS flag u) and `unicodeSets` (JS flag v). Keep the existing values\n      // for `ignoreCase` (flag i) and `dotAll` (JS flag s, but Onig flag m)\n    });\n    // Options accepted by Regex+; see <github.com/slevithan/regex#-options>\n    parent.options = {\n      disable: {\n        // Onig uses different rules for flag x than Regex+, so disable the implicit flag\n        x: true,\n        // Onig has no flag to control \"named capture only\" mode but contextually applies its\n        // behavior when named capturing is used, so disable Regex+'s implicit flag for it\n        n: true,\n      },\n      force: {\n        // Always add flag v because we're generating an AST that relies on it (it enables JS\n        // support for Onig features nested classes, intersection, Unicode properties, etc.).\n        // However, the generator might disable flag v based on its `target` option\n        v: true,\n      },\n    };\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    const {enable, disable} = node.flags;\n    // Onig's flag x (`extended`) isn't available in JS\n    enable?.extended && delete enable.extended;\n    disable?.extended && delete disable.extended;\n    // JS doesn't support flag groups that enable and disable the same flag; ex: `(?i-i:)`\n    enable?.dotAll && disable?.dotAll && delete enable.dotAll;\n    enable?.ignoreCase && disable?.ignoreCase && delete enable.ignoreCase;\n    // Cleanup\n    enable && !Object.keys(enable).length && delete node.flags.enable;\n    disable && !Object.keys(disable).length && delete node.flags.disable;\n    !node.flags.enable && !node.flags.disable && delete node.flags;\n  },\n\n  LookaroundAssertion({node}, state) {\n    const {kind} = node;\n    if (kind === 'lookbehind') {\n      state.passedLookbehind = true;\n    }\n  },\n\n  NamedCallout({node, parent, replaceWith}) {\n    const {kind} = node;\n    if (kind === 'fail') {\n      replaceWith(setParentDeep(createLookaroundAssertion({negate: true}), parent));\n    } else {\n      throw new Error(`Unsupported named callout \"(*${kind.toUpperCase()}\"`);\n    }\n  },\n\n  Quantifier({node}) {\n    if (node.body.type === 'Quantifier') {\n      // Change e.g. `a**` to `(?:a*)*`\n      const group = createGroup();\n      group.body[0].body.push(node.body);\n      node.body = setParentDeep(group, node);\n    }\n  },\n\n  Regex: {\n    enter({node}, {supportedGNodes}) {\n      // For `\\G` to be accurately emulatable using JS flag y, it must be at (and only at) the start\n      // of every top-level alternative (with complex rules for what determines being at the start).\n      // Additional `\\G` error checking in `Assertion` visitor\n      const leadingGs = [];\n      let hasAltWithLeadG = false;\n      let hasAltWithoutLeadG = false;\n      for (const alt of node.body) {\n        if (alt.body.length === 1 && alt.body[0].kind === 'search_start') {\n          // Remove the `\\G` (leaving behind an empty alternative, and without adding JS flag y)\n          // since a top-level alternative that includes only `\\G` always matches at the start of the\n          // match attempt. Note that this is based on Oniguruma's rules, and is different than other\n          // regex flavors where `\\G` matches at the end of the previous match (a subtle distinction\n          // that's relevant after zero-length matches)\n          alt.body.pop();\n        } else {\n          const leadingG = getLeadingG(alt.body);\n          if (leadingG) {\n            hasAltWithLeadG = true;\n            Array.isArray(leadingG) ?\n              leadingGs.push(...leadingG) :\n              leadingGs.push(leadingG);\n          } else {\n            hasAltWithoutLeadG = true;\n          }\n        }\n      }\n      if (hasAltWithLeadG && !hasAltWithoutLeadG) {\n        // Supported `\\G` nodes will be removed (and add flag y) when traversed\n        leadingGs.forEach(g => supportedGNodes.add(g));\n      }\n    },\n    exit(_, {accuracy, passedLookbehind, strategy}) {\n      if (accuracy === 'strict' && passedLookbehind && strategy) {\n        throw new Error(r`Uses \"\\G\" in a way that requires non-strict accuracy`);\n      }\n    },\n  },\n\n  Subroutine({node}, {jsGroupNameMap}) {\n    let {ref} = node;\n    if (typeof ref === 'string' && !isValidJsGroupName(ref)) {\n      ref = getAndStoreJsGroupName(ref, jsGroupNameMap);\n      node.ref = ref;\n    }\n  },\n};\n\nconst /** @type {Visitor} */ SecondPassVisitor = {\n  Backreference({node}, {multiplexCapturesToLeftByRef, reffedNodesByReferencer}) {\n    const {orphan, ref} = node;\n    if (!orphan) {\n      // Copy the current state for later multiplexing expansion. That's done in a subsequent pass\n      // because backref numbers need to be recalculated after subroutine expansion\n      reffedNodesByReferencer.set(node, [...multiplexCapturesToLeftByRef.get(ref).map(({node}) => node)]);\n    }\n  },\n\n  CapturingGroup: {\n    enter(\n      { node,\n        parent,\n        replaceWith,\n        skip,\n      },\n      { groupOriginByCopy,\n        groupsByName,\n        multiplexCapturesToLeftByRef,\n        openRefs,\n        reffedNodesByReferencer,\n      }\n    ) {\n      // Has value if we're within a subroutine expansion\n      const origin = groupOriginByCopy.get(node);\n\n      // ## Handle recursion; runs after subroutine expansion\n      if (origin && openRefs.has(node.number)) {\n        // Recursive subroutines don't affect any following backrefs to their `ref` (unlike other\n        // subroutines), so don't wrap with a capture. The reffed group might have its name removed\n        // due to later subroutine expansion\n        const recursion = setParent(createRecursion(node.number), parent);\n        reffedNodesByReferencer.set(recursion, openRefs.get(node.number));\n        replaceWith(recursion);\n        return;\n      }\n      openRefs.set(node.number, node);\n\n      // ## Track data for backref multiplexing\n      multiplexCapturesToLeftByRef.set(node.number, []);\n      if (node.name) {\n        getOrInsert(multiplexCapturesToLeftByRef, node.name, []);\n      }\n      const multiplexNodes = multiplexCapturesToLeftByRef.get(node.name ?? node.number);\n      for (let i = 0; i < multiplexNodes.length; i++) {\n        // Captures added via subroutine expansion (maybe indirectly because they were descendant\n        // captures of the reffed group or in a nested subroutine expansion) form a set with their\n        // origin group and any other copies of it added via subroutines. Only the most recently\n        // matched within this set is added to backref multiplexing. So search the list of already-\n        // tracked multiplexed nodes for this group name or number to see if there's a node being\n        // replaced by this capture\n        const multiplex = multiplexNodes[i];\n        if (\n          // This group is from subroutine expansion, and there's a multiplex value from either the\n          // origin node or a prior subroutine expansion group with the same origin\n          (origin === multiplex.node || (origin && origin === multiplex.origin)) ||\n          // This group is not from subroutine expansion, and it comes after a subroutine expansion\n          // group that refers to this group\n          node === multiplex.origin\n        ) {\n          multiplexNodes.splice(i, 1);\n          break;\n        }\n      }\n      multiplexCapturesToLeftByRef.get(node.number).push({node, origin});\n      if (node.name) {\n        multiplexCapturesToLeftByRef.get(node.name).push({node, origin});\n      }\n\n      // ## Track data for duplicate names\n      // Pre-ES2025 doesn't allow duplicate names, but ES2025 allows duplicate names that are\n      // unique per mutually exclusive alternation path. However, Oniguruma's handling for named\n      // subpatterns on match results means we can't use this ES2025 feature even when in an ES2025\n      // env. So, if using a duplicate name, remove the name from all but the first instance that\n      // wasn't created by subroutine expansion\n      if (node.name) {\n        const groupsWithSameName = getOrInsert(groupsByName, node.name, new Map());\n        let hasDuplicateNameToRemove = false;\n        if (origin) {\n          // Subroutines and their child captures shouldn't hold duplicate names in the final state\n          hasDuplicateNameToRemove = true;\n        } else {\n          for (const groupInfo of groupsWithSameName.values()) {\n            if (!groupInfo.hasDuplicateNameToRemove) {\n              // Will change to an unnamed capture in a later pass\n              hasDuplicateNameToRemove = true;\n              break;\n            }\n          }\n        }\n        groupsByName.get(node.name).set(node, {node, hasDuplicateNameToRemove});\n      }\n    },\n    exit({node}, {openRefs}) {\n      openRefs.delete(node.number);\n    },\n  },\n\n  Group: {\n    enter({node}, state) {\n      // Flag directives have already been converted to flag groups by the previous pass\n      state.prevFlags = state.currentFlags;\n      if (node.flags) {\n        state.currentFlags = getNewCurrentFlags(state.currentFlags, node.flags);\n      }\n    },\n    exit(_, state) {\n      state.currentFlags = state.prevFlags;\n    },\n  },\n\n  Subroutine({node, parent, replaceWith}, state) {\n    const {isRecursive, ref} = node;\n\n    // Subroutine nodes with `isRecursive` are created during the current traversal; they're only\n    // traversed here if a recursive subroutine created during traversal is then copied by a\n    // subroutine expansion, e.g. with `(?<a>\\g<a>)\\g<a>`\n    if (isRecursive) {\n      // Immediate parent is an alternative or quantifier; can skip\n      let reffed = parent;\n      while ((reffed = reffed.parent)) {\n        if (reffed.type === 'CapturingGroup' && (reffed.name === ref || reffed.number === ref)) {\n          break;\n        }\n      }\n      // Track the referenced node because `ref`s are rewritten in a subsequent pass; capturing\n      // group names and numbers might change due to subroutine expansion and duplicate group names\n      state.reffedNodesByReferencer.set(node, reffed);\n      return;\n    }\n\n    const reffedGroupNode = state.subroutineRefMap.get(ref);\n    // Other forms of recursion are handled by the `CapturingGroup` visitor\n    const isGlobalRecursion = ref === 0;\n    const expandedSubroutine = isGlobalRecursion ?\n      createRecursion(0) :\n      // The reffed group might itself contain subroutines, which are expanded during sub-traversal\n      cloneCapturingGroup(reffedGroupNode, state.groupOriginByCopy, null);\n    let replacement = expandedSubroutine;\n    if (!isGlobalRecursion) {\n      // Subroutines take their flags from the reffed group, not the flags surrounding themselves\n      const reffedGroupFlagMods = getCombinedFlagModsFromFlagNodes(getAllParents(\n        reffedGroupNode,\n        p => p.type === 'Group' && !!p.flags\n      ));\n      const reffedGroupFlags = reffedGroupFlagMods ?\n        getNewCurrentFlags(state.globalFlags, reffedGroupFlagMods) :\n        state.globalFlags;\n      if (!areFlagsEqual(reffedGroupFlags, state.currentFlags)) {\n        replacement = createGroup({\n          flags: getFlagModsFromFlags(reffedGroupFlags),\n        });\n        replacement.body[0].body.push(expandedSubroutine);\n      }\n    }\n    replaceWith(setParentDeep(replacement, parent), {traverse: !isGlobalRecursion});\n  },\n};\n\nconst /** @type {Visitor} */ ThirdPassVisitor = {\n  Backreference({node, parent, replaceWith}, state) {\n    if (node.orphan) {\n      state.highestOrphanBackref = Math.max(state.highestOrphanBackref, node.ref);\n      // Don't renumber; used with `allowOrphanBackrefs`\n      return;\n    }\n    const reffedNodes = state.reffedNodesByReferencer.get(node);\n    const participants = reffedNodes.filter(reffed => canParticipateWithNode(reffed, node));\n    // For the backref's `ref`, use `number` rather than `name` because group names might have been\n    // removed if they're duplicates within their alternation path, or they might be removed later\n    // by the generator (depending on target) if they're duplicates within the overall pattern.\n    // Backrefs must come after groups they ref, so reffed node `number`s are already recalculated\n    if (!participants.length) {\n      // If no participating capture, convert backref to to `(?!)`; backrefs to nonparticipating\n      // groups can't match in Onig but match the empty string in JS\n      replaceWith(setParentDeep(createLookaroundAssertion({negate: true}), parent));\n    } else if (participants.length > 1) {\n      // Multiplex for backrefs to duplicate capture names; try them in reverse order\n      const group = createGroup({\n        atomic: true,\n        body: participants.reverse().map(reffed => createAlternative({\n          body: [createBackreference(reffed.number)],\n        })),\n      });\n      replaceWith(setParentDeep(group, parent));\n    } else {\n      node.ref = participants[0].number;\n    }\n  },\n\n  CapturingGroup({node}, state) {\n    // Recalculate the number since the current value might be wrong due to subroutine expansion\n    node.number = ++state.numCapturesToLeft;\n    if (node.name) {\n      // Removing duplicate names here rather than in an earlier pass avoids extra complexity when\n      // handling subroutine expansion and backref multiplexing\n      if (state.groupsByName.get(node.name).get(node).hasDuplicateNameToRemove) {\n        delete node.name;\n      }\n    }\n  },\n\n  Regex: {\n    exit({node}, state) {\n      // HACK: Add unnamed captures to the end of the regex if needed to allow orphaned backrefs\n      // to be valid in JS with flag u/v. This is needed to support TextMate grammars, which\n      // replace numbered backrefs in their `end` pattern with values matched by captures in their\n      // `begin` pattern! See <github.com/microsoft/vscode-textmate/blob/7e0ea282f4f25fef12a6c84fa4fa7266f67b58dc/src/rule.ts#L661-L663>\n      // An `end` pattern, prior to this substitution, might have backrefs to a group that doesn't\n      // exist within `end`. This presents a dilemma since both Oniguruma and JS (with flag u/v)\n      // error for backrefs to undefined captures. So adding captures to the end is a solution that\n      // doesn't change what the regex matches, and lets invalid numbered backrefs through. Note:\n      // Orphan backrefs are only allowed if `allowOrphanBackrefs` is enabled\n      const numCapsNeeded = Math.max(state.highestOrphanBackref - state.numCapturesToLeft, 0);\n      for (let i = 0; i < numCapsNeeded; i++) {\n        const emptyCapture = createCapturingGroup();\n        node.body.at(-1).body.push(emptyCapture);\n      }\n    },\n  },\n\n  Subroutine({node}, state) {\n    if (!node.isRecursive || node.ref === 0) {\n      return;\n    }\n    // For the recursion's `ref`, use `number` rather than `name` because group names might have\n    // been removed if they're duplicates within their alternation path, or they might be removed\n    // later by the generator (depending on target) if they're duplicates within the overall\n    // pattern. Since recursion appears within the group it refs, the reffed node's `number` has\n    // already been recalculated\n    node.ref = state.reffedNodesByReferencer.get(node).number;\n  },\n};\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\nfunction addParentProperties(root) {\n  traverse(root, {\n    '*'({node, parent}) {\n      node.parent = parent;\n    },\n  });\n}\n\nfunction areFlagsEqual(a, b) {\n  return a.dotAll === b.dotAll && a.ignoreCase === b.ignoreCase;\n}\n\nfunction canParticipateWithNode(capture, node) {\n  // Walks to the left (prev siblings), down (sibling descendants), up (parent), then back down\n  // (parent's prev sibling descendants) the tree in a loop\n  let rightmostPoint = node;\n  do {\n    if (rightmostPoint.type === 'Regex') {\n      // End of the line; capture is not in node's alternation path\n      return false;\n    }\n    if (rightmostPoint.type === 'Alternative') {\n      // Skip past alts to their parent because we don't want to look at the kids of preceding alts\n      continue;\n    }\n    if (rightmostPoint === capture) {\n      // Capture is ancestor of node\n      return false;\n    }\n    const kidsOfParent = getKids(rightmostPoint.parent);\n    for (const kid of kidsOfParent) {\n      if (kid === rightmostPoint) {\n        // Reached rightmost node in sibling list that we want to consider; break to parent loop\n        break;\n      }\n      if (kid === capture || isAncestorOf(kid, capture)) {\n        return true;\n      }\n    }\n  } while ((rightmostPoint = rightmostPoint.parent));\n  throw new Error('Unexpected path');\n}\n\n// Creates a deep copy of the provided node, with special handling:\n// - Make `parent` props point to their parent in the copy\n// - Update the provided `originMap` for each cloned capturing group (outer and nested)\nfunction cloneCapturingGroup(obj, originMap, up, up2) {\n  const store = Array.isArray(obj) ? [] : {};\n  for (const [key, value] of Object.entries(obj)) {\n    if (key === 'parent') {\n      // If the last cloned item was a container array (for holding kids), use the object above it\n      store.parent = Array.isArray(up) ? up2 : up;\n    } else if (value && typeof value === 'object') {\n      store[key] = cloneCapturingGroup(value, originMap, store, up);\n    } else {\n      if (key === 'type' && value === 'CapturingGroup') {\n        // Key is the copied node, value is the origin node\n        originMap.set(store, originMap.get(obj) ?? obj);\n      }\n      store[key] = value;\n    }\n  }\n  return store;\n}\n\nfunction createRecursion(ref) {\n  const node = createSubroutine(ref);\n  // In the future, the parser will set a `recursive` property on subroutines:\n  // <github.com/slevithan/oniguruma-parser/issues/3>. When that's available, this function won't\n  // be needed and the related logic in this transformer should change (simplify) to use it\n  node.isRecursive = true;\n  return node;\n}\n\nfunction getAllParents(node, filterFn) {\n  const results = [];\n  while ((node = node.parent)) {\n    if (!filterFn || filterFn(node)) {\n      results.push(node);\n    }\n  }\n  return results;\n}\n\n// See also `isValidJsGroupName`\nfunction getAndStoreJsGroupName(name, map) {\n  if (map.has(name)) {\n    return map.get(name);\n  }\n  // Onig group names can't start with `$`, but JS names can\n  const jsName = `$${map.size}_${name.replace(/^[^$_\\p{IDS}]|[^$\\u200C\\u200D\\p{IDC}]/ug, '_')}`;\n  map.set(name, jsName);\n  return jsName;\n}\n\nfunction getCombinedFlagModsFromFlagNodes(flagNodes) {\n  const flagProps = ['dotAll', 'ignoreCase'];\n  const combinedFlags = {enable: {}, disable: {}};\n  flagNodes.forEach(({flags}) => {\n    flagProps.forEach(prop => {\n      if (flags.enable?.[prop]) {\n        // Need to remove `disable` since disabled flags take precedence\n        delete combinedFlags.disable[prop];\n        combinedFlags.enable[prop] = true;\n      }\n      if (flags.disable?.[prop]) {\n        combinedFlags.disable[prop] = true;\n      }\n    });\n  });\n  if (!Object.keys(combinedFlags.enable).length) {\n    delete combinedFlags.enable;\n  }\n  if (!Object.keys(combinedFlags.disable).length) {\n    delete combinedFlags.disable;\n  }\n  if (combinedFlags.enable || combinedFlags.disable) {\n    return combinedFlags;\n  }\n  return null;\n}\n\nfunction getFlagModsFromFlags({dotAll, ignoreCase}) {\n  const mods = {};\n  if (dotAll || ignoreCase) {\n    mods.enable = {};\n    dotAll && (mods.enable.dotAll = true);\n    ignoreCase && (mods.enable.ignoreCase = true);\n  }\n  if (!dotAll || !ignoreCase) {\n    mods.disable = {};\n    !dotAll && (mods.disable.dotAll = true);\n    !ignoreCase && (mods.disable.ignoreCase = true);\n  }\n  return mods;\n}\n\nfunction getKids(node) {\n  if (!node) {\n    throw new Error('Node expected');\n  }\n  // NOTE: Not handling `CharacterClassRange`'s `min`/`max` and `Regex`'s `flags`, only because\n  // they haven't been needed by current callers\n  const {body} = node;\n  return Array.isArray(body) ? body : (body ? [body] : null);\n}\n\nfunction getLeadingG(els) {\n  const firstToConsider = els.find(el => (\n    el.kind === 'search_start' ||\n    isLoneGLookaround(el, {negate: false}) ||\n    !isAlwaysZeroLength(el)\n  ));\n  if (!firstToConsider) {\n    return null;\n  }\n  if (firstToConsider.kind === 'search_start') {\n    return firstToConsider;\n  }\n  if (firstToConsider.type === 'LookaroundAssertion') {\n    return firstToConsider.body[0].body[0];\n  }\n  if (firstToConsider.type === 'CapturingGroup' || firstToConsider.type === 'Group') {\n    const gNodesForGroup = [];\n    // Recursively find `\\G` nodes for all alternatives in the group\n    for (const alt of firstToConsider.body) {\n      const leadingG = getLeadingG(alt.body);\n      if (!leadingG) {\n        // Don't return `gNodesForGroup` collected so far since this alt didn't qualify\n        return null;\n      }\n      Array.isArray(leadingG) ?\n        gNodesForGroup.push(...leadingG) :\n        gNodesForGroup.push(leadingG);\n    }\n    return gNodesForGroup;\n  }\n  return null;\n}\n\nfunction isAncestorOf(node, descendant) {\n  const kids = getKids(node) ?? [];\n  for (const kid of kids) {\n    if (kid === descendant || isAncestorOf(kid, descendant)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n@param {Node} node\n@returns {boolean}\n*/\nfunction isAlwaysZeroLength({type}) {\n  return (\n    type === 'Assertion' ||\n    type === 'Directive' ||\n    type === 'LookaroundAssertion'\n  );\n}\n\n/**\n@param {Node} node\n@returns {boolean}\n*/\nfunction isAlwaysNonZeroLength(node) {\n  const types = [\n    'Character',\n    'CharacterClass',\n    'CharacterSet',\n  ];\n  return types.includes(node.type) || (\n    node.type === 'Quantifier' &&\n    node.min &&\n    types.includes(node.body.type)\n  );\n}\n\nfunction isLoneGLookaround(node, options) {\n  const opts = {\n    negate: null,\n    ...options,\n  };\n  return (\n    node.type === 'LookaroundAssertion' &&\n    (opts.negate === null || node.negate === opts.negate) &&\n    node.body.length === 1 &&\n    hasOnlyChild(node.body[0], {\n      type: 'Assertion',\n      kind: 'search_start',\n    })\n  );\n}\n\n// See also `getAndStoreJsGroupName`\nfunction isValidJsGroupName(name) {\n  // JS group names are more restrictive than Onig; see\n  // <developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#identifiers>\n  return /^[$_\\p{IDS}][$\\u200C\\u200D\\p{IDC}]*$/u.test(name);\n}\n\n// Returns a single node, either the given node or all nodes wrapped in a noncapturing group\nfunction parseFragment(pattern, options) {\n  const ast = parse(pattern, {\n    ...options,\n    // Providing a custom set of Unicode property names avoids converting some JS Unicode\n    // properties (ex: `\\p{Alpha}`) to Onig POSIX classes\n    unicodePropertyMap: JsUnicodePropertyMap,\n  });\n  const alts = ast.body;\n  if (alts.length > 1 || alts[0].body.length > 1) {\n    return createGroup({body: alts});\n  }\n  return alts[0].body[0];\n}\n\nfunction setNegate(node, negate) {\n  node.negate = negate;\n  return node;\n}\n\nfunction setParent(node, parent) {\n  node.parent = parent;\n  return node;\n}\n\nfunction setParentDeep(node, parent) {\n  addParentProperties(node);\n  node.parent = parent;\n  return node;\n}\n\nexport {\n  transform,\n};\n", "import {getOptions} from './options.js';\nimport {getIgnoreCaseMatchChars, UnicodePropertiesWithSpecificCase} from './unicode.js';\nimport {cp, envFlags, getNewCurrentFlags, getOrInsert, isMinTarget, r, throwIfNullish} from './utils.js';\nimport {createAlternative, createCharacter, createGroup} from 'oniguruma-parser/parser';\nimport {traverse} from 'oniguruma-parser/traverser';\n/**\n@import {ToRegExpOptions} from './index.js';\n@import {RegexPlusAst} from './transform.js';\n@import {AlternativeNode, AssertionNode, BackreferenceNode, CapturingGroupNode, CharacterClassNode, CharacterClassRangeNode, CharacterNode, CharacterSetNode, FlagsNode, GroupNode, LookaroundAssertionNode, Node, QuantifierNode, SubroutineNode} from 'oniguruma-parser/parser';\n@import {Visitor} from 'oniguruma-parser/traverser';\n*/\n\n/**\nGenerates a Regex+ compatible `pattern`, `flags`, and `options` from a Regex+ AST.\n@param {RegexPlusAst} ast\n@param {ToRegExpOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options: Object;\n  _captureTransfers: Map<number, Array<number>>;\n  _hiddenCaptures: Array<number>;\n}}\n*/\nfunction generate(ast, options) {\n  const opts = getOptions(options);\n  const minTargetEs2024 = isMinTarget(opts.target, 'ES2024');\n  const minTargetEs2025 = isMinTarget(opts.target, 'ES2025');\n  const recursionLimit = opts.rules.recursionLimit;\n  if (!Number.isInteger(recursionLimit) || recursionLimit < 2 || recursionLimit > 20) {\n    throw new Error('Invalid recursionLimit; use 2-20');\n  }\n\n  // If the output can't use flag groups, we need a pre-pass to check for the use of chars with\n  // case in case sensitive/insensitive states. This minimizes the need for case expansions (though\n  // expansions are lossless, even given Unicode case complexities) and allows supporting case\n  // insensitive backrefs in more cases\n  // TODO: Consider gathering this data in the transformer's final traversal to avoid work here\n  let hasCaseInsensitiveNode = null;\n  let hasCaseSensitiveNode = null;\n  if (!minTargetEs2025) {\n    const iStack = [ast.flags.ignoreCase];\n    traverse(ast, FlagModifierVisitor, {\n      getCurrentModI: () => iStack.at(-1),\n      popModI() {iStack.pop()},\n      pushModI(isIOn) {iStack.push(isIOn)},\n      setHasCasedChar() {\n        if (iStack.at(-1)) {\n          hasCaseInsensitiveNode = true;\n        } else {\n          hasCaseSensitiveNode = true;\n        }\n      },\n    });\n  }\n\n  const appliedGlobalFlags = {\n    dotAll: ast.flags.dotAll,\n    // - Turn global flag i on if a case insensitive node was used and no case sensitive nodes were\n    //   used (to avoid unnecessary node expansion).\n    // - Turn global flag i off if a case sensitive node was used (since case sensitivity can't be\n    //   forced without the use of ES2025 flag groups)\n    ignoreCase: !!((ast.flags.ignoreCase || hasCaseInsensitiveNode) && !hasCaseSensitiveNode),\n  };\n  let /** @type {Node} */ lastNode = ast;\n  const state = {\n    accuracy: opts.accuracy,\n    appliedGlobalFlags,\n    captureMap: new Map(),\n    currentFlags: {\n      dotAll: ast.flags.dotAll,\n      ignoreCase: ast.flags.ignoreCase,\n    },\n    inCharClass: false,\n    lastNode,\n    originMap: ast._originMap,\n    recursionLimit,\n    useAppliedIgnoreCase: !!(!minTargetEs2025 && hasCaseInsensitiveNode && hasCaseSensitiveNode),\n    useFlagMods: minTargetEs2025,\n    useFlagV: minTargetEs2024,\n    verbose: opts.verbose,\n  };\n  function gen(/** @type {Node} */ node) {\n    state.lastNode = lastNode;\n    lastNode = node; // For the next iteration\n    const fn = throwIfNullish(generator[node.type], `Unexpected node type \"${node.type}\"`);\n    return fn(node, state, gen);\n  }\n\n  const result = {\n    pattern: ast.body.map(gen).join('|'),\n    // Could reset `lastNode` at this point via `lastNode = ast`, but it isn't needed by flags\n    flags: gen(ast.flags),\n    options: {...ast.options},\n  };\n  if (!minTargetEs2024) {\n    // Switch from flag v to u; Regex+ implicitly chooses by default\n    delete result.options.force.v;\n    result.options.disable.v = true;\n    result.options.unicodeSetsPlugin = null;\n  }\n  result._captureTransfers = new Map();\n  result._hiddenCaptures = [];\n  state.captureMap.forEach((value, key) => {\n    if (value.hidden) {\n      result._hiddenCaptures.push(key);\n    }\n    if (value.transferTo) {\n      getOrInsert(result._captureTransfers, value.transferTo, []).push(key);\n    }\n  });\n\n  return result;\n}\n\nconst /** @type {Visitor} */ FlagModifierVisitor = {\n  '*': {\n    enter({node}, state) {\n      if (isAnyGroup(node)) {\n        const currentModI = state.getCurrentModI();\n        state.pushModI(\n          node.flags ?\n            getNewCurrentFlags({ignoreCase: currentModI}, node.flags).ignoreCase :\n            currentModI\n        );\n      }\n    },\n    exit({node}, state) {\n      if (isAnyGroup(node)) {\n        state.popModI();\n      }\n    },\n  },\n  Backreference(_, state) {\n    // Can't know for sure, so assume the backref will include chars with case (best that could be\n    // done is not calling `setHasCasedChar` if the reffed group doesn't contain a char with case\n    // or most kinds of char sets)\n    state.setHasCasedChar();\n  },\n  Character({node}, state) {\n    if (charHasCase(cp(node.value))) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterClassRange({node, skip}, state) {\n    skip();\n    if (getCasesOutsideCharClassRange(node, {firstOnly: true}).length) {\n      state.setHasCasedChar();\n    }\n  },\n  CharacterSet({node}, state) {\n    if (\n      node.kind === 'property' &&\n      UnicodePropertiesWithSpecificCase.has(node.value)\n    ) {\n      state.setHasCasedChar();\n    }\n  },\n};\n\n// `AbsenceFunction`, `Directive`, and `NamedCallout` nodes aren't included in transformer output\nconst generator = {\n  /**\n  @param {AlternativeNode} node\n  */\n  Alternative({body}, _, gen) {\n    return body.map(gen).join('');\n  },\n\n  /**\n  @param {AssertionNode} node\n  */\n  Assertion({kind, negate}) {\n    // Can always use `^` and `$` for string boundaries since JS flag m is never used (Onig uses\n    // different line break chars)\n    if (kind === 'string_end') {\n      return '$';\n    }\n    if (kind === 'string_start') {\n      return '^';\n    }\n    // If a word boundary came through the transformer unaltered, that means `wordIsAscii` or\n    // `asciiWordBoundaries` is enabled\n    if (kind === 'word_boundary') {\n      return negate ? r`\\B` : r`\\b`;\n    }\n    // Kinds `line_end`, `line_start`, `search_start`, `string_end_newline`, and\n    // `text_segment_boundary` are never included in transformer output\n    throw new Error(`Unexpected assertion kind \"${kind}\"`);\n  },\n\n  /**\n  @param {BackreferenceNode} node\n  */\n  Backreference({ref}, state) {\n    if (typeof ref !== 'number') {\n      throw new Error('Unexpected named backref in transformed AST');\n    }\n    if (\n      !state.useFlagMods &&\n      state.accuracy === 'strict' &&\n      state.currentFlags.ignoreCase &&\n      !state.captureMap.get(ref).ignoreCase\n    ) {\n      throw new Error('Use of case-insensitive backref to case-sensitive group requires target ES2025 or non-strict accuracy');\n    }\n    return '\\\\' + ref;\n  },\n\n  /**\n  @param {CapturingGroupNode} node\n  */\n  CapturingGroup(node, state, gen) {\n    const {body, name, number} = node;\n    const data = {ignoreCase: state.currentFlags.ignoreCase};\n    // Has origin if the capture is from an expanded subroutine\n    const origin = state.originMap.get(node);\n    if (origin) {\n      // All captures from/within expanded subroutines are marked as hidden\n      data.hidden = true;\n      // If a subroutine (or descendant capture) occurs after its origin group, it's marked to have\n      // its captured value transferred to the origin's capture slot. `number` and `origin.number`\n      // are the capture numbers *after* subroutine expansion\n      if (number > origin.number) {\n        data.transferTo = origin.number;\n      }\n    }\n    state.captureMap.set(number, data);\n    return `(${name ? `?<${name}>` : ''}${body.map(gen).join('|')})`;\n  },\n\n  /**\n  @param {CharacterNode} node\n  */\n  Character({value}, state) {\n    const char = cp(value);\n    const escaped = getCharEscape(value, {\n      escDigit: state.lastNode.type === 'Backreference',\n      inCharClass: state.inCharClass,\n      useFlagV: state.useFlagV,\n    });\n    if (escaped !== char) {\n      return escaped;\n    }\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase && charHasCase(char)) {\n      const cases = getIgnoreCaseMatchChars(char);\n      return state.inCharClass ?\n        cases.join('') :\n        (cases.length > 1 ? `[${cases.join('')}]` : cases[0]);\n    }\n    return char;\n  },\n\n  /**\n  @param {CharacterClassNode} node\n  */\n  CharacterClass(node, state, gen) {\n    const {kind, negate, parent} = node;\n    let {body} = node;\n    if (kind === 'intersection' && !state.useFlagV) {\n      throw new Error('Use of class intersection requires min target ES2024');\n    }\n    // Work around a WebKit parser bug by moving literal hyphens to the beginning of the class; see\n    // <github.com/slevithan/oniguruma-to-es/issues/30>\n    if (envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV && body.some(isLiteralHyphen)) {\n      body = [createCharacter(45), ...body.filter(kid => !isLiteralHyphen(kid))];\n    }\n    const genClass = () => `[${negate ? '^' : ''}${\n      body.map(gen).join(kind === 'intersection' ? '&&' : '')\n    }]`;\n    if (!state.inCharClass) {\n      // HACK: Transform the AST to support top-level-nested, negated classes in non-negated\n      // classes (ex: `[\u2026[^\u2026]]`) with pre-ES2024 `target`, via `(?:[\u2026]|[^\u2026])` or `(?:[^\u2026])`,\n      // possibly with multiple alts that contain negated classes. Would be better to do this in\n      // the transformer, but it doesn't have true `target` since that's supposed to be a concern\n      // of the generator\n      if (\n        // Already established `kind !== 'intersection'` if `!state.useFlagV`; don't check again\n        (!state.useFlagV || envFlags.bugNestedClassIgnoresNegation) &&\n        !negate\n      ) {\n        const negatedChildClasses = body.filter(\n          kid => kid.type === 'CharacterClass' && kid.kind === 'union' && kid.negate\n        );\n        if (negatedChildClasses.length) {\n          const group = createGroup();\n          const groupFirstAlt = group.body[0];\n          group.parent = parent;\n          groupFirstAlt.parent = group;\n          body = body.filter(kid => !negatedChildClasses.includes(kid));\n          node.body = body;\n          if (body.length) {\n            node.parent = groupFirstAlt;\n            groupFirstAlt.body.push(node);\n          } else {\n            // Remove the group's only alt thus far, but since the class's `body` is empty, that\n            // implies there's at least one negated class we removed from it, so we'll add at least\n            // one alt back to the group, next\n            group.body.pop();\n          }\n          negatedChildClasses.forEach(cc => {\n            const newAlt = createAlternative({body: [cc]});\n            cc.parent = newAlt;\n            newAlt.parent = group;\n            group.body.push(newAlt);\n          });\n          return gen(group);\n        }\n      }\n      // For the outermost char class, set state\n      state.inCharClass = true;\n      const result = genClass();\n      state.inCharClass = false;\n      return result;\n    }\n    // No first element for implicit class in empty intersection like `[&&]`\n    const firstEl = body[0];\n    if (\n      // Already established that the parent is a char class via `inCharClass`; don't check again\n      kind === 'union' &&\n      !negate &&\n      firstEl &&\n      (\n        ( // Allows many nested classes to work with `target` ES2018 which doesn't support nesting\n          (!state.useFlagV || !state.verbose) &&\n          parent.kind === 'union' &&\n          !(envFlags.bugFlagVLiteralHyphenIsRange && state.useFlagV)\n        ) ||\n        ( !state.verbose &&\n          parent.kind === 'intersection' &&\n          // JS doesn't allow intersection with union or ranges\n          body.length === 1 &&\n          firstEl.type !== 'CharacterClassRange'\n        )\n      )\n    ) {\n      // Remove unnecessary nesting; unwrap kids into the parent char class\n      return body.map(gen).join('');\n    }\n    if (!state.useFlagV && parent.type === 'CharacterClass') {\n      throw new Error('Use of nested character class requires min target ES2024');\n    }\n    return genClass();\n  },\n\n  /**\n  @param {CharacterClassRangeNode} node\n  */\n  CharacterClassRange(node, state) {\n    const min = node.min.value;\n    const max = node.max.value;\n    const escOpts = {\n      escDigit: false,\n      inCharClass: true,\n      useFlagV: state.useFlagV,\n    };\n    const minStr = getCharEscape(min, escOpts);\n    const maxStr = getCharEscape(max, escOpts);\n    const extraChars = new Set();\n    if (state.useAppliedIgnoreCase && state.currentFlags.ignoreCase) {\n      // TODO: Avoid duplication by considering other chars in the parent char class when expanding\n      const charsOutsideRange = getCasesOutsideCharClassRange(node);\n      const ranges = getCodePointRangesFromChars(charsOutsideRange);\n      ranges.forEach(value => {\n        extraChars.add(\n          Array.isArray(value) ?\n            `${getCharEscape(value[0], escOpts)}-${getCharEscape(value[1], escOpts)}` :\n            getCharEscape(value, escOpts)\n        );\n      });\n    }\n    // Create the range without calling `gen` on the `min`/`max` kids\n    return `${minStr}-${maxStr}${[...extraChars].join('')}`;\n  },\n\n  /**\n  @param {CharacterSetNode} node\n  */\n  CharacterSet({kind, negate, value, key}, state) {\n    if (kind === 'dot') {\n      return state.currentFlags.dotAll ?\n        ((state.appliedGlobalFlags.dotAll || state.useFlagMods) ? '.' : '[^]') :\n        // Onig's only line break char is line feed, unlike JS\n        r`[^\\n]`;\n    }\n    if (kind === 'digit') {\n      return negate ? r`\\D` : r`\\d`;\n    }\n    if (kind === 'property') {\n      if (\n        state.useAppliedIgnoreCase &&\n        state.currentFlags.ignoreCase &&\n        UnicodePropertiesWithSpecificCase.has(value)\n      ) {\n        // Support for this would require heavy Unicode data. Could change e.g. `\\p{Lu}` to\n        // `\\p{LC}` if not using strict `accuracy` (since it's close but not 100%), but this\n        // wouldn't work for e.g. `\\p{Lt}`, and in any case, it's probably user error if using\n        // these case-specific props case-insensitively\n        throw new Error(`Unicode property \"${value}\" can't be case-insensitive when other chars have specific case`);\n      }\n      return `${negate ? r`\\P` : r`\\p`}{${key ? `${key}=` : ''}${value}}`;\n    }\n    if (kind === 'word') {\n      return negate ? r`\\W` : r`\\w`;\n    }\n    // Kinds `any`, `hex`, `newline`, `posix`, `space`, and `text_segment` are never included in\n    // transformer output\n    throw new Error(`Unexpected character set kind \"${kind}\"`);\n  },\n\n  /**\n  @param {FlagsNode} node\n  */\n  Flags(node, state) {\n    return (\n      // The transformer should never turn on the properties for flags d, g, m since Onig doesn't\n      // have equivs. Flag m is never used since Onig uses different line break chars than JS\n      // (node.hasIndices ? 'd' : '') +\n      // (node.global ? 'g' : '') +\n      // (node.multiline ? 'm' : '') +\n      (state.appliedGlobalFlags.ignoreCase ? 'i' : '') +\n      (node.dotAll ? 's' : '') +\n      (node.sticky ? 'y' : '')\n      // Regex+ doesn't allow explicitly adding flags it handles implicitly, so there are no\n      // `unicode` (flag u) or `unicodeSets` (flag v) props; those flags are added separately\n    );\n  },\n\n  /**\n  @param {GroupNode} node\n  */\n  Group({atomic, body, flags, parent}, state, gen) {\n    const currentFlags = state.currentFlags;\n    if (flags) {\n      state.currentFlags = getNewCurrentFlags(currentFlags, flags);\n    }\n    const contents = body.map(gen).join('|');\n    const result = (\n      !state.verbose &&\n      body.length === 1 && // Single alt\n      parent.type !== 'Quantifier' &&\n      !atomic &&\n      (!state.useFlagMods || !flags)\n     ) ? contents : `(?${getGroupPrefix(atomic, flags, state.useFlagMods)}${contents})`;\n    state.currentFlags = currentFlags;\n    return result;\n  },\n\n  /**\n  @param {LookaroundAssertionNode} node\n  */\n  LookaroundAssertion({body, kind, negate}, _, gen) {\n    const prefix = `${kind === 'lookahead' ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${body.map(gen).join('|')})`;\n  },\n\n  /**\n  @param {QuantifierNode} node\n  */\n  Quantifier(node, _, gen) {\n    return gen(node.body) + getQuantifierStr(node);\n  },\n\n  /**\n  @param {SubroutineNode & {isRecursive: true}} node\n  */\n  Subroutine({isRecursive, ref}, state) {\n    if (!isRecursive) {\n      throw new Error('Unexpected non-recursive subroutine in transformed AST');\n    }\n    const limit = state.recursionLimit;\n    // Using the syntax supported by `regex-recursion`\n    return ref === 0 ? `(?R=${limit})` : r`\\g<${ref}&R=${limit}>`;\n  },\n};\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', ']', '^', '{', '|', '}',\n]);\n\nconst CharClassEscapeChars = new Set([\n  '-', '\\\\', ']', '^',\n  // Literal `[` doesn't require escaping with flag u, but this can help work around regex source\n  // linters and regex syntax processors that expect unescaped `[` to create a nested class\n  '[',\n]);\n\nconst CharClassEscapeCharsFlagV = new Set([\n  '(', ')', '-', '/', '[', '\\\\', ']', '^', '{', '|', '}',\n  // Double punctuators; also includes already-listed `-` and `^`\n  '!', '#', '$', '%', '&', '*', '+', ',', '.', ':', ';', '<', '=', '>', '?', '@', '`', '~',\n]);\n\nconst CharCodeEscapeMap = new Map([\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nconst casedRe = /^\\p{Cased}$/u;\nfunction charHasCase(char) {\n  return casedRe.test(char);\n}\n\n/**\nGiven a `CharacterClassRange` node, returns an array of chars that are a case variant of a char in\nthe range, and aren't already in the range.\n*/\nfunction getCasesOutsideCharClassRange(node, options) {\n  const firstOnly = !!options?.firstOnly;\n  const min = node.min.value;\n  const max = node.max.value;\n  const found = [];\n  // Avoid unneeded work. Assumptions (per Unicode 16):\n  // - No case variants cross the Basic Multilingual Plane boundary\n  // - No cased chars appear beyond the Supplementary Multilingual Plane\n  if ((min < 65 && (max === 0xFFFF || max >= 0x1FFFF)) || (min === 0x10000 && max >= 0x1FFFF)) {\n    return found;\n  }\n  for (let i = min; i <= max; i++) {\n    const char = cp(i);\n    if (!charHasCase(char)) {\n      continue;\n    }\n    const charsOutsideRange = getIgnoreCaseMatchChars(char).filter(caseOfChar => {\n      const num = caseOfChar.codePointAt(0);\n      return num < min || num > max;\n    });\n    if (charsOutsideRange.length) {\n      found.push(...charsOutsideRange);\n      if (firstOnly) {\n        break;\n      }\n    }\n  }\n  return found;\n}\n\n// This shouldn't modifiy any char that has case\nfunction getCharEscape(codePoint, {escDigit, inCharClass, useFlagV}) {\n  if (CharCodeEscapeMap.has(codePoint)) {\n    return CharCodeEscapeMap.get(codePoint);\n  }\n  if (\n    // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n    codePoint < 32 || (codePoint > 126 && codePoint < 160) ||\n    // Unicode planes 4-16; unassigned, special purpose, and private use area\n    codePoint > 0x3FFFF ||\n    // Avoid corrupting a preceding backref by immediately following it with a literal digit\n    (escDigit && isDigitCharCode(codePoint))\n  ) {\n    // Don't convert codePoint `0` to `\\0` since that's corruptible by following literal digits\n    // Note: Not using raw strings to work around Bun \u2264 1.1.34 issue <github.com/oven-sh/bun/issues/7540>\n    return codePoint > 0xFF ?\n      `\\\\u{${codePoint.toString(16).toUpperCase()}}` :\n      `\\\\x${codePoint.toString(16).toUpperCase().padStart(2, '0')}`;\n  }\n  const escapeChars = inCharClass ?\n    (useFlagV ? CharClassEscapeCharsFlagV : CharClassEscapeChars) :\n    BaseEscapeChars;\n  const char = cp(codePoint);\n  return (escapeChars.has(char) ? '\\\\' : '') + char;\n}\n\nfunction getCodePointRangesFromChars(chars) {\n  const codePoints = chars.map(char => char.codePointAt(0)).sort((a, b) => a - b);\n  const values = [];\n  let start = null;\n  for (let i = 0; i < codePoints.length; i++) {\n    if (codePoints[i + 1] === codePoints[i] + 1) {\n      start ??= codePoints[i];\n    } else if (start === null) {\n      values.push(codePoints[i]);\n    } else {\n      values.push([start, codePoints[i]]);\n      start = null;\n    }\n  }\n  return values;\n}\n\nfunction getGroupPrefix(atomic, flagMods, useFlagMods) {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flagMods && useFlagMods) {\n    const {enable, disable} = flagMods;\n    mods =\n      (enable?.ignoreCase ? 'i' : '') +\n      (enable?.dotAll ? 's' : '') +\n      (disable ? '-' : '') +\n      (disable?.ignoreCase ? 'i' : '') +\n      (disable?.dotAll ? 's' : '');\n  }\n  return `${mods}:`;\n}\n\n/**\n@param {QuantifierNode} node\n@returns {string}\n*/\nfunction getQuantifierStr({kind, max, min}) {\n  let base;\n  if (!min && max === 1) {\n    base = '?';\n  } else if (!min && max === Infinity) {\n    base = '*';\n  } else if (min === 1 && max === Infinity) {\n    base = '+';\n  } else if (min === max) {\n    base = `{${min}}`;\n  } else {\n    base = `{${min},${max === Infinity ? '' : max}}`;\n  }\n  return base + {\n    greedy: '',\n    lazy: '?',\n    possessive: '+',\n  }[kind];\n}\n\n/**\n@param {Node} node\n@returns {boolean}\n*/\nfunction isAnyGroup({type}) {\n  return type === 'CapturingGroup' ||\n    type === 'Group' ||\n    type === 'LookaroundAssertion';\n}\n\nfunction isDigitCharCode(value) {\n  return value > 47 && value < 58;\n}\n\n/**\n@param {Node} node\n@returns {boolean}\n*/\nfunction isLiteralHyphen({type, value}) {\n  return type === 'Character' && value === 45;\n}\n\nexport {\n  generate,\n};\n", "import {getOrInsert} from './utils.js';\n\n/**\n@typedef {{\n  hiddenCaptures?: Array<number>;\n  lazyCompile?: boolean;\n  strategy?: string | null;\n  transfers?: Array<[number, Array<number>]>;\n}} EmulatedRegExpOptions\n*/\n\n/**\nWorks the same as JavaScript's native `RegExp` constructor in all contexts, but can be given\nresults from `toRegExpDetails` to produce the same result as `toRegExp`.\n*/\nclass EmulatedRegExp extends RegExp {\n  /**\n  @type {Map<number, {\n    hidden?: true;\n    transferTo?: number;\n  }>}\n  */\n  #captureMap = new Map();\n\n  /**\n  @type {RegExp | EmulatedRegExp | null}\n  */\n  #compiled = null;\n\n  /**\n  @type {string}\n  */\n  #pattern;\n\n  /**\n  @type {Map<number, string>?}\n  */\n  #nameMap = null;\n\n  /**\n  @type {string?}\n  */\n  #strategy = null;\n\n  /**\n  Can be used to serialize the instance.\n  @type {EmulatedRegExpOptions}\n  */\n  rawOptions = {};\n\n  // Override the getter with one that works with lazy-compiled regexes\n  get source() {\n    return this.#pattern || '(?:)';\n  }\n\n  /**\n  @overload\n  @param {string} pattern\n  @param {string} [flags]\n  @param {EmulatedRegExpOptions} [options]\n  */\n  /**\n  @overload\n  @param {EmulatedRegExp} pattern\n  @param {string} [flags]\n  */\n  constructor(pattern, flags, options) {\n    const lazyCompile = !!options?.lazyCompile;\n    if (pattern instanceof RegExp) {\n      // Argument `options` isn't provided when regexes are copied, including as part of the\n      // internal handling of string methods `matchAll` and `split`\n      if (options) {\n        throw new Error('Cannot provide options when copying a regexp');\n      }\n      const re = pattern; // Alias for readability\n      super(re, flags);\n      this.#pattern = re.source;\n      if (re instanceof EmulatedRegExp) {\n        this.#captureMap = re.#captureMap;\n        this.#nameMap = re.#nameMap;\n        this.#strategy = re.#strategy;\n        this.rawOptions = re.rawOptions;\n      }\n    } else {\n      const opts = {\n        hiddenCaptures: [],\n        strategy: null,\n        transfers: [],\n        ...options,\n      };\n      super(lazyCompile ? '' : pattern, flags);\n      this.#pattern = pattern;\n      this.#captureMap = createCaptureMap(opts.hiddenCaptures, opts.transfers);\n      this.#strategy = opts.strategy;\n      // Don't add default values from `opts` since this gets serialized\n      this.rawOptions = options ?? {};\n    }\n    if (!lazyCompile) {\n      this.#compiled = this;\n    }\n  }\n\n  /**\n  Called internally by all String/RegExp methods that use regexes.\n  @override\n  @param {string} str\n  @returns {RegExpExecArray?}\n  */\n  exec(str) {\n    // Lazy compilation\n    if (!this.#compiled) {\n      const {lazyCompile, ...rest} = this.rawOptions;\n      this.#compiled = new EmulatedRegExp(this.#pattern, this.flags, rest);\n    }\n\n    const useLastIndex = this.global || this.sticky;\n    const pos = this.lastIndex;\n\n    if (this.#strategy === 'clip_search' && useLastIndex && pos) {\n      // Reset since this tests on a sliced string that we want to match at the start of\n      this.lastIndex = 0;\n      // Slicing the string can lead to mismatches when three edge cases are stacked on each other:\n      // 1. An uncommon use of `\\G` that relies on `clip_search`, combined with...\n      // 2. Lookbehind that searches behind the search start (not match start) position...\n      // 3. During a search when the regex's `lastIndex` isn't `0`.\n      // The `clip_search` strategy is therefore only allowed when lookbehind isn't present, if\n      // using strict `accuracy`\n      const match = this.#execCore(str.slice(pos));\n      if (match) {\n        adjustMatchDetailsForOffset(match, pos, str, this.hasIndices);\n        this.lastIndex += pos;\n      }\n      return match;\n    }\n\n    return this.#execCore(str);\n  }\n\n  /**\n  Adds support for hidden and transfer captures.\n  @param {string} str\n  @returns\n  */\n  #execCore(str) {\n    // Support lazy compilation\n    this.#compiled.lastIndex = this.lastIndex;\n    const match = super.exec.call(this.#compiled, str);\n    this.lastIndex = this.#compiled.lastIndex;\n\n    if (!match || !this.#captureMap.size) {\n      return match;\n    }\n\n    const matchCopy = [...match];\n    // Empty all but the first value of the array while preserving its other properties\n    match.length = 1;\n    let indicesCopy;\n    if (this.hasIndices) {\n      indicesCopy = [...match.indices];\n      match.indices.length = 1;\n    }\n    const mappedNums = [0];\n    for (let i = 1; i < matchCopy.length; i++) {\n      const {hidden, transferTo} = this.#captureMap.get(i) ?? {};\n      if (hidden) {\n        mappedNums.push(null);\n      } else {\n        mappedNums.push(match.length);\n        match.push(matchCopy[i]);\n        if (this.hasIndices) {\n          match.indices.push(indicesCopy[i]);\n        }\n      }\n\n      // Only transfer if the capture participated in the match\n      if (transferTo && matchCopy[i] !== undefined) {\n        const to = mappedNums[transferTo];\n        if (!to) {\n          throw new Error(`Invalid capture transfer to \"${to}\"`);\n        }\n        match[to] = matchCopy[i];\n        if (this.hasIndices) {\n          match.indices[to] = indicesCopy[i];\n        }\n        if (match.groups) {\n          if (!this.#nameMap) {\n            // Generate and cache the first time it's needed\n            this.#nameMap = createNameMap(this.source);\n          }\n          const name = this.#nameMap.get(transferTo);\n          if (name) {\n            match.groups[name] = matchCopy[i];\n            if (this.hasIndices) {\n              match.indices.groups[name] = indicesCopy[i];\n            }\n          }\n        }\n      }\n    }\n\n    return match;\n  }\n}\n\nfunction adjustMatchDetailsForOffset(match, offset, input, hasIndices) {\n  match.index += offset;\n  match.input = input;\n  if (hasIndices) {\n    const indices = match.indices;\n    for (let i = 0; i < indices.length; i++) {\n      const arr = indices[i];\n      if (arr) {\n        // Replace the array rather than updating values since the keys of `match.indices` and\n        // `match.indices.groups` share their value arrays by reference. Need to be precise in case\n        // they were previously altered separately\n        indices[i] = [arr[0] + offset, arr[1] + offset];\n      }\n    }\n    const groupIndices = indices.groups;\n    if (groupIndices) {\n      Object.keys(groupIndices).forEach(key => {\n        const arr = groupIndices[key];\n        if (arr) {\n          groupIndices[key] = [arr[0] + offset, arr[1] + offset];\n        }\n      });\n    }\n  }\n}\n\n/**\nBuild the capturing group map, with hidden/transfer groups marked to indicate their submatches\nshould get special handling in match results.\n@param {Array<number>} hiddenCaptures\n@param {Array<[number, Array<number>]>} transfers\n@returns {Map<number, {\n  hidden?: true;\n  transferTo?: number;\n}>}\n*/\nfunction createCaptureMap(hiddenCaptures, transfers) {\n  const captureMap = new Map();\n  for (const num of hiddenCaptures) {\n    captureMap.set(num, {\n      hidden: true,\n    });\n  }\n  for (const [to, from] of transfers) {\n    for (const num of from) {\n      getOrInsert(captureMap, num, {}).transferTo = to;\n    }\n  }\n  return captureMap;\n}\n\n/**\n@param {string} pattern\n@returns {Map<number, string>}\n*/\nfunction createNameMap(pattern) {\n  const re = /(?<capture>\\((?:\\?<(?![=!])(?<name>[^>]+)>|(?!\\?)))|\\\\?./gsu;\n  const map = new Map();\n  let numCharClassesOpen = 0;\n  let numCaptures = 0;\n  let match;\n  while ((match = re.exec(pattern))) {\n    const {0: m, groups: {capture, name}} = match;\n    // Relies on no unescaped literal `[` in char classes (valid in JS if not using flag v), but\n    // this library's generator never produces unescaped literal `[` even with `target` ES2018 (see\n    // `CharClassEscapeChars`)\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (capture) {\n        numCaptures++;\n        if (name) {\n          map.set(numCaptures, name);\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return map;\n}\n\nexport {\n  EmulatedRegExp,\n};\n", "import {transform} from './transform.js';\nimport {generate} from './generate.js';\nimport {Accuracy, getOptions, Target} from './options.js';\nimport {EmulatedRegExp} from './subclass.js';\nimport {JsUnicodePropertyMap} from './unicode.js';\nimport {parse} from 'oniguruma-parser/parser';\nimport {atomic, possessive} from 'regex/internals';\nimport {recursion} from 'regex-recursion';\n/**\n@import {EmulatedRegExpOptions} from './subclass.js';\n*/\n\n// The validation and transformation for Oniguruma's unique syntax and behavior differences\n// compared to native JS RegExp is layered into all steps of the compilation process:\n// 1. Parser: Uses `oniguruma-parser` to build an Oniguruma AST, which accounts for many\n//    differences between Oniguruma and JS.\n// 2. Transformer: Converts the Oniguruma AST to a Regex+ AST that preserves all Oniguruma\n//    behavior. This is true even in cases of non-native-JS features that are supported by both\n//    Regex+ and Oniguruma but with subtly different behavior in each (subroutines, flag x).\n// 3. Generator: Converts the Regex+ AST to a Regex+ pattern, flags, and options.\n// 4. Postprocessing: Regex+ internals and plugins are used to transpile several remaining features\n//    (atomic groups, possessive quantifiers, recursion). Regex+ uses a strict superset of JS\n//    RegExp syntax, so using it allows this library to benefit from not reinventing the wheel for\n//    complex features that Regex+ already knows how to transpile to JS.\n\n/**\n@typedef {{\n  accuracy?: keyof Accuracy;\n  avoidSubclass?: boolean;\n  flags?: string;\n  global?: boolean;\n  hasIndices?: boolean;\n  lazyCompileLength?: number;\n  rules?: {\n    allowOrphanBackrefs?: boolean;\n    asciiWordBoundaries?: boolean;\n    captureGroup?: boolean;\n    recursionLimit?: number;\n    singleline?: boolean;\n  };\n  target?: keyof Target;\n  verbose?: boolean;\n}} ToRegExpOptions\n*/\n\n/**\nAccepts an Oniguruma pattern and returns an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {ToRegExpOptions} [options]\n@returns {RegExp | EmulatedRegExp}\n*/\nfunction toRegExp(pattern, options) {\n  const d = toRegExpDetails(pattern, options);\n  if (d.options) {\n    return new EmulatedRegExp(d.pattern, d.flags, d.options);\n  }\n  return new RegExp(d.pattern, d.flags);\n}\n\n/**\nAccepts an Oniguruma pattern and returns the details for an equivalent JavaScript `RegExp`.\n@param {string} pattern Oniguruma regex pattern.\n@param {ToRegExpOptions} [options]\n@returns {{\n  pattern: string;\n  flags: string;\n  options?: EmulatedRegExpOptions;\n}}\n*/\nfunction toRegExpDetails(pattern, options) {\n  const opts = getOptions(options);\n  const onigurumaAst = parse(pattern, {\n    flags: opts.flags,\n    normalizeUnknownPropertyNames: true,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    unicodePropertyMap: JsUnicodePropertyMap,\n  });\n  const regexPlusAst = transform(onigurumaAst, {\n    accuracy: opts.accuracy,\n    asciiWordBoundaries: opts.rules.asciiWordBoundaries,\n    avoidSubclass: opts.avoidSubclass,\n    bestEffortTarget: opts.target,\n  });\n  const generated = generate(regexPlusAst, opts);\n  const recursionResult = recursion(generated.pattern, {\n    captureTransfers: generated._captureTransfers,\n    hiddenCaptures: generated._hiddenCaptures,\n    mode: 'external',\n  });\n  const possessiveResult = possessive(recursionResult.pattern);\n  const atomicResult = atomic(possessiveResult.pattern, {\n    captureTransfers: recursionResult.captureTransfers,\n    hiddenCaptures: recursionResult.hiddenCaptures,\n  });\n  const details = {\n    pattern: atomicResult.pattern,\n    flags: `${opts.hasIndices ? 'd' : ''}${opts.global ? 'g' : ''}${generated.flags}${generated.options.disable.v ? 'u' : 'v'}`,\n  };\n  if (opts.avoidSubclass) {\n    if (opts.lazyCompileLength !== Infinity) {\n      throw new Error('Lazy compilation requires subclass');\n    }\n  } else {\n    // Sort isn't required; only for readability when serialized\n    const hiddenCaptures = atomicResult.hiddenCaptures.sort((a, b) => a - b);\n    // Change the map to the `EmulatedRegExp` format, serializable as JSON\n    const transfers = Array.from(atomicResult.captureTransfers);\n    const strategy = regexPlusAst._strategy;\n    const lazyCompile = details.pattern.length >= opts.lazyCompileLength;\n    if (hiddenCaptures.length || transfers.length || strategy || lazyCompile) {\n      details.options = {\n        ...(hiddenCaptures.length && {hiddenCaptures}),\n        ...(transfers.length && {transfers}),\n        ...(strategy && {strategy}),\n        ...(lazyCompile && {lazyCompile}),\n      };\n    }\n  }\n  return details;\n}\n\n// function toOnigurumaAst(pattern, options) {\n//   return parse(pattern, {\n//     flags: options?.flags ?? '',\n//     normalizeUnknownPropertyNames: true,\n//     rules: options?.rules ?? {},\n//     unicodePropertyMap: JsUnicodePropertyMap,\n//   });\n// }\n\n// function toRegexPlusAst(pattern, options) {\n//   return transform(toOnigurumaAst(pattern, options));\n// }\n\nexport {\n  EmulatedRegExp,\n  toRegExp,\n  toRegExpDetails,\n  // toOnigurumaAst,\n  // toRegexPlusAst,\n};\n"],
  "mappings": "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",
  "names": ["range", "slug", "node", "recursion", "createAlternative", "createCharacter", "createGroup", "traverse", "atomic", "parse"]
}
