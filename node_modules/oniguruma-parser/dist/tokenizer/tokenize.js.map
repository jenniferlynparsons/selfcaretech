{
  "version": 3,
  "sources": ["../../src/tokenizer/tokenize.ts"],
  "sourcesContent": ["import {cpOf, PosixClassNames, r, throwIfNullish} from '../utils.js';\n\ntype Token =\n  AlternatorToken |\n  AssertionToken |\n  BackreferenceToken |\n  CharacterToken |\n  CharacterClassCloseToken |\n  CharacterClassHyphenToken |\n  CharacterClassIntersectorToken |\n  CharacterClassOpenToken |\n  CharacterSetToken |\n  DirectiveToken |\n  GroupCloseToken |\n  GroupOpenToken |\n  NamedCalloutToken |\n  QuantifierToken |\n  SubroutineToken;\n\ntype IntermediateToken =\n  EscapedNumberToken;\n\ntype TokenCharacterSetKind =\n  'any' |\n  'digit' |\n  'dot' |\n  'hex' |\n  'newline' |\n  'posix' |\n  'property' |\n  'space' |\n  'text_segment' |\n  'word';\n\ntype TokenDirectiveKind =\n  'flags' |\n  'keep';\n\ntype TokenGroupOpenKind =\n  'absence_repeater' |\n  'atomic' |\n  'capturing' |\n  'group' |\n  'lookahead' |\n  'lookbehind';\n\ntype TokenQuantifierKind =\n  'greedy' |\n  'lazy' |\n  'possessive';\n\ntype TokenNamedCalloutKind =\n  'count' |\n  'cmp' |\n  'error' |\n  'fail' |\n  'max' |\n  'mismatch' |\n  'skip' |\n  'total_count' |\n  'custom';\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*[^\\)]*\\)?\n  )?\n  | (?:${quantifierRe.source})+\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\ntype Context = {\n  captureGroup: boolean;\n  getCurrentModX(): boolean;\n  numOpenGroups: number;\n  popModX(): void;\n  pushModX(isXOn: boolean): void;\n  replaceCurrentModX(isXOn: boolean): void;\n  singleline: boolean;\n};\n\ntype TokenizeOptions = {\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n};\n\nfunction tokenize(pattern: string, options: TokenizeOptions = {}): {\n  tokens: Array<Token>;\n  flags: FlagProperties;\n} {\n  const opts = {\n    flags: '',\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  const flagProperties = getFlagProperties(opts.flags);\n  const xStack = [flagProperties.extended];\n  const context: Context = {\n    captureGroup: opts.rules.captureGroup,\n    // Always at least has the top-level flag x\n    getCurrentModX() {return xStack.at(-1)!},\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: opts.rules.singleline,\n  };\n  let tokens: Array<Token | IntermediateToken> = [];\n  let match: RegExpExecArray | null;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens: Array<GroupOpenToken> = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.filter(t => t.type === 'GroupOpen').forEach(t => {\n    if (t.kind === 'capturing') {\n      t.number = ++numNamedAndOptInUnnamedCaptures;\n    } else if (t.raw === '(') {\n      potentialUnnamedCaptureTokens.push(t);\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = 'capturing';\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  const tokensWithoutIntermediate = tokens.map(\n    t => t.type === 'EscapedNumber' ? splitEscapedNumberToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens: tokensWithoutIntermediate,\n    flags: flagProperties,\n  };\n}\n\nfunction getTokenWithDetails(context: Context, pattern: string, m: string, lastIndex: number): {\n  token: Token | IntermediateToken;\n  tokens?: never;\n  lastIndex?: number;\n} | {\n  token?: never;\n  tokens: Array<Token | IntermediateToken>;\n  lastIndex?: number;\n} | {\n  token?: never;\n  tokens?: never;\n  lastIndex: number;\n} {\n  const [m0, m1] = m;\n\n  if (m === '[' || m === '[^') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n\n  if (m0 === '\\\\') {\n    if ('AbBGyYzZ'.includes(m1)) {\n      return {\n        token: createAssertionToken(m, m),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createSubroutineToken(m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createBackreferenceToken(m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createDirectiveToken('keep', m),\n      };\n    }\n    if (m1 === 'N' || m1 === 'R') {\n      return {\n        token: createCharacterSetToken('newline', m, {\n          // `\\N` and `\\R` are not actually opposites since the former only excludes `\\n`\n          negate: m1 === 'N',\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createCharacterSetToken('any', m),\n      };\n    }\n    if (m1 === 'X') {\n      return {\n        token: createCharacterSetToken('text_segment', m),\n      };\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = tokenizeSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n\n  if (m0 === '(') {\n    if (m1 === '*') {\n      return {\n        token: tokenizeNamedCallout(m),\n      };\n    }\n    if (m === '(?{') {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    // Comment group\n    if (m.startsWith('(?#')) {\n      // Everything except the closing unescaped `)` is included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        // Jump forward to after the closing paren\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener)\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: tokenizeFlagModifier(m, context),\n      };\n    }\n    // --- Remaining group types all reuse current flag x status ---\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        // For `(`, will later change to `capturing` and add `number` prop if no named captures\n        token: createGroupOpenToken('group', m),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createGroupOpenToken('atomic', m),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createGroupOpenToken(m[2] === '<' ? 'lookbehind' : 'lookahead', m, {\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Unnamed capture when `captureGroup` enabled, or named capture (checked after lookbehind due\n    // to similar syntax)\n    if (\n      (m === '(' && context.captureGroup) ||\n      (m.startsWith('(?<') && m.endsWith('>')) ||\n      (m.startsWith(\"(?'\") && m.endsWith(\"'\"))\n    ) {\n      return {\n        token: createGroupOpenToken('capturing', m, {\n          // Will add `number` prop in a second pass\n          ...(m !== '(' && {name: m.slice(3, -1)}),\n        }),\n      };\n    }\n    if (m.startsWith('(?~')) {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absence function kind \"${m}\"`);\n      }\n      return {\n        token: createGroupOpenToken('absence_repeater', m),\n      };\n    }\n    if (m === '(?(') {\n      // TODO: Add support\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createGroupCloseToken(m),\n    };\n  }\n\n  if (context.getCurrentModX()) {\n    if (m === '#') {\n      // Onig's only line break char is line feed\n      const end = pattern.indexOf('\\n', lastIndex);\n      return {\n        // Jump forward to the end of the comment\n        lastIndex: end === -1 ? pattern.length : end,\n      };\n    }\n    if (/^\\s$/.test(m)) {\n      const re = /\\s+/y;\n      re.lastIndex = lastIndex;\n      const rest = re.exec(pattern);\n      return {\n        // Jump forward to the end of the whitespace\n        lastIndex: rest ? re.lastIndex : lastIndex,\n      };\n    }\n  }\n\n  if (m === '.') {\n    return {\n      token: createCharacterSetToken('dot', m),\n    };\n  }\n\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createAssertionToken(kind, m),\n    };\n  }\n\n  if (m === '|') {\n    return {\n      token: createAlternatorToken(m),\n    };\n  }\n\n  if (quantifierRe.test(m)) {\n    return {\n      tokens: splitQuantifierMatch(m),\n    };\n  }\n\n  // `cpOf` asserts that it's a single code point\n  return {\n    token: createCharacterToken(cpOf(m), m),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern: string, opener: CharacterClassOpener, lastIndex: number): {\n  tokens: Array<Token | IntermediateToken>;\n  lastIndex: number;\n} {\n  const tokens: Array<Token | IntermediateToken> = [createCharacterClassOpenToken(opener[1] === '^', opener)];\n  let numCharClassesOpen = 1;\n  let match: RegExpExecArray | null;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createCharacterClassOpenToken(m[1] === '^', m as CharacterClassOpener));\n    } else if (m === ']') {\n      // Always at least includes the char class opener\n      if (tokens.at(-1)!.type === 'CharacterClassOpen') {\n        // Allow unescaped `]` as leading char\n        tokens.push(createCharacterToken(93, m));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createCharacterClassCloseToken(m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = tokenizeAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  };\n}\n\nfunction tokenizeAnyTokenWithinCharClass(raw: string): Token | IntermediateToken | Array<Token> {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return tokenizeSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassNames.has(posix.groups!.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createCharacterSetToken('posix', raw, {\n      value: posix.groups!.name,\n      negate: !!posix.groups!.negate,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createCharacterClassHyphenToken(raw);\n  }\n  if (raw === '&&') {\n    return createCharacterClassIntersectorToken(raw);\n  }\n  // `cpOf` asserts that it's a single code point\n  return createCharacterToken(cpOf(raw), raw);\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction tokenizeSharedEscape(raw: string, {inCharClass}: {inCharClass: boolean}): Token | IntermediateToken | Array<Token> {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return tokenizeControlCharacter(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return tokenizeShorthand(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return tokenizeUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createCharacterToken(cpOf(char), raw);\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createCharacterToken(getValidatedHexCharCode(raw), raw);\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createCharacterToken(EscapeCharCodes.get(char1)!, raw);\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createEscapedNumberToken(inCharClass, raw);\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // TODO: Add support. See:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    // - <github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createCharacterToken(raw.codePointAt(1)!, raw);\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n// --------------------------------\n// --- Token creation and types ---\n// --------------------------------\n\ntype AlternatorToken = {\n  type: 'Alternator';\n  raw: '|';\n};\nfunction createAlternatorToken(raw: '|'): AlternatorToken {\n  return {\n    type: 'Alternator',\n    raw,\n  };\n}\n\ntype AssertionToken = {\n  type: 'Assertion';\n  kind: string;\n  raw: string;\n};\nfunction createAssertionToken(kind: string, raw: string): AssertionToken {\n  return {\n    type: 'Assertion',\n    kind,\n    raw,\n  };\n}\n\ntype BackreferenceToken = {\n  type: 'Backreference';\n  raw: string;\n};\nfunction createBackreferenceToken(raw: string): BackreferenceToken {\n  return {\n    type: 'Backreference',\n    raw,\n  };\n}\n\ntype CharacterToken = {\n  type: 'Character';\n  value: number;\n  raw: string;\n};\nfunction createCharacterToken(value: number, raw: string): CharacterToken {\n  return {\n    type: 'Character',\n    value,\n    raw,\n  };\n}\n\ntype CharacterClassCloseToken = {\n  type: 'CharacterClassClose';\n  raw: ']';\n};\nfunction createCharacterClassCloseToken(raw: ']'): CharacterClassCloseToken {\n  return {\n    type: 'CharacterClassClose',\n    raw,\n  };\n}\n\ntype CharacterClassHyphenToken = {\n  type: 'CharacterClassHyphen';\n  raw: '-';\n};\nfunction createCharacterClassHyphenToken(raw: '-'): CharacterClassHyphenToken {\n  return {\n    type: 'CharacterClassHyphen',\n    raw,\n  };\n}\n\ntype CharacterClassIntersectorToken = {\n  type: 'CharacterClassIntersector';\n  raw: '&&';\n};\nfunction createCharacterClassIntersectorToken(raw: '&&'): CharacterClassIntersectorToken {\n  return {\n    type: 'CharacterClassIntersector',\n    raw,\n  };\n}\n\ntype CharacterClassOpenToken = {\n  type: 'CharacterClassOpen';\n  negate: boolean;\n  raw: CharacterClassOpener;\n};\ntype CharacterClassOpener = '[' | '[^';\nfunction createCharacterClassOpenToken(negate: boolean, raw: CharacterClassOpener): CharacterClassOpenToken {\n  return {\n    type: 'CharacterClassOpen',\n    negate,\n    raw,\n  };\n}\n\ntype CharacterSetToken = {\n  type: 'CharacterSet';\n  kind: TokenCharacterSetKind;\n  value?: string;\n  negate?: boolean;\n  raw: string;\n};\nfunction createCharacterSetToken(\n  kind: TokenCharacterSetKind,\n  raw: string,\n  options: {\n    value?: string;\n    negate?: boolean;\n  } = {}\n): CharacterSetToken {\n  return {\n    type: 'CharacterSet',\n    kind,\n    ...options,\n    raw,\n  };\n}\n\ntype DirectiveToken = {\n  type: 'Directive';\n  raw: string;\n} & ({\n  kind: 'keep';\n  flags?: never;\n} | {\n  kind: 'flags';\n  flags: FlagGroupModifiers;\n});\nfunction createDirectiveToken(kind: TokenDirectiveKind, raw: string, options: {flags?: FlagGroupModifiers} = {}): DirectiveToken {\n  if (kind === 'keep') {\n    return {\n      type: 'Directive',\n      kind,\n      raw,\n    };\n  }\n  return {\n    type: 'Directive',\n    kind,\n    flags: throwIfNullish(options.flags),\n    raw,\n  };\n}\n\ntype EscapedNumberToken = {\n  type: 'EscapedNumber';\n  inCharClass: boolean;\n  raw: string;\n};\n/**\nIntermediate representation only; will become a `Backreference` or one or more `Character`s.\n*/\nfunction createEscapedNumberToken(inCharClass: boolean, raw: string): EscapedNumberToken {\n  return {\n    type: 'EscapedNumber',\n    inCharClass,\n    raw,\n  };\n}\n\ntype GroupCloseToken = {\n  type: 'GroupClose';\n  raw: ')';\n};\nfunction createGroupCloseToken(raw: ')'): GroupCloseToken {\n  return {\n    type: 'GroupClose',\n    raw,\n  };\n}\n\ntype GroupOpenToken = {\n  type: 'GroupOpen';\n  kind: TokenGroupOpenKind;\n  flags?: FlagGroupModifiers;\n  name?: string;\n  number?: number;\n  negate?: boolean;\n  raw: string;\n};\nfunction createGroupOpenToken(\n  kind: TokenGroupOpenKind,\n  raw: string,\n  options: {\n    flags?: FlagGroupModifiers;\n    name?: string;\n    number?: number;\n    negate?: boolean;\n  } = {}\n): GroupOpenToken {\n  return {\n    type: 'GroupOpen',\n    kind,\n    ...options,\n    raw,\n  };\n}\n\ntype NamedCalloutToken = {\n  type: 'NamedCallout';\n  kind: TokenNamedCalloutKind;\n  tag: string | null;\n  arguments: Array<string | number> | null;\n  raw: string;\n};\nfunction createNamedCalloutToken(\n  kind: TokenNamedCalloutKind,\n  tag: string | null,\n  args: Array<string | number> | null,\n  raw: string\n): NamedCalloutToken {\n  return {\n    type: 'NamedCallout',\n    kind,\n    tag,\n    arguments: args,\n    raw,\n  };\n};\n\ntype QuantifierToken = {\n  type: 'Quantifier';\n  kind: TokenQuantifierKind;\n  min: number;\n  max: number;\n  raw: string;\n};\nfunction createQuantifierToken(\n  kind: TokenQuantifierKind,\n  min: number,\n  max: number,\n  raw: string\n): QuantifierToken {\n  return {\n    type: 'Quantifier',\n    kind,\n    min,\n    max,\n    raw,\n  };\n}\n\ntype SubroutineToken = {\n  type: 'Subroutine';\n  raw: string;\n};\nfunction createSubroutineToken(raw: string): SubroutineToken {\n  return {\n    type: 'Subroutine',\n    raw,\n  };\n}\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\ntype FlagProperties = {\n  ignoreCase: boolean;\n  dotAll: boolean;\n  extended: boolean;\n  digitIsAscii: boolean;\n  posixIsAscii: boolean;\n  spaceIsAscii: boolean;\n  wordIsAscii: boolean;\n  textSegmentMode: 'grapheme' | 'word' | null;\n};\n\ntype FlagGroupModifiers = {\n  enable?: FlagGroupSwitches;\n  disable?: FlagGroupSwitches;\n};\n\ntype FlagGroupSwitches = {\n  ignoreCase?: true;\n  dotAll?: true;\n  extended?: true;\n};\n\nconst CalloutNames = new Set<Uppercase<Exclude<TokenNamedCalloutKind, 'custom'>>>([\n  'COUNT',\n  'CMP',\n  'ERROR',\n  'FAIL',\n  'MAX',\n  'MISMATCH',\n  'SKIP',\n  'TOTAL_COUNT',\n]);\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\n// Expects `\\cx` or `\\C-x`\nfunction tokenizeControlCharacter(raw: string): CharacterToken {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // TODO: Add support. See:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createCharacterToken(cpOf(char.toUpperCase()) - 64, raw);\n}\n\nfunction tokenizeFlagModifier(raw: string, context: Context): DirectiveToken | GroupOpenToken {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw)!.groups as {on: string, off: string | undefined};\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagGroupSwitches(on);\n  const disabledFlags = getFlagGroupSwitches(off);\n  const flagChanges: FlagGroupModifiers = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createDirectiveToken('flags', raw, {\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    return createGroupOpenToken('group', raw, {\n      ...((enabledFlags || disabledFlags) && {flags: flagChanges}),\n    });\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction tokenizeNamedCallout(raw: string): NamedCalloutToken {\n  const callout = /\\(\\*(?<name>[A-Za-z_]\\w*)?(?:\\[(?<tag>(?:[A-Za-z_]\\w*)?)\\])?(?:\\{(?<args>[^}]*)\\})?\\)/.exec(raw);\n  if (!callout) {\n    throw new Error(`Incomplete or invalid named callout \"${raw}\"`);\n  }\n  const {name, tag, args} = callout.groups as Partial<{\n    name: string;\n    tag: string;\n    args: string;\n  }>;\n  if (!name) {\n    throw new Error(`Invalid named callout \"${raw}\"`);\n  }\n  if (tag === '') {\n    throw new Error(`Named callout tag with empty value not allowed \"${raw}\"`);\n  }\n  const argsArray: Array<string | number> = args ?\n    args.split(',').\n      // Onig skips over/ignores redundant/unnecessary commas\n      filter(arg => arg !== '').\n      map(arg => /^[+-]?\\d+$/.test(arg) ? +arg : arg) :\n    [];\n  const [arg0, arg1, arg2] = argsArray;\n  const kind: TokenNamedCalloutKind = CalloutNames.has(name as Uppercase<Exclude<TokenNamedCalloutKind, 'custom'>>) ?\n    name.toLowerCase() as TokenNamedCalloutKind :\n    'custom';\n  switch (kind) {\n    case 'fail':\n    case 'mismatch':\n    case 'skip':\n      if (argsArray.length > 0) {\n        throw new Error(`Named callout arguments not allowed \"${argsArray}\"`);\n      }\n      break;\n    case 'error':\n      if (argsArray.length > 1) {\n        throw new Error(`Named callout allows only one argument \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string') {\n        throw new Error(`Named callout argument must be a number \"${arg0}\"`);\n      }\n      break;\n    case 'max':\n      if (!argsArray.length || argsArray.length > 2) {\n        throw new Error(`Named callout must have one or two arguments \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg0)) {\n        throw new Error(`Named callout argument one must be a tag or number \"${arg0}\"`);\n      }\n      if (argsArray.length === 2 && (typeof arg1 === 'number' || !/^[<>X]$/.test(arg1))) {\n        throw new Error(`Named callout optional argument two must be '<', '>', or 'X' \"${arg1}\"`);\n      }\n      break;\n    case 'count':\n    case 'total_count':\n      if (argsArray.length > 1) {\n        throw new Error(`Named callout allows only one argument \"${argsArray}\"`);\n      }\n      if (argsArray.length === 1 && (typeof arg0 === 'number' || !/^[<>X]$/.test(arg0))) {\n        throw new Error(`Named callout optional argument must be '<', '>', or 'X' \"${arg0}\"`);\n      }\n      break;\n    case 'cmp':\n      if (argsArray.length !== 3) {\n        throw new Error(`Named callout must have three arguments \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg0)) {\n        throw new Error(`Named callout argument one must be a tag or number \"${arg0}\"`);\n      }\n      if (typeof arg1 === 'number' || !/^(?:[<>!=]=|[<>])$/.test(arg1)) {\n        throw new Error(`Named callout argument two must be '==', '!=', '>', '<', '>=', or '<=' \"${arg1}\"`);\n      }\n      if (typeof arg2 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg2)) {\n        throw new Error(`Named callout argument three must be a tag or number \"${arg2}\"`);\n      }\n      break;\n    case 'custom':\n      // TODO: Can support custom callout names via a new option that allows providing a list of\n      // allowed, non-built-in names\n      throw new Error(`Undefined callout name \"${name}\"`);\n    default:\n      throw new Error(`Unexpected named callout kind \"${kind}\"`);\n  }\n  // TODO: If supporting custom callout names in the future (with an added `name` property for\n  // `NamedCalloutToken`), will need to set `name` to `null` if `kind` isn't `'custom'`\n  return createNamedCalloutToken(kind, tag ?? null, args?.split(',') ?? null, raw);\n}\n\nfunction tokenizeQuantifier(raw: string): QuantifierToken {\n  let kind: TokenQuantifierKind = null!;\n  let min: number;\n  let max: number;\n  if (raw[0] === '{') {\n    const {minStr, maxStr} =\n      /^\\{(?<minStr>\\d*)(?:,(?<maxStr>\\d*))?/.exec(raw)!.groups as {minStr: string, maxStr: string | undefined};\n    const limit = 100_000;\n    if (+minStr > limit || (maxStr && +maxStr > limit)) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    min = +minStr;\n    max = maxStr === undefined ? +minStr : (maxStr === '' ? Infinity : +maxStr);\n    // By default, Onig doesn't support making interval quantifiers possessive with a `+` suffix;\n    // uses reversed range instead\n    if (min > max) {\n      kind = 'possessive';\n      [min, max] = [max, min];\n    }\n    if (raw.endsWith('?')) {\n      if (kind === 'possessive') {\n        // TODO: <github.com/slevithan/oniguruma-parser/issues/10>\n        throw new Error('Unsupported possessive interval quantifier chain with \"?\"');\n      }\n      kind = 'lazy';\n    } else if (!kind) {\n      kind = 'greedy';\n    }\n  } else {\n    min = raw[0] === '+' ? 1 : 0;\n    max = raw[0] === '?' ? 1 : Infinity;\n    kind = raw[1] === '+' ? 'possessive' : (raw[1] === '?' ? 'lazy' : 'greedy');\n  }\n  return createQuantifierToken(kind, min, max, raw);\n}\n\nfunction tokenizeShorthand(raw: string): CharacterSetToken {\n  const lower = raw[1].toLowerCase();\n  return createCharacterSetToken({\n    'd': 'digit',\n    'h': 'hex',\n    's': 'space',\n    'w': 'word',\n  }[lower] as TokenCharacterSetKind, raw, {\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction tokenizeUnicodeProperty(raw: string): CharacterSetToken {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw)!.groups!;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createCharacterSetToken('property', raw, {\n    value,\n    negate,\n  });\n}\n\nfunction getFlagGroupSwitches(flags: string): FlagGroupSwitches | null {\n  // Don't include `false` for flags that aren't included\n  const obj: FlagGroupSwitches = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\nfunction getFlagProperties(flags: string): FlagProperties {\n  const flagProperties: FlagProperties = {\n    ignoreCase: false,\n    dotAll: false,\n    extended: false,\n    digitIsAscii: false,\n    posixIsAscii: false,\n    spaceIsAscii: false,\n    wordIsAscii: false,\n    textSegmentMode: null,\n  };\n  for (let i = 0; i < flags.length; i++) {\n    const char = flags[i];\n    if (!'imxDPSWy'.includes(char)) {\n      throw new Error(`Invalid flag \"${char}\"`);\n    }\n    // Flags y{g}, y{w} are currently only supported via the top-level `flags` option\n    if (char === 'y') {\n      if (!/^y{[gw]}/.test(flags.slice(i))) {\n        throw new Error('Invalid or unspecified flag \"y\" mode');\n      }\n      // If text segment mode flags appear multiple times, use the last one\n      flagProperties.textSegmentMode = flags[i + 2] === 'g' ? 'grapheme' : 'word';\n      i += 3;\n      continue;\n    }\n    flagProperties[{\n      i: 'ignoreCase',\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      m: 'dotAll',\n      // Flag x is fully handled during tokenization\n      x: 'extended',\n      // Flags D, P, S, W are currently only supported via the top-level `flags` option\n      D: 'digitIsAscii',\n      P: 'posixIsAscii',\n      S: 'spaceIsAscii',\n      W: 'wordIsAscii',\n    }[char] as Exclude<keyof FlagProperties, 'textSegmentMode'>] = true;\n  }\n  return flagProperties;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw: string): number {\n  // Note: Onig 6.9.10 and earlier have a bug where pattern-terminating `\\u` and `\\x` are treated\n  // as identity escapes; see <github.com/kkos/oniguruma/issues/343>. Don't emulate these bugs.\n  // Additionally, Onig treats bare `\\x` as equivalent to `\\0`, and treats incomplete `\\x{` (with\n  // the brace but not immediately followed by a hex digit) as an identity escape, so e.g. `\\x{`\n  // matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are errors. Currently,\n  // this library treats all such cases as errors\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw)!.groups!.hex :\n    raw.slice(2);\n  return parseInt(hex, 16);\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumberToken(token: EscapedNumberToken, numCaptures: number): Array<BackreferenceToken> | Array<CharacterToken> {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createBackreferenceToken(raw)];\n  }\n  const tokens: Array<CharacterToken> = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g)!;\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value: number;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = cpOf(m);\n    }\n    tokens.push(createCharacterToken(value, (i === 0 ? '\\\\' : '') + m));\n  }\n  return tokens;\n}\n\nfunction splitQuantifierMatch(str: string): Array<QuantifierToken> {\n  const tokens: Array<QuantifierToken> = [];\n  // `str` is one or more quantifiers in a chain. It can't be split by a regex because of one edge\n  // case where we have to compare numeric values: although `{1,2}?` is a single, lazy quantifier,\n  // a reversed (possessive) interval quantifier like `{2,1}` can't be both possessive and lazy, so\n  // any following `?`, `??`, or `?+` is a second, chained quantifier (i.e., `{2,1}?` is equivalent\n  // to `{2,1}{0,1}` or `{2,0}`)\n  const withG = new RegExp(quantifierRe, 'gy');\n  let match: RegExpExecArray | null;\n  while ((match = withG.exec(str))) {\n    const m = match[0];\n    if (m[0] === '{') {\n      // Doesn't need to handle fixed `{n}`, infinite max `{n,}`, or implicit zero min `{,n}`\n      // since, according to Onig syntax rules, those can't be possessive\n      const parts = /^\\{(?<min>\\d+),(?<max>\\d+)\\}\\??$/.exec(m);\n      if (parts) {\n        const {min, max} = parts.groups as {min: string, max: string};\n        if (+min > +max && m.endsWith('?')) {\n          // Leave the trailing `?` for the next match\n          withG.lastIndex--;\n          tokens.push(tokenizeQuantifier(m.slice(0, -1)));\n          continue;\n        }\n      }\n    }\n    tokens.push(tokenizeQuantifier(m));\n  }\n  return tokens;\n}\n\nexport {\n  type AlternatorToken,\n  type AssertionToken,\n  type BackreferenceToken,\n  type CharacterToken,\n  type CharacterClassCloseToken,\n  type CharacterClassHyphenToken,\n  type CharacterClassIntersectorToken,\n  type CharacterClassOpenToken,\n  type CharacterSetToken,\n  type DirectiveToken,\n  type FlagGroupModifiers,\n  type FlagProperties,\n  type GroupCloseToken,\n  type GroupOpenToken,\n  type NamedCalloutToken,\n  type QuantifierToken,\n  type SubroutineToken,\n  type Token,\n  type TokenCharacterSetKind,\n  type TokenDirectiveKind,\n  type TokenNamedCalloutKind,\n  type TokenQuantifierKind,\n  tokenize,\n};\n"],
  "mappings": "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",
  "names": ["cpOf", "PosixClassNames", "r", "throwIfNullish", "charClassOpenPattern", "sharedEscapesPattern", "quantifierRe", "tokenRe", "charClassTokenRe", "tokenize", "pattern", "options", "opts", "flagProperties", "getFlagProperties", "xStack", "context", "isXOn", "tokens", "match", "result", "getTokenWithDetails", "potentialUnnamedCaptureTokens", "numNamedAndOptInUnnamedCaptures", "t", "i", "numCaptures", "splitEscapedNumberToken", "m", "lastIndex", "m0", "m1", "getAllTokensForCharClass", "createAssertionToken", "createSubroutineToken", "createBackreferenceToken", "createDirectiveToken", "createCharacterSetToken", "tokenizeSharedEscape", "tokenizeNamedCallout", "tokenizeFlagModifier", "createGroupOpenToken", "createGroupCloseToken", "end", "re", "kind", "createAlternatorToken", "splitQuantifierMatch", "createCharacterToken", "opener", "createCharacterClassOpenToken", "numCharClassesOpen", "createCharacterClassCloseToken", "tokenizeAnyTokenWithinCharClass", "raw", "posix", "createCharacterClassHyphenToken", "createCharacterClassIntersectorToken", "inCharClass", "char1", "tokenizeControlCharacter", "tokenizeShorthand", "tokenizeUnicodeProperty", "bytes", "hex", "decoded", "encoder", "char", "byte", "getValidatedHexCharCode", "EscapeCharCodes", "createEscapedNumberToken", "value", "negate", "createNamedCalloutToken", "tag", "args", "createQuantifierToken", "min", "max", "CalloutNames", "on", "off", "enabledFlags", "getFlagGroupSwitches", "disabledFlags", "flagChanges", "callout", "name", "argsArray", "arg", "arg0", "arg1", "arg2", "tokenizeQuantifier", "minStr", "maxStr", "limit", "lower", "p", "neg", "flags", "obj", "token", "matches", "str", "withG", "parts"]
}
