{
  "version": 3,
  "sources": ["../src/bundle.ts", "../src/utils.ts", "../src/generator/generate.ts", "../src/tokenizer/tokenize.ts", "../src/parser/node-utils.ts", "../src/parser/parse.ts", "../src/unicode.ts", "../src/index.ts", "../src/traverser/traverse.ts", "../src/optimizer/transforms/alternation-to-class.ts", "../src/optimizer/transforms/expose-anchors.ts", "../src/optimizer/transforms/extract-prefix.ts", "../src/optimizer/transforms/extract-prefix-2.ts", "../src/optimizer/transforms/extract-suffix.ts", "../src/optimizer/transforms/merge-ranges.ts", "../src/optimizer/transforms/optionalize.ts", "../src/optimizer/transforms/prevent-redos.ts", "../src/optimizer/transforms/remove-empty-groups.ts", "../src/optimizer/transforms/remove-useless-flags.ts", "../src/optimizer/transforms/simplify-callouts.ts", "../src/optimizer/transforms/unnest-useless-classes.ts", "../src/optimizer/transforms/unwrap-negation-wrappers.ts", "../src/optimizer/transforms/unwrap-useless-classes.ts", "../src/optimizer/transforms/unwrap-useless-groups.ts", "../src/optimizer/transforms/use-shorthands.ts", "../src/optimizer/transforms/use-unicode-aliases.ts", "../src/optimizer/transforms/use-unicode-props.ts", "../src/optimizer/optimizations.ts", "../src/optimizer/optimize.ts"],
  "sourcesContent": ["export {generate} from './generator/generate.js';\nexport {toOnigurumaAst} from './index.js';\nexport {getOptionalOptimizations, optimize} from './optimizer/optimize.js';\nexport {parse} from './parser/parse.js';\nexport {traverse} from './traverser/traverse.js';\nexport {OnigUnicodePropertyMap} from './unicode.js';\n", "function cpOf(char: string): number {\n  // Count code point length\n  if ([...char].length !== 1) {\n    throw new Error(`Expected \"${char}\" to be a single code point`);\n  }\n  return char.codePointAt(0)!;\n}\n\nfunction getOrInsert<Key, Value>(map: Map<Key, Value>, key: Key, defaultValue: Value): Value {\n  if (!map.has(key)) {\n    map.set(key, defaultValue);\n  }\n  return map.get(key)!;\n}\n\nconst PosixClassNames = new Set([\n  'alnum',\n  'alpha',\n  'ascii',\n  'blank',\n  'cntrl',\n  'digit',\n  'graph',\n  'lower',\n  'print',\n  'punct',\n  'space',\n  'upper',\n  'word',\n  'xdigit',\n]);\n\nconst r = String.raw;\n\nfunction throwIfNullish<Value>(value: Value, msg?: string): NonNullable<Value> {\n  if (value == null) {\n    throw new Error(msg ?? 'Value expected');\n  }\n  return value;\n}\n\nexport {\n  cpOf,\n  getOrInsert,\n  PosixClassNames,\n  r,\n  throwIfNullish,\n};\n", "import type {GroupNode, Node, OnigurumaAst, ParentNode, QuantifierNode, RegexNode} from '../parser/parse.js';\nimport type {FlagProperties} from '../tokenizer/tokenize.js';\nimport {r, throwIfNullish} from '../utils.js';\n\ntype OnigurumaRegex = {\n  pattern: string;\n  flags: string;\n};\n\n/**\nGenerates an Oniguruma `pattern` and `flags` from an `OnigurumaAst`.\n*/\nfunction generate(ast: OnigurumaAst): OnigurumaRegex {\n  const parentStack: Array<ParentNode> = [];\n  let lastNode: Node = ast;\n  const state: State = {\n    inCharClass: false,\n    lastNode,\n    parent: ast,\n  };\n  const gen: Gen = node => {\n    state.lastNode = lastNode;\n    lastNode = node; // For the next iteration\n    if (getFirstChild(state.lastNode) === node) {\n      state.parent = state.lastNode as ParentNode;\n      parentStack.push(state.parent);\n    }\n    const fn = throwIfNullish(generator[node.type], `Unexpected node type \"${node.type}\"`);\n    // @ts-expect-error\n    const result = fn(node, state, gen);\n    if (getLastChild(state.parent) === node) {\n      parentStack.pop();\n      state.parent = parentStack.at(-1) ?? ast;\n    };\n    return result;\n  };\n  return {\n    pattern: ast.body.map(gen).join('|'),\n    // Could reset `lastNode` at this point via `lastNode = ast`, but it isn't needed by flags\n    flags: gen(ast.flags),\n  };\n}\n\ntype State = {\n  inCharClass: boolean;\n  lastNode: Node;\n  parent: ParentNode;\n};\n\ntype NonRootNode = Exclude<Node, RegexNode>;\n\ntype Gen = (node: NonRootNode) => string;\n\ntype Generator = {\n  [N in NonRootNode as N['type']]:\n  (node: N, state: State, gen: Gen) => string\n};\n\nconst generator: Generator = {\n  AbsenceFunction({body, kind}, _, gen) {\n    if (kind !== 'repeater') {\n      throw new Error(`Unexpected absence function kind \"${kind}\"`);\n    }\n    return `(?~${body.map(gen).join('|')})`;\n  },\n\n  Alternative({body}, _, gen) {\n    return body.map(gen).join('');\n  },\n\n  Assertion({kind, negate}) {\n    if (kind === 'text_segment_boundary') {\n      return negate ? r`\\Y` : r`\\y`;\n    }\n    if (kind === 'word_boundary') {\n      return negate ? r`\\B` : r`\\b`;\n    }\n    return throwIfNullish({\n      line_end: '$',\n      line_start: '^',\n      search_start: r`\\G`,\n      string_end: r`\\z`,\n      string_end_newline: r`\\Z`,\n      string_start: r`\\A`,\n    }[kind], `Unexpected assertion kind \"${kind}\"`);\n  },\n\n  Backreference({ref}) {\n    if (typeof ref === 'number') {\n      // TODO: Won't be safe to indiscriminately unenclose when forward backrefs are supported\n      return '\\\\' + ref;\n    }\n    // Onig doesn't allow chars `>` or `'` in backref names, so this is safe\n    return `\\\\k<${ref}>`;\n  },\n\n  CapturingGroup({body, name}, _, gen) {\n    const enclosedName = name ? `?${name.includes('>') ? `'${name}'` : `<${name}>`}` : '';\n    return `(${enclosedName}${body.map(gen).join('|')})`;\n  },\n\n  Character(node, {inCharClass, lastNode, parent}) {\n    const {value} = node;\n    if (CharCodeEscapeMap.has(value)) {\n      return CharCodeEscapeMap.get(value)!;\n    }\n    const escDigit = lastNode.type === 'Backreference';\n    if (\n      // Control chars, etc.; condition modeled on the Chrome developer console's display for strings\n      value < 32 || (value > 126 && value < 160) ||\n      // Unicode planes 4-16; unassigned, special purpose, and private use area\n      value > 0x3FFFF ||\n      // Avoid corrupting a preceding backref by immediately following it with a literal digit\n      (escDigit && isDigitCharCode(value))\n    ) {\n      // Onig treats unenclosed `\\x80` to `\\xFF` as an encoded byte (a fragment of a code unit), so\n      // we can't use them to represent a character. Also, don't convert value `0` to `\\0` since\n      // that's corruptible by following literal digits\n      return value > 0x7F ?\n        `\\\\x{${value.toString(16).toUpperCase()}}` :\n        `\\\\x${value.toString(16).toUpperCase().padStart(2, '0')}`;\n    }\n    const char = String.fromCodePoint(value);\n    let escape = false;\n    if (inCharClass) {\n      const isDirectClassKid = parent.type === 'CharacterClass';\n      const isFirst = isDirectClassKid && parent.body[0] === node;\n      const isLast = isDirectClassKid && parent.body.at(-1) === node;\n      // Avoid escaping in some optional special cases when escaping isn't needed due to position\n      if (char === '^') {\n        escape = isFirst && !parent.negate;\n      } else if (char === ']') {\n        escape = !isFirst;\n      } else if (char === '-') {\n        // Could also avoid escaping if it's immediately after a range or nested class, but don't\n        // make that the default rendering\n        escape = !isFirst && !isLast;\n      } else {\n        escape = CharClassEscapeChars.has(char);\n      }\n    } else {\n      escape = BaseEscapeChars.has(char);\n    }\n    return `${escape ? '\\\\' : ''}${char}`;\n  },\n\n  CharacterClass({body, kind, negate}, state, gen) {\n    function genClass() {\n      if (\n        state.parent.type === 'CharacterClass' &&\n        state.parent.kind === 'intersection' &&\n        kind === 'union' &&\n        !body.length\n      ) {\n        // Prevent empty intersection like `[&&]` from becoming the invalid `[[]&&[]]`\n        return '';\n      }\n      return `[${negate ? '^' : ''}${\n        body.map(gen).join(kind === 'intersection' ? '&&' : '')\n      }]`;\n    }\n    if (!state.inCharClass) {\n      // For the outermost char class, set state\n      state.inCharClass = true;\n      const result = genClass();\n      state.inCharClass = false;\n      return result;\n    }\n    return genClass();\n  },\n\n  CharacterClassRange({min, max}, _, gen) {\n    return `${gen(min)}-${gen(max)}`;\n  },\n\n  CharacterSet({kind, negate, value}, {inCharClass}) {\n    switch (kind) {\n      case 'any':\n        return r`\\O`;\n      case 'digit':\n        return negate ? r`\\D` : r`\\d`;\n      case 'dot':\n        return '.';\n      case 'hex':\n        return negate ? r`\\H` : r`\\h`;\n      case 'newline':\n        return negate ? r`\\N` : r`\\R`;\n      case 'posix':\n        return inCharClass ?\n          `[:${negate ? '^' : ''}${value}:]` :\n          `${negate ? r`\\P` : r`\\p`}{${value}}`;\n      case 'property':\n        return `${negate ? r`\\P` : r`\\p`}{${value}}`;\n      case 'space':\n        return negate ? r`\\S` : r`\\s`;\n      case 'text_segment':\n        return r`\\X`;\n      case 'word':\n        return negate ? r`\\W` : r`\\w`;\n      default:\n        throw new Error(`Unexpected character set kind \"${kind}\"`);\n    }\n  },\n\n  Directive({kind, flags}) {\n    if (kind === 'flags') {\n      const {enable = {}, disable = {}} = flags;\n      const enableStr = getFlagsStr(enable);\n      const disableStr = getFlagsStr(disable);\n      return (enableStr || disableStr) ? `(?${enableStr}${disableStr ? `-${disableStr}` : ''})` : '';\n    }\n    if (kind === 'keep') {\n      return r`\\K`;\n    }\n    throw new Error(`Unexpected directive kind \"${kind}\"`);\n  },\n\n  Flags(node) {\n    return getFlagsStr(node);\n  },\n\n  Group({atomic, body, flags}, _, gen) {\n    const contents = body.map(gen).join('|');\n    return `(?${getGroupPrefix(atomic, flags)}${contents})`;\n  },\n\n  LookaroundAssertion({body, kind, negate}, _, gen) {\n    const prefix = `${kind === 'lookahead' ? '' : '<'}${negate ? '!' : '='}`;\n    return `(?${prefix}${body.map(gen).join('|')})`;\n  },\n\n  NamedCallout({kind, tag, arguments: args}) {\n    if (kind === 'custom') {\n      // TODO: If supporting custom callout names in the future (with an added `name` property for\n      // `NamedCalloutNode`), will need to use `name` instead of `kind` if `kind` is `'custom'`\n      throw new Error(`Unexpected named callout kind \"${kind}\"`);\n    }\n    return `(*${kind.toUpperCase()}${tag ? `[${tag}]` : ''}${args ? `{${args.join(',')}}` : ''})`;\n  },\n\n  Quantifier(node, {parent}, gen) {\n    // Rendering Onig quantifiers is wildly, unnecessarily complex compared to other regex flavors\n    // because of the combination of a few features unique to Onig:\n    // - You can create quantifier chains (i.e., quantify a quantifier).\n    // - An implicit zero min is allowed for interval quantifiers (ex: `{,2}`).\n    // - Interval quantifiers can't use `+` to make them possessive (it creates a quantifier\n    //   chain), even though quantifiers `?` `*` `+` can.\n    // - A reversed range in a quantifier makes it possessive (ex: `{2,1}`).\n    //   - `{,n}` is always greedy with an implicit zero min, and can't represent a possesive range\n    //     from n to infinity.\n    const {body, kind, max, min} = node;\n    // These errors shouldn't happen unless the AST is modified in an invalid way after parsing\n    if (min === Infinity) {\n      throw new Error(`Invalid quantifier: infinite min`);\n    }\n    if (min > max) {\n      throw new Error(`Invalid quantifier: min \"${min}\" > max \"${max}\"`);\n    }\n    const kidIsGreedyQuantifier = (\n      body.type === 'Quantifier' &&\n      body.kind === 'greedy'\n    );\n    const parentIsPossessivePlus = (\n      parent.type === 'Quantifier' &&\n      parent.kind === 'possessive' &&\n      parent.min === 1 &&\n      parent.max === Infinity\n    );\n    // Can't render as a symbol, because the following (parent) quantifier, which is `++`, would\n    // then alter this node's meaning to make it possessive, and the parent quantifier can't change\n    // to avoid this because there's no interval representation possible for `++`. There's also no\n    // other way to render `*+`, but a following `*` wouldn't alter the meaning of this node. `?+`\n    // is also safe since it can use the alternative `{1,0}` representation (which is possessive)\n    const forcedInterval = kind === 'greedy' && parentIsPossessivePlus;\n    let base;\n    if (isSymbolQuantifierCandidate(node) && !forcedInterval) {\n      if (\n        !min && max === 1 &&\n        // Can't chain a base of `?` to any greedy quantifier since that would make it lazy\n        !kidIsGreedyQuantifier\n      ) {\n        base = '?';\n      } else if (!min && max === Infinity) {\n        base = '*';\n      } else if (\n        min === 1 && max === Infinity &&\n        ( // Can't chain a base of `+` to greedy `?`/`*`/`+` since that would make them possessive\n          !(kidIsGreedyQuantifier && isSymbolQuantifierCandidate(body)) ||\n          // ...but, we're forced to use `+` (and change the kid's rendering) if this is possessive\n          // `++` since you can't use a possessive reversed range with `Infinity`\n          kind === 'possessive'\n        )\n      ) {\n        base = '+';\n      }\n    }\n    const isIntervalQuantifier = !base;\n    if (isIntervalQuantifier) {\n      if (kind === 'possessive') {\n        if (min === max) {\n          // Can't add a `+` suffix to a fixed `{n}` interval quantifier\n          throw new Error(`Invalid possessive quantifier: min and max are equal \"${min}\"`);\n        }\n        if (max === Infinity) {\n          // Onig reversed ranges are possessive but `{,n}` is the same as greedy `{0,n}`, so\n          // there's no way to represent this without adding additional nodes that aren't in the\n          // AST. The exceptions are when `min` is 0 or 1 (`?+`, `*+`, `++`), but we've already\n          // ruled out rendering as a symbol at this point\n          throw new Error(`Invalid possessive quantifier: min \"${min}\" with infinite max\"`);\n        }\n        // Reversed range\n        base = `{${max},${min}}`;\n      } else if (min === max) {\n        base = `{${min}}`;\n      } else {\n        base = `{${min},${max === Infinity ? '' : max}}`;\n      }\n    }\n    const suffix = {\n      greedy: '',\n      lazy: '?',\n      // Interval quantifiers are marked possessive by reversing their min/max; a `+` suffix would\n      // create a quantifier chain\n      possessive: isIntervalQuantifier ? '' : '+',\n    }[kind];\n    return `${gen(body)}${base}${suffix}`;\n  },\n\n  Subroutine({ref}) {\n    if (typeof ref === 'string' && ref.includes('>')) {\n      return r`\\g'${ref}'`;\n    }\n    return r`\\g<${ref}>`;\n  },\n};\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\nconst BaseEscapeChars = new Set([\n  '$', '(', ')', '*', '+', '.', '?', '[', '\\\\', '^', '{', '|',\n]);\n\nconst CharClassEscapeChars = new Set([\n  '&', '-', '[', '\\\\', ']', '^',\n]);\n\nconst CharCodeEscapeMap = new Map([\n  [ 7, r`\\a`], // bell\n  [ 9, r`\\t`], // horizontal tab\n  [10, r`\\n`], // line feed\n  [11, r`\\v`], // vertical tab\n  [12, r`\\f`], // form feed\n  [13, r`\\r`], // carriage return\n  [27, r`\\e`], // escape\n  [0x2028, r`\\u2028`], // line separator\n  [0x2029, r`\\u2029`], // paragraph separator\n  [0xFEFF, r`\\uFEFF`], // ZWNBSP/BOM\n]);\n\nfunction getFirstChild(node: Node) {\n  if ('body' in node) {\n    return Array.isArray(node.body) ? (node.body[0] ?? null) : node.body;\n  }\n  // Check for `type` to determine if it's a child node; quantifiers have a numeric `min`\n  if ('min' in node && node.min.type) {\n    return node.min;\n  }\n  return null;\n}\n\nfunction getLastChild(node: Node) {\n  if ('body' in node) {\n    return Array.isArray(node.body) ? (node.body.at(-1) ?? null) : node.body;\n  }\n  // Check for `type` to determine if it's a child node; quantifiers have a numeric `max`\n  if ('max' in node && node.max.type) {\n    return node.max;\n  }\n  return null;\n}\n\nfunction getFlagsStr({\n  ignoreCase,\n  dotAll,\n  extended,\n  digitIsAscii,\n  posixIsAscii,\n  spaceIsAscii,\n  wordIsAscii,\n  textSegmentMode,\n}: Partial<FlagProperties>): string {\n  return `${\n    ignoreCase ? 'i' : ''\n  }${\n    dotAll ? 'm' : ''\n  }${\n    extended ? 'x' : ''\n  }${\n    digitIsAscii ? 'D' : ''\n  }${\n    posixIsAscii ? 'P' : ''\n  }${\n    spaceIsAscii ? 'S' : ''\n  }${\n    wordIsAscii ? 'W' : ''\n  }${\n    textSegmentMode ? throwIfNullish({\n      grapheme: 'y{g}',\n      word: 'y{w}',\n    }[textSegmentMode], `Unexpected text segment mode \"${textSegmentMode}\"`) : ''\n  }`;\n}\n\nfunction getGroupPrefix(atomic: GroupNode['atomic'], flags?: GroupNode['flags']): string {\n  if (atomic) {\n    return '>';\n  }\n  let mods = '';\n  if (flags) {\n    const {enable = {}, disable = {}} = flags;\n    const enableStr = getFlagsStr(enable);\n    const disableStr = getFlagsStr(disable);\n    mods = `${enableStr}${disableStr ? `-${disableStr}` : ''}`;\n  }\n  return `${mods}:`;\n}\n\nfunction isDigitCharCode(value: number): boolean {\n  return value > 47 && value < 58;\n}\n\nfunction isSymbolQuantifierCandidate({min, max}: QuantifierNode): boolean {\n  return (\n    (!min && max === 1) || // `?`\n    (!min && max === Infinity) || // `*`\n    (min === 1 && max === Infinity) // `+`\n  );\n}\n\nexport {\n  type OnigurumaRegex,\n  generate,\n};\n", "import {cpOf, PosixClassNames, r, throwIfNullish} from '../utils.js';\n\ntype Token =\n  AlternatorToken |\n  AssertionToken |\n  BackreferenceToken |\n  CharacterToken |\n  CharacterClassCloseToken |\n  CharacterClassHyphenToken |\n  CharacterClassIntersectorToken |\n  CharacterClassOpenToken |\n  CharacterSetToken |\n  DirectiveToken |\n  GroupCloseToken |\n  GroupOpenToken |\n  NamedCalloutToken |\n  QuantifierToken |\n  SubroutineToken;\n\ntype IntermediateToken =\n  EscapedNumberToken;\n\ntype TokenCharacterSetKind =\n  'any' |\n  'digit' |\n  'dot' |\n  'hex' |\n  'newline' |\n  'posix' |\n  'property' |\n  'space' |\n  'text_segment' |\n  'word';\n\ntype TokenDirectiveKind =\n  'flags' |\n  'keep';\n\ntype TokenGroupOpenKind =\n  'absence_repeater' |\n  'atomic' |\n  'capturing' |\n  'group' |\n  'lookahead' |\n  'lookbehind';\n\ntype TokenQuantifierKind =\n  'greedy' |\n  'lazy' |\n  'possessive';\n\ntype TokenNamedCalloutKind =\n  'count' |\n  'cmp' |\n  'error' |\n  'fail' |\n  'max' |\n  'mismatch' |\n  'skip' |\n  'total_count' |\n  'custom';\n\nconst charClassOpenPattern = r`\\[\\^?`;\nconst sharedEscapesPattern = `${\n  // Control char\n  'c.? | C(?:-.?)?'\n}|${\n  // Unicode property; Onig considers `\\p` an identity escape, but e.g. `\\p{`, `\\p{ ^L}`, and\n  // `\\p{gc=L}` are invalid\n  r`[pP]\\{(?:\\^?[-\\x20_]*[A-Za-z][-\\x20\\w]*\\})?`\n}|${\n  // Hex encoded byte sequence; attempt match before other `\\xNN` hex char\n  r`x[89A-Fa-f]\\p{AHex}(?:\\\\x[89A-Fa-f]\\p{AHex})*`\n}|${\n  // Hex char\n  r`u(?:\\p{AHex}{4})? | x\\{[^\\}]*\\}? | x\\p{AHex}{0,2}`\n}|${\n  // Enclosed octal code point\n  r`o\\{[^\\}]*\\}?`\n}|${\n  // Escaped number\n  r`\\d{1,3}`\n}`;\n// Even with flag x, Onig doesn't allow whitespace to separate a quantifier from the `?` or `+`\n// that makes it lazy or possessive. Possessive suffixes don't apply to interval quantifiers\nconst quantifierRe = /[?*+][?+]?|\\{(?:\\d+(?:,\\d*)?|,\\d+)\\}\\??/;\nconst tokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | [gk]<[^>]*>?\n    | [gk]'[^']*'?\n    | .\n  )\n  | \\( (?:\n    \\? (?:\n      [:=!>({]\n      | <[=!]\n      | <[^>]*>\n      | '[^']*'\n      | ~\\|?\n      | #(?:[^)\\\\]|\\\\.?)*\n      | [^:)]*[:)]\n    )?\n    | \\*[^\\)]*\\)?\n  )?\n  | (?:${quantifierRe.source})+\n  | ${charClassOpenPattern}\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\nconst charClassTokenRe = new RegExp(r`\n  \\\\ (?:\n    ${sharedEscapesPattern}\n    | .\n  )\n  | \\[:(?:\\^?\\p{Alpha}+|\\^):\\]\n  | ${charClassOpenPattern}\n  | &&\n  | .\n`.replace(/\\s+/g, ''), 'gsu');\n\ntype Context = {\n  captureGroup: boolean;\n  getCurrentModX(): boolean;\n  numOpenGroups: number;\n  popModX(): void;\n  pushModX(isXOn: boolean): void;\n  replaceCurrentModX(isXOn: boolean): void;\n  singleline: boolean;\n};\n\ntype TokenizeOptions = {\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n};\n\nfunction tokenize(pattern: string, options: TokenizeOptions = {}): {\n  tokens: Array<Token>;\n  flags: FlagProperties;\n} {\n  const opts = {\n    flags: '',\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  if (typeof pattern !== 'string') {\n    throw new Error('String expected as pattern');\n  }\n  const flagProperties = getFlagProperties(opts.flags);\n  const xStack = [flagProperties.extended];\n  const context: Context = {\n    captureGroup: opts.rules.captureGroup,\n    // Always at least has the top-level flag x\n    getCurrentModX() {return xStack.at(-1)!},\n    numOpenGroups: 0,\n    popModX() {xStack.pop()},\n    pushModX(isXOn) {xStack.push(isXOn)},\n    replaceCurrentModX(isXOn) {xStack[xStack.length - 1] = isXOn},\n    singleline: opts.rules.singleline,\n  };\n  let tokens: Array<Token | IntermediateToken> = [];\n  let match: RegExpExecArray | null;\n  tokenRe.lastIndex = 0;\n  while ((match = tokenRe.exec(pattern))) {\n    const result = getTokenWithDetails(context, pattern, match[0], tokenRe.lastIndex);\n    if (result.tokens) {\n      tokens.push(...result.tokens);\n    } else if (result.token) {\n      tokens.push(result.token);\n    }\n    if (result.lastIndex !== undefined) {\n      tokenRe.lastIndex = result.lastIndex;\n    }\n  }\n\n  const potentialUnnamedCaptureTokens: Array<GroupOpenToken> = [];\n  let numNamedAndOptInUnnamedCaptures = 0;\n  tokens.filter(t => t.type === 'GroupOpen').forEach(t => {\n    if (t.kind === 'capturing') {\n      t.number = ++numNamedAndOptInUnnamedCaptures;\n    } else if (t.raw === '(') {\n      potentialUnnamedCaptureTokens.push(t);\n    }\n  });\n  // Enable unnamed capturing groups if no named captures (when `captureGroup` not enabled)\n  if (!numNamedAndOptInUnnamedCaptures) {\n    potentialUnnamedCaptureTokens.forEach((t, i) => {\n      t.kind = 'capturing';\n      t.number = i + 1;\n    });\n  }\n  const numCaptures = numNamedAndOptInUnnamedCaptures || potentialUnnamedCaptureTokens.length;\n  // Can now split escaped nums accurately, accounting for number of captures\n  const tokensWithoutIntermediate = tokens.map(\n    t => t.type === 'EscapedNumber' ? splitEscapedNumberToken(t, numCaptures) : t\n  ).flat();\n\n  return {\n    tokens: tokensWithoutIntermediate,\n    flags: flagProperties,\n  };\n}\n\nfunction getTokenWithDetails(context: Context, pattern: string, m: string, lastIndex: number): {\n  token: Token | IntermediateToken;\n  tokens?: never;\n  lastIndex?: number;\n} | {\n  token?: never;\n  tokens: Array<Token | IntermediateToken>;\n  lastIndex?: number;\n} | {\n  token?: never;\n  tokens?: never;\n  lastIndex: number;\n} {\n  const [m0, m1] = m;\n\n  if (m === '[' || m === '[^') {\n    const result = getAllTokensForCharClass(pattern, m, lastIndex);\n    return {\n      // Array of all of the char class's tokens\n      tokens: result.tokens,\n      // Jump forward to the end of the char class\n      lastIndex: result.lastIndex,\n    };\n  }\n\n  if (m0 === '\\\\') {\n    if ('AbBGyYzZ'.includes(m1)) {\n      return {\n        token: createAssertionToken(m, m),\n      };\n    }\n    if (/^\\\\g[<']/.test(m)) {\n      if (!/^\\\\g(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createSubroutineToken(m),\n      };\n    }\n    if (/^\\\\k[<']/.test(m)) {\n      if (!/^\\\\k(?:<[^>]+>|'[^']+')$/.test(m)) {\n        throw new Error(`Invalid group name \"${m}\"`);\n      }\n      return {\n        token: createBackreferenceToken(m),\n      };\n    }\n    if (m1 === 'K') {\n      return {\n        token: createDirectiveToken('keep', m),\n      };\n    }\n    if (m1 === 'N' || m1 === 'R') {\n      return {\n        token: createCharacterSetToken('newline', m, {\n          // `\\N` and `\\R` are not actually opposites since the former only excludes `\\n`\n          negate: m1 === 'N',\n        }),\n      };\n    }\n    if (m1 === 'O') {\n      return {\n        token: createCharacterSetToken('any', m),\n      };\n    }\n    if (m1 === 'X') {\n      return {\n        token: createCharacterSetToken('text_segment', m),\n      };\n    }\n    // Run last since it assumes an identity escape as final condition\n    const result = tokenizeSharedEscape(m, {inCharClass: false});\n    return Array.isArray(result) ? {tokens: result} : {token: result};\n  }\n\n  if (m0 === '(') {\n    if (m1 === '*') {\n      return {\n        token: tokenizeNamedCallout(m),\n      };\n    }\n    if (m === '(?{') {\n      throw new Error(`Unsupported callout \"${m}\"`);\n    }\n    // Comment group\n    if (m.startsWith('(?#')) {\n      // Everything except the closing unescaped `)` is included in the match\n      if (pattern[lastIndex] !== ')') {\n        throw new Error('Unclosed comment group \"(?#\"');\n      }\n      return {\n        // Jump forward to after the closing paren\n        lastIndex: lastIndex + 1,\n      };\n    }\n    // Flag modifier (directive or group opener)\n    if (/^\\(\\?[-imx]+[:)]$/.test(m)) {\n      return {\n        token: tokenizeFlagModifier(m, context),\n      };\n    }\n    // --- Remaining group types all reuse current flag x status ---\n    context.pushModX(context.getCurrentModX());\n    context.numOpenGroups++;\n    if (\n      // Unnamed capture if no named captures present and `captureGroup` not enabled, else\n      // noncapturing group\n      (m === '(' && !context.captureGroup) ||\n      // Noncapturing group\n      m === '(?:'\n    ) {\n      return {\n        // For `(`, will later change to `capturing` and add `number` prop if no named captures\n        token: createGroupOpenToken('group', m),\n      };\n    }\n    // Atomic group\n    if (m === '(?>') {\n      return {\n        token: createGroupOpenToken('atomic', m),\n      };\n    }\n    // Lookaround\n    if (m === '(?=' || m === '(?!' || m === '(?<=' || m === '(?<!') {\n      return {\n        token: createGroupOpenToken(m[2] === '<' ? 'lookbehind' : 'lookahead', m, {\n          negate: m.endsWith('!'),\n        }),\n      };\n    }\n    // Unnamed capture when `captureGroup` enabled, or named capture (checked after lookbehind due\n    // to similar syntax)\n    if (\n      (m === '(' && context.captureGroup) ||\n      (m.startsWith('(?<') && m.endsWith('>')) ||\n      (m.startsWith(\"(?'\") && m.endsWith(\"'\"))\n    ) {\n      return {\n        token: createGroupOpenToken('capturing', m, {\n          // Will add `number` prop in a second pass\n          ...(m !== '(' && {name: m.slice(3, -1)}),\n        }),\n      };\n    }\n    if (m.startsWith('(?~')) {\n      if (m === '(?~|') {\n        throw new Error(`Unsupported absence function kind \"${m}\"`);\n      }\n      return {\n        token: createGroupOpenToken('absence_repeater', m),\n      };\n    }\n    if (m === '(?(') {\n      // TODO: Add support\n      throw new Error(`Unsupported conditional \"${m}\"`);\n    }\n    throw new Error(`Invalid or unsupported group option \"${m}\"`);\n  }\n  if (m === ')') {\n    context.popModX();\n    context.numOpenGroups--;\n    if (context.numOpenGroups < 0) {\n      throw new Error('Unmatched \")\"');\n    }\n    return {\n      token: createGroupCloseToken(m),\n    };\n  }\n\n  if (context.getCurrentModX()) {\n    if (m === '#') {\n      // Onig's only line break char is line feed\n      const end = pattern.indexOf('\\n', lastIndex);\n      return {\n        // Jump forward to the end of the comment\n        lastIndex: end === -1 ? pattern.length : end,\n      };\n    }\n    if (/^\\s$/.test(m)) {\n      const re = /\\s+/y;\n      re.lastIndex = lastIndex;\n      const rest = re.exec(pattern);\n      return {\n        // Jump forward to the end of the whitespace\n        lastIndex: rest ? re.lastIndex : lastIndex,\n      };\n    }\n  }\n\n  if (m === '.') {\n    return {\n      token: createCharacterSetToken('dot', m),\n    };\n  }\n\n  if (m === '^' || m === '$') {\n    const kind = context.singleline ? {\n      '^': r`\\A`,\n      '$': r`\\Z`,\n    }[m] : m;\n    return {\n      token: createAssertionToken(kind, m),\n    };\n  }\n\n  if (m === '|') {\n    return {\n      token: createAlternatorToken(m),\n    };\n  }\n\n  if (quantifierRe.test(m)) {\n    return {\n      tokens: splitQuantifierMatch(m),\n    };\n  }\n\n  // `cpOf` asserts that it's a single code point\n  return {\n    token: createCharacterToken(cpOf(m), m),\n  };\n}\n\nfunction getAllTokensForCharClass(pattern: string, opener: CharacterClassOpener, lastIndex: number): {\n  tokens: Array<Token | IntermediateToken>;\n  lastIndex: number;\n} {\n  const tokens: Array<Token | IntermediateToken> = [createCharacterClassOpenToken(opener[1] === '^', opener)];\n  let numCharClassesOpen = 1;\n  let match: RegExpExecArray | null;\n  charClassTokenRe.lastIndex = lastIndex;\n  while ((match = charClassTokenRe.exec(pattern))) {\n    const m = match[0];\n    // Start of nested char class\n    // POSIX classes are handled as a single token; not as a nested char class\n    if (m[0] === '[' && m[1] !== ':') {\n      numCharClassesOpen++;\n      tokens.push(createCharacterClassOpenToken(m[1] === '^', m as CharacterClassOpener));\n    } else if (m === ']') {\n      // Always at least includes the char class opener\n      if (tokens.at(-1)!.type === 'CharacterClassOpen') {\n        // Allow unescaped `]` as leading char\n        tokens.push(createCharacterToken(93, m));\n      } else {\n        numCharClassesOpen--;\n        tokens.push(createCharacterClassCloseToken(m));\n        if (!numCharClassesOpen) {\n          break;\n        }\n      }\n    } else {\n      const result = tokenizeAnyTokenWithinCharClass(m);\n      if (Array.isArray(result)) {\n        tokens.push(...result);\n      } else {\n        tokens.push(result);\n      }\n    }\n  }\n  return {\n    tokens,\n    lastIndex: charClassTokenRe.lastIndex || pattern.length,\n  };\n}\n\nfunction tokenizeAnyTokenWithinCharClass(raw: string): Token | IntermediateToken | Array<Token> {\n  if (raw[0] === '\\\\') {\n    // Assumes an identity escape as final condition\n    return tokenizeSharedEscape(raw, {inCharClass: true});\n  }\n  // POSIX class: `[:name:]` or `[:^name:]`\n  if (raw[0] === '[') {\n    const posix = /\\[:(?<negate>\\^?)(?<name>[a-z]+):\\]/.exec(raw);\n    if (!posix || !PosixClassNames.has(posix.groups!.name)) {\n      throw new Error(`Invalid POSIX class \"${raw}\"`);\n    }\n    return createCharacterSetToken('posix', raw, {\n      value: posix.groups!.name,\n      negate: !!posix.groups!.negate,\n    });\n  }\n  // Range (possibly invalid) or literal hyphen\n  if (raw === '-') {\n    return createCharacterClassHyphenToken(raw);\n  }\n  if (raw === '&&') {\n    return createCharacterClassIntersectorToken(raw);\n  }\n  // `cpOf` asserts that it's a single code point\n  return createCharacterToken(cpOf(raw), raw);\n}\n\n// Tokens shared by base syntax and char class syntax that start with `\\`\nfunction tokenizeSharedEscape(raw: string, {inCharClass}: {inCharClass: boolean}): Token | IntermediateToken | Array<Token> {\n  const char1 = raw[1];\n  if (char1 === 'c' || char1 === 'C') {\n    return tokenizeControlCharacter(raw);\n  }\n  if ('dDhHsSwW'.includes(char1)) {\n    return tokenizeShorthand(raw);\n  }\n  if (raw.startsWith(r`\\o{`)) {\n    throw new Error(`Incomplete, invalid, or unsupported octal code point \"${raw}\"`);\n  }\n  if (/^\\\\[pP]\\{/.test(raw)) {\n    if (raw.length === 3) {\n      throw new Error(`Incomplete or invalid Unicode property \"${raw}\"`);\n    }\n    return tokenizeUnicodeProperty(raw);\n  }\n  // Hex UTF-8 encoded byte sequence\n  if (/^\\\\x[89A-Fa-f]\\p{AHex}/u.test(raw)) {\n    try {\n      const bytes = raw.split(/\\\\x/).slice(1).map(hex => parseInt(hex, 16));\n      const decoded = new TextDecoder('utf-8', {\n        ignoreBOM: true,\n        fatal: true,\n      }).decode(new Uint8Array(bytes));\n      const encoder = new TextEncoder();\n      const tokens = [...decoded].map(char => {\n        // Since this regenerates `raw`, it might have different casing for hex A-F than the input\n        const raw = [...encoder.encode(char)].map(byte => `\\\\x${byte.toString(16)}`).join('');\n        return createCharacterToken(cpOf(char), raw);\n      });\n      return tokens;\n    } catch {\n      throw new Error(`Multibyte code \"${raw}\" incomplete or invalid in Oniguruma`);\n    }\n  }\n  if (char1 === 'u' || char1 === 'x') {\n    return createCharacterToken(getValidatedHexCharCode(raw), raw);\n  }\n  if (EscapeCharCodes.has(char1)) {\n    return createCharacterToken(EscapeCharCodes.get(char1)!, raw);\n  }\n  // Escaped number: backref (possibly invalid), null, octal, or identity escape, possibly followed\n  // by 1-2 literal digits\n  if (/\\d/.test(char1)) {\n    return createEscapedNumberToken(inCharClass, raw);\n  }\n  if (raw === '\\\\') {\n    throw new Error(r`Incomplete escape \"\\\"`);\n  }\n  // Meta `\\M-x` and `\\M-\\C-x` are unsupported; avoid treating as an identity escape\n  if (char1 === 'M') {\n    // TODO: Add support. See:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#12-onig_syn_op2_esc_capital_m_bar_meta-enable-m-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    // - <github.com/ammar/regexp_parser/blob/8851030feda68223d74f502335fb254a20d77016/lib/regexp_parser/expression/classes/escape_sequence.rb#L75>\n    throw new Error(`Unsupported meta \"${raw}\"`);\n  }\n  // Identity escape; count code point length\n  if ([...raw].length === 2) {\n    return createCharacterToken(raw.codePointAt(1)!, raw);\n  }\n  throw new Error(`Unexpected escape \"${raw}\"`);\n}\n\n// --------------------------------\n// --- Token creation and types ---\n// --------------------------------\n\ntype AlternatorToken = {\n  type: 'Alternator';\n  raw: '|';\n};\nfunction createAlternatorToken(raw: '|'): AlternatorToken {\n  return {\n    type: 'Alternator',\n    raw,\n  };\n}\n\ntype AssertionToken = {\n  type: 'Assertion';\n  kind: string;\n  raw: string;\n};\nfunction createAssertionToken(kind: string, raw: string): AssertionToken {\n  return {\n    type: 'Assertion',\n    kind,\n    raw,\n  };\n}\n\ntype BackreferenceToken = {\n  type: 'Backreference';\n  raw: string;\n};\nfunction createBackreferenceToken(raw: string): BackreferenceToken {\n  return {\n    type: 'Backreference',\n    raw,\n  };\n}\n\ntype CharacterToken = {\n  type: 'Character';\n  value: number;\n  raw: string;\n};\nfunction createCharacterToken(value: number, raw: string): CharacterToken {\n  return {\n    type: 'Character',\n    value,\n    raw,\n  };\n}\n\ntype CharacterClassCloseToken = {\n  type: 'CharacterClassClose';\n  raw: ']';\n};\nfunction createCharacterClassCloseToken(raw: ']'): CharacterClassCloseToken {\n  return {\n    type: 'CharacterClassClose',\n    raw,\n  };\n}\n\ntype CharacterClassHyphenToken = {\n  type: 'CharacterClassHyphen';\n  raw: '-';\n};\nfunction createCharacterClassHyphenToken(raw: '-'): CharacterClassHyphenToken {\n  return {\n    type: 'CharacterClassHyphen',\n    raw,\n  };\n}\n\ntype CharacterClassIntersectorToken = {\n  type: 'CharacterClassIntersector';\n  raw: '&&';\n};\nfunction createCharacterClassIntersectorToken(raw: '&&'): CharacterClassIntersectorToken {\n  return {\n    type: 'CharacterClassIntersector',\n    raw,\n  };\n}\n\ntype CharacterClassOpenToken = {\n  type: 'CharacterClassOpen';\n  negate: boolean;\n  raw: CharacterClassOpener;\n};\ntype CharacterClassOpener = '[' | '[^';\nfunction createCharacterClassOpenToken(negate: boolean, raw: CharacterClassOpener): CharacterClassOpenToken {\n  return {\n    type: 'CharacterClassOpen',\n    negate,\n    raw,\n  };\n}\n\ntype CharacterSetToken = {\n  type: 'CharacterSet';\n  kind: TokenCharacterSetKind;\n  value?: string;\n  negate?: boolean;\n  raw: string;\n};\nfunction createCharacterSetToken(\n  kind: TokenCharacterSetKind,\n  raw: string,\n  options: {\n    value?: string;\n    negate?: boolean;\n  } = {}\n): CharacterSetToken {\n  return {\n    type: 'CharacterSet',\n    kind,\n    ...options,\n    raw,\n  };\n}\n\ntype DirectiveToken = {\n  type: 'Directive';\n  raw: string;\n} & ({\n  kind: 'keep';\n  flags?: never;\n} | {\n  kind: 'flags';\n  flags: FlagGroupModifiers;\n});\nfunction createDirectiveToken(kind: TokenDirectiveKind, raw: string, options: {flags?: FlagGroupModifiers} = {}): DirectiveToken {\n  if (kind === 'keep') {\n    return {\n      type: 'Directive',\n      kind,\n      raw,\n    };\n  }\n  return {\n    type: 'Directive',\n    kind,\n    flags: throwIfNullish(options.flags),\n    raw,\n  };\n}\n\ntype EscapedNumberToken = {\n  type: 'EscapedNumber';\n  inCharClass: boolean;\n  raw: string;\n};\n/**\nIntermediate representation only; will become a `Backreference` or one or more `Character`s.\n*/\nfunction createEscapedNumberToken(inCharClass: boolean, raw: string): EscapedNumberToken {\n  return {\n    type: 'EscapedNumber',\n    inCharClass,\n    raw,\n  };\n}\n\ntype GroupCloseToken = {\n  type: 'GroupClose';\n  raw: ')';\n};\nfunction createGroupCloseToken(raw: ')'): GroupCloseToken {\n  return {\n    type: 'GroupClose',\n    raw,\n  };\n}\n\ntype GroupOpenToken = {\n  type: 'GroupOpen';\n  kind: TokenGroupOpenKind;\n  flags?: FlagGroupModifiers;\n  name?: string;\n  number?: number;\n  negate?: boolean;\n  raw: string;\n};\nfunction createGroupOpenToken(\n  kind: TokenGroupOpenKind,\n  raw: string,\n  options: {\n    flags?: FlagGroupModifiers;\n    name?: string;\n    number?: number;\n    negate?: boolean;\n  } = {}\n): GroupOpenToken {\n  return {\n    type: 'GroupOpen',\n    kind,\n    ...options,\n    raw,\n  };\n}\n\ntype NamedCalloutToken = {\n  type: 'NamedCallout';\n  kind: TokenNamedCalloutKind;\n  tag: string | null;\n  arguments: Array<string | number> | null;\n  raw: string;\n};\nfunction createNamedCalloutToken(\n  kind: TokenNamedCalloutKind,\n  tag: string | null,\n  args: Array<string | number> | null,\n  raw: string\n): NamedCalloutToken {\n  return {\n    type: 'NamedCallout',\n    kind,\n    tag,\n    arguments: args,\n    raw,\n  };\n};\n\ntype QuantifierToken = {\n  type: 'Quantifier';\n  kind: TokenQuantifierKind;\n  min: number;\n  max: number;\n  raw: string;\n};\nfunction createQuantifierToken(\n  kind: TokenQuantifierKind,\n  min: number,\n  max: number,\n  raw: string\n): QuantifierToken {\n  return {\n    type: 'Quantifier',\n    kind,\n    min,\n    max,\n    raw,\n  };\n}\n\ntype SubroutineToken = {\n  type: 'Subroutine';\n  raw: string;\n};\nfunction createSubroutineToken(raw: string): SubroutineToken {\n  return {\n    type: 'Subroutine',\n    raw,\n  };\n}\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\ntype FlagProperties = {\n  ignoreCase: boolean;\n  dotAll: boolean;\n  extended: boolean;\n  digitIsAscii: boolean;\n  posixIsAscii: boolean;\n  spaceIsAscii: boolean;\n  wordIsAscii: boolean;\n  textSegmentMode: 'grapheme' | 'word' | null;\n};\n\ntype FlagGroupModifiers = {\n  enable?: FlagGroupSwitches;\n  disable?: FlagGroupSwitches;\n};\n\ntype FlagGroupSwitches = {\n  ignoreCase?: true;\n  dotAll?: true;\n  extended?: true;\n};\n\nconst CalloutNames = new Set<Uppercase<Exclude<TokenNamedCalloutKind, 'custom'>>>([\n  'COUNT',\n  'CMP',\n  'ERROR',\n  'FAIL',\n  'MAX',\n  'MISMATCH',\n  'SKIP',\n  'TOTAL_COUNT',\n]);\n\nconst EscapeCharCodes = new Map([\n  ['a',  7], // alert/bell (Not available in JS)\n  ['b',  8], // backspace (only in char classes)\n  ['e', 27], // escape (Not available in JS)\n  ['f', 12], // form feed\n  ['n', 10], // line feed\n  ['r', 13], // carriage return\n  ['t',  9], // horizontal tab\n  ['v', 11], // vertical tab\n]);\n\n// Expects `\\cx` or `\\C-x`\nfunction tokenizeControlCharacter(raw: string): CharacterToken {\n  const char = raw[1] === 'c' ? raw[2] : raw[3];\n  if (!char || !/[A-Za-z]/.test(char)) {\n    // Unlike JS, Onig allows any char to follow `\\c` or `\\C-`, but this is an extreme edge case\n    // TODO: Add support. See:\n    // - <github.com/kkos/oniguruma/blob/master/doc/SYNTAX.md#11-onig_syn_op2_esc_capital_c_bar_control-enable-c-x>\n    // - <github.com/kkos/oniguruma/blob/43a8c3f3daf263091f3a74019d4b32ebb6417093/src/regparse.c#L4695>\n    throw new Error(`Unsupported control character \"${raw}\"`);\n  }\n  return createCharacterToken(cpOf(char.toUpperCase()) - 64, raw);\n}\n\nfunction tokenizeFlagModifier(raw: string, context: Context): DirectiveToken | GroupOpenToken {\n  // Allows multiple `-` and solo `-` without `on` or `off` flags\n  let {on, off} = /^\\(\\?(?<on>[imx]*)(?:-(?<off>[-imx]*))?/.exec(raw)!.groups as {on: string, off: string | undefined};\n  off ??= '';\n  // Flag x is used directly by the tokenizer since it changes how to interpret the pattern\n  const isXOn = (context.getCurrentModX() || on.includes('x')) && !off.includes('x');\n  const enabledFlags = getFlagGroupSwitches(on);\n  const disabledFlags = getFlagGroupSwitches(off);\n  const flagChanges: FlagGroupModifiers = {};\n  enabledFlags && (flagChanges.enable = enabledFlags);\n  disabledFlags && (flagChanges.disable = disabledFlags);\n  // Flag directive; ex: `(?im-x)`\n  if (raw.endsWith(')')) {\n    // Replace flag x value until the end of the current group\n    context.replaceCurrentModX(isXOn);\n    // Can't remove flag directives without flags like `(?-)`; they affect following quantifiers\n    return createDirectiveToken('flags', raw, {\n      flags: flagChanges,\n    });\n  }\n  // Flag group opener; ex: `(?im-x:`\n  if (raw.endsWith(':')) {\n    context.pushModX(isXOn);\n    context.numOpenGroups++;\n    return createGroupOpenToken('group', raw, {\n      ...((enabledFlags || disabledFlags) && {flags: flagChanges}),\n    });\n  }\n  throw new Error(`Unexpected flag modifier \"${raw}\"`);\n}\n\nfunction tokenizeNamedCallout(raw: string): NamedCalloutToken {\n  const callout = /\\(\\*(?<name>[A-Za-z_]\\w*)?(?:\\[(?<tag>(?:[A-Za-z_]\\w*)?)\\])?(?:\\{(?<args>[^}]*)\\})?\\)/.exec(raw);\n  if (!callout) {\n    throw new Error(`Incomplete or invalid named callout \"${raw}\"`);\n  }\n  const {name, tag, args} = callout.groups as Partial<{\n    name: string;\n    tag: string;\n    args: string;\n  }>;\n  if (!name) {\n    throw new Error(`Invalid named callout \"${raw}\"`);\n  }\n  if (tag === '') {\n    throw new Error(`Named callout tag with empty value not allowed \"${raw}\"`);\n  }\n  const argsArray: Array<string | number> = args ?\n    args.split(',').\n      // Onig skips over/ignores redundant/unnecessary commas\n      filter(arg => arg !== '').\n      map(arg => /^[+-]?\\d+$/.test(arg) ? +arg : arg) :\n    [];\n  const [arg0, arg1, arg2] = argsArray;\n  const kind: TokenNamedCalloutKind = CalloutNames.has(name as Uppercase<Exclude<TokenNamedCalloutKind, 'custom'>>) ?\n    name.toLowerCase() as TokenNamedCalloutKind :\n    'custom';\n  switch (kind) {\n    case 'fail':\n    case 'mismatch':\n    case 'skip':\n      if (argsArray.length > 0) {\n        throw new Error(`Named callout arguments not allowed \"${argsArray}\"`);\n      }\n      break;\n    case 'error':\n      if (argsArray.length > 1) {\n        throw new Error(`Named callout allows only one argument \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string') {\n        throw new Error(`Named callout argument must be a number \"${arg0}\"`);\n      }\n      break;\n    case 'max':\n      if (!argsArray.length || argsArray.length > 2) {\n        throw new Error(`Named callout must have one or two arguments \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg0)) {\n        throw new Error(`Named callout argument one must be a tag or number \"${arg0}\"`);\n      }\n      if (argsArray.length === 2 && (typeof arg1 === 'number' || !/^[<>X]$/.test(arg1))) {\n        throw new Error(`Named callout optional argument two must be '<', '>', or 'X' \"${arg1}\"`);\n      }\n      break;\n    case 'count':\n    case 'total_count':\n      if (argsArray.length > 1) {\n        throw new Error(`Named callout allows only one argument \"${argsArray}\"`);\n      }\n      if (argsArray.length === 1 && (typeof arg0 === 'number' || !/^[<>X]$/.test(arg0))) {\n        throw new Error(`Named callout optional argument must be '<', '>', or 'X' \"${arg0}\"`);\n      }\n      break;\n    case 'cmp':\n      if (argsArray.length !== 3) {\n        throw new Error(`Named callout must have three arguments \"${argsArray}\"`);\n      }\n      if (typeof arg0 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg0)) {\n        throw new Error(`Named callout argument one must be a tag or number \"${arg0}\"`);\n      }\n      if (typeof arg1 === 'number' || !/^(?:[<>!=]=|[<>])$/.test(arg1)) {\n        throw new Error(`Named callout argument two must be '==', '!=', '>', '<', '>=', or '<=' \"${arg1}\"`);\n      }\n      if (typeof arg2 === 'string' && !/^[A-Za-z_]\\w*$/.test(arg2)) {\n        throw new Error(`Named callout argument three must be a tag or number \"${arg2}\"`);\n      }\n      break;\n    case 'custom':\n      // TODO: Can support custom callout names via a new option that allows providing a list of\n      // allowed, non-built-in names\n      throw new Error(`Undefined callout name \"${name}\"`);\n    default:\n      throw new Error(`Unexpected named callout kind \"${kind}\"`);\n  }\n  // TODO: If supporting custom callout names in the future (with an added `name` property for\n  // `NamedCalloutToken`), will need to set `name` to `null` if `kind` isn't `'custom'`\n  return createNamedCalloutToken(kind, tag ?? null, args?.split(',') ?? null, raw);\n}\n\nfunction tokenizeQuantifier(raw: string): QuantifierToken {\n  let kind: TokenQuantifierKind = null!;\n  let min: number;\n  let max: number;\n  if (raw[0] === '{') {\n    const {minStr, maxStr} =\n      /^\\{(?<minStr>\\d*)(?:,(?<maxStr>\\d*))?/.exec(raw)!.groups as {minStr: string, maxStr: string | undefined};\n    const limit = 100_000;\n    if (+minStr > limit || (maxStr && +maxStr > limit)) {\n      throw new Error('Quantifier value unsupported in Oniguruma');\n    }\n    min = +minStr;\n    max = maxStr === undefined ? +minStr : (maxStr === '' ? Infinity : +maxStr);\n    // By default, Onig doesn't support making interval quantifiers possessive with a `+` suffix;\n    // uses reversed range instead\n    if (min > max) {\n      kind = 'possessive';\n      [min, max] = [max, min];\n    }\n    if (raw.endsWith('?')) {\n      if (kind === 'possessive') {\n        // TODO: <github.com/slevithan/oniguruma-parser/issues/10>\n        throw new Error('Unsupported possessive interval quantifier chain with \"?\"');\n      }\n      kind = 'lazy';\n    } else if (!kind) {\n      kind = 'greedy';\n    }\n  } else {\n    min = raw[0] === '+' ? 1 : 0;\n    max = raw[0] === '?' ? 1 : Infinity;\n    kind = raw[1] === '+' ? 'possessive' : (raw[1] === '?' ? 'lazy' : 'greedy');\n  }\n  return createQuantifierToken(kind, min, max, raw);\n}\n\nfunction tokenizeShorthand(raw: string): CharacterSetToken {\n  const lower = raw[1].toLowerCase();\n  return createCharacterSetToken({\n    'd': 'digit',\n    'h': 'hex',\n    's': 'space',\n    'w': 'word',\n  }[lower] as TokenCharacterSetKind, raw, {\n    negate: raw[1] !== lower,\n  });\n}\n\nfunction tokenizeUnicodeProperty(raw: string): CharacterSetToken {\n  const {p, neg, value} = /^\\\\(?<p>[pP])\\{(?<neg>\\^?)(?<value>[^}]+)/.exec(raw)!.groups!;\n  const negate = (p === 'P' && !neg) || (p === 'p' && !!neg);\n  return createCharacterSetToken('property', raw, {\n    value,\n    negate,\n  });\n}\n\nfunction getFlagGroupSwitches(flags: string): FlagGroupSwitches | null {\n  // Don't include `false` for flags that aren't included\n  const obj: FlagGroupSwitches = {};\n  if (flags.includes('i')) {\n    obj.ignoreCase = true;\n  }\n  if (flags.includes('m')) {\n    // Onig flag m is equivalent to JS flag s\n    obj.dotAll = true;\n  }\n  if (flags.includes('x')) {\n    obj.extended = true;\n  }\n  return Object.keys(obj).length ? obj : null;\n}\n\nfunction getFlagProperties(flags: string): FlagProperties {\n  const flagProperties: FlagProperties = {\n    ignoreCase: false,\n    dotAll: false,\n    extended: false,\n    digitIsAscii: false,\n    posixIsAscii: false,\n    spaceIsAscii: false,\n    wordIsAscii: false,\n    textSegmentMode: null,\n  };\n  for (let i = 0; i < flags.length; i++) {\n    const char = flags[i];\n    if (!'imxDPSWy'.includes(char)) {\n      throw new Error(`Invalid flag \"${char}\"`);\n    }\n    // Flags y{g}, y{w} are currently only supported via the top-level `flags` option\n    if (char === 'y') {\n      if (!/^y{[gw]}/.test(flags.slice(i))) {\n        throw new Error('Invalid or unspecified flag \"y\" mode');\n      }\n      // If text segment mode flags appear multiple times, use the last one\n      flagProperties.textSegmentMode = flags[i + 2] === 'g' ? 'grapheme' : 'word';\n      i += 3;\n      continue;\n    }\n    flagProperties[{\n      i: 'ignoreCase',\n      // Flag m is called `multiline` in Onig, but that has a different meaning in JS. Onig flag m\n      // is equivalent to JS flag s\n      m: 'dotAll',\n      // Flag x is fully handled during tokenization\n      x: 'extended',\n      // Flags D, P, S, W are currently only supported via the top-level `flags` option\n      D: 'digitIsAscii',\n      P: 'posixIsAscii',\n      S: 'spaceIsAscii',\n      W: 'wordIsAscii',\n    }[char] as Exclude<keyof FlagProperties, 'textSegmentMode'>] = true;\n  }\n  return flagProperties;\n}\n\n// - Unenclosed `\\xNN` above 0x7F is handled elsewhere as a UTF-8 encoded byte sequence\n// - Enclosed `\\x{}` with value above 0x10FFFF is allowed here; handled in the parser\nfunction getValidatedHexCharCode(raw: string): number {\n  // Note: Onig 6.9.10 and earlier have a bug where pattern-terminating `\\u` and `\\x` are treated\n  // as identity escapes; see <github.com/kkos/oniguruma/issues/343>. Don't emulate these bugs.\n  // Additionally, Onig treats bare `\\x` as equivalent to `\\0`, and treats incomplete `\\x{` (with\n  // the brace but not immediately followed by a hex digit) as an identity escape, so e.g. `\\x{`\n  // matches `x{` and `^\\x{,2}$` matches `xx`, but `\\x{2,}` and `\\x{0,2}` are errors. Currently,\n  // this library treats all such cases as errors\n  if (/^(?:\\\\u(?!\\p{AHex}{4})|\\\\x(?!\\p{AHex}{1,2}|\\{\\p{AHex}{1,8}\\}))/u.test(raw)) {\n    throw new Error(`Incomplete or invalid escape \"${raw}\"`);\n  }\n  // Might include leading 0s\n  const hex = raw[2] === '{' ?\n    /^\\\\x\\{\\s*(?<hex>\\p{AHex}+)/u.exec(raw)!.groups!.hex :\n    raw.slice(2);\n  return parseInt(hex, 16);\n}\n\n// Value is 1-3 digits, which can be a backref (possibly invalid), null, octal, or identity escape,\n// possibly followed by 1-2 literal digits\nfunction splitEscapedNumberToken(token: EscapedNumberToken, numCaptures: number): Array<BackreferenceToken> | Array<CharacterToken> {\n  const {raw, inCharClass} = token;\n  // Keep any leading 0s since they indicate octal\n  const value = raw.slice(1);\n  // Backref (possibly invalid)\n  if (\n    !inCharClass &&\n    ( // Single digit 1-9 outside a char class is always treated as a backref\n      (value !== '0' && value.length === 1) ||\n      // Leading 0 makes it octal; backrefs can't include following literal digits\n      (value[0] !== '0' && +value <= numCaptures)\n    )\n  ) {\n    return [createBackreferenceToken(raw)];\n  }\n  const tokens: Array<CharacterToken> = [];\n  // Returns 1-3 matches; the first (only) might be octal\n  const matches = value.match(/^[0-7]+|\\d/g)!;\n  for (let i = 0; i < matches.length; i++) {\n    const m = matches[i];\n    let value: number;\n    // Octal digits are 0-7\n    if (i === 0 && m !== '8' && m !== '9') {\n      value = parseInt(m, 8);\n      if (value > 0o177) {\n        // Octal UTF-8 encoded byte sequence; not yet supported\n        throw new Error(r`Octal encoded byte above 177 unsupported \"${raw}\"`);\n      }\n    } else {\n      value = cpOf(m);\n    }\n    tokens.push(createCharacterToken(value, (i === 0 ? '\\\\' : '') + m));\n  }\n  return tokens;\n}\n\nfunction splitQuantifierMatch(str: string): Array<QuantifierToken> {\n  const tokens: Array<QuantifierToken> = [];\n  // `str` is one or more quantifiers in a chain. It can't be split by a regex because of one edge\n  // case where we have to compare numeric values: although `{1,2}?` is a single, lazy quantifier,\n  // a reversed (possessive) interval quantifier like `{2,1}` can't be both possessive and lazy, so\n  // any following `?`, `??`, or `?+` is a second, chained quantifier (i.e., `{2,1}?` is equivalent\n  // to `{2,1}{0,1}` or `{2,0}`)\n  const withG = new RegExp(quantifierRe, 'gy');\n  let match: RegExpExecArray | null;\n  while ((match = withG.exec(str))) {\n    const m = match[0];\n    if (m[0] === '{') {\n      // Doesn't need to handle fixed `{n}`, infinite max `{n,}`, or implicit zero min `{,n}`\n      // since, according to Onig syntax rules, those can't be possessive\n      const parts = /^\\{(?<min>\\d+),(?<max>\\d+)\\}\\??$/.exec(m);\n      if (parts) {\n        const {min, max} = parts.groups as {min: string, max: string};\n        if (+min > +max && m.endsWith('?')) {\n          // Leave the trailing `?` for the next match\n          withG.lastIndex--;\n          tokens.push(tokenizeQuantifier(m.slice(0, -1)));\n          continue;\n        }\n      }\n    }\n    tokens.push(tokenizeQuantifier(m));\n  }\n  return tokens;\n}\n\nexport {\n  type AlternatorToken,\n  type AssertionToken,\n  type BackreferenceToken,\n  type CharacterToken,\n  type CharacterClassCloseToken,\n  type CharacterClassHyphenToken,\n  type CharacterClassIntersectorToken,\n  type CharacterClassOpenToken,\n  type CharacterSetToken,\n  type DirectiveToken,\n  type FlagGroupModifiers,\n  type FlagProperties,\n  type GroupCloseToken,\n  type GroupOpenToken,\n  type NamedCalloutToken,\n  type QuantifierToken,\n  type SubroutineToken,\n  type Token,\n  type TokenCharacterSetKind,\n  type TokenDirectiveKind,\n  type TokenNamedCalloutKind,\n  type TokenQuantifierKind,\n  tokenize,\n};\n", "import type {AlternativeContainerNode, Node, ParentNode, QuantifiableNode} from './parse.js';\n\ntype KeysOfUnion<T> = T extends T ? keyof T: never;\ntype Props = {[key in KeysOfUnion<Node>]?: any} & {type?: Node['type']};\n\nfunction hasOnlyChild(node: ParentNode & {body: Array<Node>}, props?: Props): boolean {\n  if (!Array.isArray(node.body)) {\n    throw new Error('Expected node with body array');\n  }\n  if (node.body.length !== 1) {\n    return false;\n  }\n  const kid = node.body[0] as Props;\n  return !props || Object.keys(props).every(key => props[key as keyof Props] === kid[key as keyof Props]);\n}\n\nfunction isAlternativeContainer(node: Node): node is AlternativeContainerNode {\n  if (\n    !alternativeContainerTypes.has(node.type) ||\n    (node.type === 'AbsenceFunction' && node.kind !== 'repeater')\n  ) {\n    return false;\n  }\n  return true;\n}\nconst alternativeContainerTypes = new Set<Node['type']>([\n  'AbsenceFunction',\n  'CapturingGroup',\n  'Group',\n  'LookaroundAssertion',\n  'Regex',\n]);\n\nfunction isQuantifiable(node: Node): node is QuantifiableNode {\n  return quantifiableTypes.has(node.type);\n}\nconst quantifiableTypes = new Set<Node['type']>([\n  'AbsenceFunction',\n  'Backreference',\n  'CapturingGroup',\n  'Character',\n  'CharacterClass',\n  'CharacterSet',\n  'Group',\n  'Quantifier',\n  'Subroutine',\n]);\n\nexport {\n  hasOnlyChild,\n  isAlternativeContainer,\n  isQuantifiable,\n};\n", "import type {AssertionToken, BackreferenceToken, CharacterClassHyphenToken, CharacterClassOpenToken, CharacterSetToken, FlagGroupModifiers, FlagProperties, GroupOpenToken, QuantifierToken, SubroutineToken, Token, TokenCharacterSetKind, TokenDirectiveKind, TokenNamedCalloutKind, TokenQuantifierKind} from '../tokenizer/tokenize.js';\nimport {tokenize} from '../tokenizer/tokenize.js';\nimport {cpOf, getOrInsert, PosixClassNames, r, throwIfNullish} from '../utils.js';\nimport {hasOnlyChild, isAlternativeContainer, isQuantifiable} from './node-utils.js';\n\n// Watch out for the DOM `Node` interface!\ntype Node =\n  AbsenceFunctionNode |\n  AlternativeNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode |\n  DirectiveNode |\n  FlagsNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  NamedCalloutNode |\n  QuantifierNode |\n  RegexNode |\n  SubroutineNode;\n\ntype OnigurumaAst = RegexNode;\n\ntype ParentNode =\n  AlternativeContainerNode |\n  AlternativeNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  QuantifierNode;\n\n// See also `isAlternativeContainer`\ntype AlternativeContainerNode =\n  AbsenceFunctionNode | // Some sub-kinds aren't alternative containers\n  CapturingGroupNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  RegexNode;\n\ntype AlternativeElementNode =\n  AbsenceFunctionNode |\n  AssertionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  DirectiveNode |\n  GroupNode |\n  LookaroundAssertionNode |\n  NamedCalloutNode |\n  QuantifierNode |\n  SubroutineNode;\n\ntype CharacterClassElementNode =\n  CharacterNode |\n  CharacterClassNode |\n  CharacterClassRangeNode |\n  CharacterSetNode;\n\n// See also `isQuantifiable`\ntype QuantifiableNode =\n  AbsenceFunctionNode |\n  BackreferenceNode |\n  CapturingGroupNode |\n  CharacterNode |\n  CharacterClassNode |\n  CharacterSetNode |\n  GroupNode |\n  QuantifierNode |\n  SubroutineNode;\n\n// TODO: Support remaining kinds; see <github.com/slevithan/oniguruma-to-es/issues/13>\ntype NodeAbsenceFunctionKind =\n  'repeater';\n\ntype NodeAssertionKind =\n  'line_end' |\n  'line_start' |\n  'search_start' |\n  'string_end' |\n  'string_end_newline' |\n  'string_start' |\n  'text_segment_boundary' |\n  'word_boundary';\n\ntype NodeCharacterClassKind =\n  'union' |\n  'intersection';\n\ntype NodeCharacterSetKind = TokenCharacterSetKind;\n\ntype NodeDirectiveKind = TokenDirectiveKind;\n\ntype NodeLookaroundAssertionKind =\n  'lookahead' |\n  'lookbehind';\n\ntype NodeNamedCalloutKind = TokenNamedCalloutKind;\n\ntype NodeQuantifierKind = TokenQuantifierKind;\n\ntype UnicodePropertyMap = Map<string, string>;\n\ntype Context = {\n  capturingGroups: Array<CapturingGroupNode>;\n  hasNumberedRef: boolean;\n  namedGroupsByName: Map<string, Array<CapturingGroupNode>>;\n  nextIndex: number;\n  normalizeUnknownPropertyNames: boolean;\n  parent: ParentNode;\n  skipBackrefValidation: boolean;\n  skipLookbehindValidation: boolean;\n  skipPropertyNameValidation: boolean;\n  subroutines: Array<SubroutineNode>;\n  tokens: Array<Token>;\n  unicodePropertyMap: UnicodePropertyMap | null;\n  walk: (parent: ParentNode, state: State) => Node;\n};\n\n// Top-level `walk` calls are given empty state; nested calls can add data specific to their `walk`\ntype State = {\n  isCheckingRangeEnd?: boolean;\n  isInAbsenceFunction?: boolean;\n  isInLookbehind?: boolean;\n  isInNegLookbehind?: boolean;\n};\n\ntype ParseOptions = {\n  flags?: string;\n  normalizeUnknownPropertyNames?: boolean;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n  skipBackrefValidation?: boolean;\n  skipLookbehindValidation?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: UnicodePropertyMap | null;\n};\n\nfunction parse(pattern: string, options: ParseOptions = {}): OnigurumaAst {\n  const opts: Required<ParseOptions> = {\n    flags: '',\n    normalizeUnknownPropertyNames: false,\n    skipBackrefValidation: false,\n    skipLookbehindValidation: false,\n    skipPropertyNameValidation: false,\n    // `toOnigurumaAst` provides `OnigUnicodePropertyMap`, but it can be custom or `null`\n    unicodePropertyMap: null,\n    ...options,\n    rules: {\n      captureGroup: false, // `ONIG_OPTION_CAPTURE_GROUP`\n      singleline: false, // `ONIG_OPTION_SINGLELINE`\n      ...options.rules,\n    },\n  };\n  const tokenized = tokenize(pattern, {\n    // Limit to the tokenizer's options\n    flags: opts.flags,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n  });\n  const walk: Context['walk'] = (parent, state) => {\n    const token = tokenized.tokens[context.nextIndex];\n    context.parent = parent;\n    // Advance for the next iteration\n    context.nextIndex++;\n    switch (token.type) {\n      case 'Alternator':\n        // Top-level only; groups handle their own alternators\n        return createAlternative();\n      case 'Assertion':\n        return parseAssertion(token);\n      case 'Backreference':\n        return parseBackreference(token, context);\n      case 'Character':\n        return createCharacter(token.value, {useLastValid: !!state.isCheckingRangeEnd});\n      case 'CharacterClassHyphen':\n        return parseCharacterClassHyphen(token, context, state);\n      case 'CharacterClassOpen':\n        return parseCharacterClassOpen(token, context, state);\n      case 'CharacterSet':\n        return parseCharacterSet(token, context);\n      case 'Directive':\n        return createDirective(token.kind, {flags: token.flags});\n      case 'GroupOpen':\n        return parseGroupOpen(token, context, state);\n      case 'NamedCallout':\n        return createNamedCallout(token.kind, token.tag, token.arguments);\n      case 'Quantifier':\n        return parseQuantifier(token, context);\n      case 'Subroutine':\n        return parseSubroutine(token, context);\n      default:\n        throw new Error(`Unexpected token type \"${token.type}\"`);\n    }\n  }\n  const context: Context = {\n    capturingGroups: [],\n    hasNumberedRef: false,\n    namedGroupsByName: new Map(),\n    nextIndex: 0,\n    normalizeUnknownPropertyNames: opts.normalizeUnknownPropertyNames,\n    parent: null!, // Assigned by `walk`\n    skipBackrefValidation: opts.skipBackrefValidation,\n    skipLookbehindValidation: opts.skipLookbehindValidation,\n    skipPropertyNameValidation: opts.skipPropertyNameValidation,\n    subroutines: [],\n    tokens: tokenized.tokens,\n    unicodePropertyMap: opts.unicodePropertyMap,\n    walk,\n  };\n\n  // ## AST construction from tokens\n  const ast = createRegex(createFlags(tokenized.flags));\n  let top = ast.body[0]; // First alt\n  while (context.nextIndex < tokenized.tokens.length) {\n    const node = walk(top, {});\n    if (node.type === 'Alternative') {\n      ast.body.push(node);\n      top = node;\n    } else {\n      top.body.push(node as AlternativeElementNode);\n    }\n  }\n\n  // ## Validation that requires knowledge about the complete pattern\n  // `context` updated by the preceding `walk` loop\n  const {capturingGroups, hasNumberedRef, namedGroupsByName, subroutines} = context;\n  if (hasNumberedRef && namedGroupsByName.size && !opts.rules.captureGroup) {\n    throw new Error('Numbered backref/subroutine not allowed when using named capture');\n  }\n  for (const {ref} of subroutines) {\n    if (typeof ref === 'number') {\n      // Relative nums are already resolved\n      if (ref > capturingGroups.length) {\n        throw new Error(`Subroutine uses a group number that's not defined`);\n      }\n      if (ref) {\n        capturingGroups[ref - 1].isSubroutined = true;\n      }\n    } else if (!namedGroupsByName.has(ref)) {\n      throw new Error(r`Subroutine uses a group name that's not defined \"\\g<${ref}>\"`);\n    } else if (namedGroupsByName.get(ref)!.length > 1) {\n      throw new Error(r`Subroutine uses a duplicate group name \"\\g<${ref}>\"`);\n    } else {\n      namedGroupsByName.get(ref)![0].isSubroutined = true;\n    }\n  }\n\n  return ast;\n}\n\nfunction parseAssertion({kind}: AssertionToken): AssertionNode {\n  return createAssertion(\n    throwIfNullish({\n      '^': 'line_start',\n      '$': 'line_end',\n      '\\\\A': 'string_start',\n      '\\\\b': 'word_boundary',\n      '\\\\B': 'word_boundary',\n      '\\\\G': 'search_start',\n      '\\\\y': 'text_segment_boundary',\n      '\\\\Y': 'text_segment_boundary',\n      '\\\\z': 'string_end',\n      '\\\\Z': 'string_end_newline',\n    }[kind], `Unexpected assertion kind \"${kind}\"`) as NodeAssertionKind,\n    {negate: kind === r`\\B` || kind === r`\\Y`}\n  );\n}\n\n// Supported (if the backref appears to the right of the reffed capture's opening paren):\n// - `\\k<name>`, `\\k'name'`\n// - When named capture not used:\n//   - `\\n`, `\\nn`, `\\nnn`\n//   - `\\k<n>`, `\\k'n'\n//   - `\\k<-n>`, `\\k'-n'`\n// Unsupported:\n// - `\\k<+n>`, `\\k'+n'` - Note that, Unlike Oniguruma, Onigmo doesn't support this as special\n//   syntax and therefore considers it a valid group name.\n// - Backref with recursion level (with num or name): `\\k<n+level>`, `\\k<n-level>`, etc.\n//   (Onigmo also supports `\\k<-n+level>`, `\\k<-n-level>`, etc.)\n// Backrefs in Onig use multiplexing for duplicate group names (the rules can be complicated when\n// overlapping with subroutines), but a `Backreference`'s simple `ref` prop doesn't capture these\n// details so multiplexed ref pointers need to be derived when working with the AST\nfunction parseBackreference({raw}: BackreferenceToken, context: Context): BackreferenceNode {\n  const hasKWrapper = /^\\\\k[<']/.test(raw);\n  const ref = hasKWrapper ? raw.slice(3, -1) : raw.slice(1);\n  const fromNum = (num: number, isRelative = false) => {\n    const numCapturesToLeft = context.capturingGroups.length;\n    let orphan = false;\n    // Note: It's not an error for numbered backrefs to come before their referenced group in Onig,\n    // but it's currently an error in this library.\n    // - Most such placements are mistakes and can never match, due to Onig's behavior for backrefs\n    //   to nonparticipating groups.\n    //   - The edge cases where they're matchable rely on rules for backref resetting within\n    //     quantified groups that are different in JS (thus not emulatable in `oniguruma-to-es`).\n    // - Erroring matches the correct behavior of named backrefs.\n    // - For unenclosed backrefs, this only affects `\\1`-`\\9` since it's not a backref in the first\n    //   place if using `\\10` or higher and not as many capturing groups are defined to the left\n    //   (it's an octal or identity escape).\n    // TODO: Ideally this would be refactored to include the backref in the AST when it's not an\n    // error in Onig (due to the reffed group being defined to the right), and the error handling\n    // would move to the `oniguruma-to-es` transformer\n    if (num > numCapturesToLeft) {\n      // Skipping the error breaks assumptions and might create edge case issues, since backrefs\n      // are required to come after their captures; unfortunately this option is needed for\n      // TextMate grammars\n      if (context.skipBackrefValidation) {\n        orphan = true;\n      } else {\n        throw new Error(`Not enough capturing groups defined to the left \"${raw}\"`);\n      }\n    }\n    context.hasNumberedRef = true;\n    return createBackreference(isRelative ? numCapturesToLeft + 1 - num : num, {orphan});\n  };\n  if (hasKWrapper) {\n    const numberedRef = /^(?<sign>-?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n    if (numberedRef) {\n      return fromNum(+numberedRef.groups!.num, !!numberedRef.groups!.sign);\n    }\n    // Invalid in a backref name even when valid in a group name\n    if (/[-+]/.test(ref)) {\n      throw new Error(`Invalid backref name \"${raw}\"`);\n    }\n    if (!context.namedGroupsByName.has(ref)) {\n      throw new Error(`Group name not defined to the left \"${raw}\"`);\n    }\n    return createBackreference(ref);\n  }\n  return fromNum(+ref);\n}\n\nfunction parseCharacterClassHyphen(_: CharacterClassHyphenToken, context: Context, state: State): CharacterNode | CharacterClassRangeNode {\n  const {tokens, walk} = context;\n  const parent = context.parent as CharacterClassNode;\n  const prevSiblingNode = parent.body.at(-1);\n  const nextToken = tokens[context.nextIndex];\n  if (\n    !state.isCheckingRangeEnd &&\n    prevSiblingNode &&\n    prevSiblingNode.type !== 'CharacterClass' &&\n    prevSiblingNode.type !== 'CharacterClassRange' &&\n    nextToken &&\n    nextToken.type !== 'CharacterClassOpen' &&\n    nextToken.type !== 'CharacterClassClose' &&\n    nextToken.type !== 'CharacterClassIntersector'\n  ) {\n    const nextNode = walk(parent, {\n      ...state,\n      isCheckingRangeEnd: true,\n    });\n    if (prevSiblingNode.type === 'Character' && nextNode.type === 'Character') {\n      parent.body.pop();\n      return createCharacterClassRange(prevSiblingNode, nextNode);\n    }\n    throw new Error('Invalid character class range');\n  }\n  return createCharacter(cpOf('-'));\n}\n\nfunction parseCharacterClassOpen({negate}: CharacterClassOpenToken, context: Context, state: State): CharacterClassNode {\n  const {tokens, walk} = context;\n  const firstClassToken = tokens[context.nextIndex];\n  const intersections = [createCharacterClass()];\n  let nextToken = throwIfUnclosedCharacterClass(firstClassToken);\n  while (nextToken.type !== 'CharacterClassClose') {\n    if (nextToken.type === 'CharacterClassIntersector') {\n      intersections.push(createCharacterClass());\n      // Skip the intersector\n      context.nextIndex++;\n    } else {\n      const cc = intersections.at(-1)!; // Always at least one\n      cc.body.push(walk(cc, state) as CharacterClassElementNode);\n    }\n    nextToken = throwIfUnclosedCharacterClass(tokens[context.nextIndex], firstClassToken);\n  }\n  const node = createCharacterClass({negate});\n  if (intersections.length === 1) {\n    node.body = intersections[0].body;\n  } else {\n    node.kind = 'intersection';\n    node.body = intersections.map(cc => cc.body.length === 1 ? cc.body[0] : cc);\n  }\n  // Skip the closing square bracket\n  context.nextIndex++;\n  return node;\n}\n\nfunction parseCharacterSet({kind, negate, value}: CharacterSetToken, context: Context): CharacterSetNode {\n  const {normalizeUnknownPropertyNames, skipPropertyNameValidation, unicodePropertyMap} = context;\n  if (kind === 'property') {\n    const normalized = slug(value!);\n    // Don't treat as POSIX if it's in the provided list of Unicode property names\n    if (PosixClassNames.has(normalized) && !unicodePropertyMap?.has(normalized)) {\n      kind = 'posix';\n      value = normalized;\n    } else {\n      return createUnicodeProperty(value!, {\n        negate,\n        normalizeUnknownPropertyNames,\n        skipPropertyNameValidation,\n        unicodePropertyMap,\n      });\n    }\n  }\n  if (kind === 'posix') {\n    return createPosixClass(value!, {negate});\n  }\n  return createCharacterSet(kind, {negate});\n}\n\nfunction parseGroupOpen(token: GroupOpenToken, context: Context, state: State): AbsenceFunctionNode | CapturingGroupNode | GroupNode | LookaroundAssertionNode {\n  const {tokens, capturingGroups, namedGroupsByName, skipLookbehindValidation, walk} = context;\n  const node = createByGroupKind(token);\n  const isThisAbsenceFunction = node.type === 'AbsenceFunction';\n  const isThisLookbehind = isLookbehind(node);\n  const isThisNegLookbehind = isThisLookbehind && node.negate;\n  // Track capturing group details for backrefs and subroutines (before parsing the group's\n  // contents so nested groups with the same name are tracked in order)\n  if (node.type === 'CapturingGroup') {\n    capturingGroups.push(node);\n    if (node.name) {\n      getOrInsert(namedGroupsByName, node.name, []).push(node);\n    }\n  }\n  // Don't allow nested absence functions\n  if (isThisAbsenceFunction && state.isInAbsenceFunction) {\n    // Is officially unsupported in Onig but doesn't throw, gives strange results\n    throw new Error('Nested absence function not supported by Oniguruma');\n  }\n  let nextToken = throwIfUnclosedGroup(tokens[context.nextIndex]);\n  while (nextToken.type !== 'GroupClose') {\n    if (nextToken.type === 'Alternator') {\n      node.body.push(createAlternative());\n      // Skip the alternator\n      context.nextIndex++;\n    } else {\n      const alt = node.body.at(-1)!; // Always at least one\n      const child = walk(alt, {\n        ...state,\n        isInAbsenceFunction: state.isInAbsenceFunction || isThisAbsenceFunction,\n        isInLookbehind: state.isInLookbehind || isThisLookbehind,\n        isInNegLookbehind: state.isInNegLookbehind || isThisNegLookbehind,\n      }) as AlternativeElementNode;\n      alt.body.push(child);\n      // Centralized validation of lookbehind contents\n      if ((isThisLookbehind || state.isInLookbehind) && !skipLookbehindValidation) {\n        // JS supports all features within lookbehind, but Onig doesn't. Absence functions of form\n        // `(?~|)` and `(?~|\u2026)` are also invalid in lookbehind (the `(?~\u2026)` and `(?~|\u2026|\u2026)` forms\n        // are allowed), but all forms with `(?~|` throw since they aren't yet supported\n        const msg = 'Lookbehind includes a pattern not allowed by Oniguruma';\n        if (isThisNegLookbehind || state.isInNegLookbehind) {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, capturing groups\n          // - Valid: `(?<=\u2026)`, `(?<!\u2026)`\n          if (isLookahead(child) || child.type === 'CapturingGroup') {\n            throw new Error(msg);\n          }\n        } else {\n          // - Invalid: `(?=\u2026)`, `(?!\u2026)`, `(?<!\u2026)`\n          // - Valid: `(?<=\u2026)`, capturing groups\n          if (isLookahead(child) || (isLookbehind(child) && child.negate)) {\n            throw new Error(msg);\n          }\n        }\n      }\n    }\n    nextToken = throwIfUnclosedGroup(tokens[context.nextIndex]);\n  }\n  // Skip the closing parenthesis\n  context.nextIndex++;\n  return node;\n}\n\nfunction parseQuantifier({kind, min, max}: QuantifierToken, context: Context): QuantifierNode {\n  const parent = context.parent as AlternativeNode;\n  const quantifiedNode = parent.body.at(-1);\n  if (!quantifiedNode || !isQuantifiable(quantifiedNode)) {\n    throw new Error('Quantifier requires a repeatable token');\n  }\n  const node = createQuantifier(kind, min, max, quantifiedNode);\n  parent.body.pop();\n  return node;\n}\n\n// Onig subroutine behavior:\n// - Subroutines can appear before the groups they reference; ex: `\\g<1>(a)` is valid.\n// - Multiple subroutines can reference the same group.\n// - Subroutines can reference groups that themselves contain subroutines, followed to any depth.\n// - Subroutines can be used recursively, and `\\g<0>` recursively references the whole pattern.\n// - Subroutines can use relative references (backward or forward); ex: `\\g<+1>(.)\\g<-1>`.\n// - Subroutines don't get their own capturing group numbers; ex: `(.)\\g<1>\\2` is invalid.\n// - Subroutines use the flags that apply to their referenced group, so e.g.\n//   `(?-i)(?<a>a)(?i)\\g<a>` is fully case sensitive.\n// - Differences from PCRE/Perl/Regex+ subroutines:\n//   - Subroutines can't reference duplicate group names (though duplicate names are valid if no\n//     subroutines reference them).\n//   - Subroutines can't use absolute or relative numbers if named capture is used anywhere.\n//   - Named backrefs must be to the right of their group definition, so the backref in\n//     `\\g<a>\\k<a>(?<a>)` is invalid (not directly related to subroutines).\n//   - Subroutines don't restore capturing group match values (for backrefs) upon exit, so e.g.\n//     `(?<a>(?<b>[ab]))\\g<a>\\k<b>` matches `abb` but not `aba`; same for numbered.\n// The interaction of backref multiplexing (an Onig-specific feature) and subroutines is complex:\n// - Only the most recent value matched by a capturing group and its subroutines is considered for\n//   backref multiplexing, and this also applies to capturing groups nested within a group that's\n//   referenced by a subroutine.\n// - Although a subroutine can't reference a group with a duplicate name, it can reference a group\n//   with a nested capture whose name is duplicated (e.g. outside of the referenced group).\n//   - These duplicate names can then multiplex; but only the most recent value matched from within\n//     the outer group (or the subroutines that reference it) is available for multiplexing.\n//   - Ex: With `(?<a>(?<b>[123]))\\g<a>\\g<a>(?<b>0)\\k<b>`, the backref `\\k<b>` can only match `0`\n//     or whatever was matched by the most recently matched subroutine. If you took out `(?<b>0)`,\n//     no multiplexing would occur.\nfunction parseSubroutine({raw}: SubroutineToken, context: Context): SubroutineNode {\n  const {capturingGroups, subroutines} = context;\n  let ref: string | number = raw.slice(3, -1);\n  const numberedRef = /^(?<sign>[-+]?)0*(?<num>[1-9]\\d*)$/.exec(ref);\n  if (numberedRef) {\n    const num = +numberedRef.groups!.num;\n    const numCapturesToLeft = capturingGroups.length;\n    context.hasNumberedRef = true;\n    ref = {\n      '': num,\n      '+': numCapturesToLeft + num,\n      '-': numCapturesToLeft + 1 - num,\n    }[numberedRef.groups!.sign]!;\n    if (ref < 1) {\n      throw new Error('Invalid subroutine number');\n    }\n  // Special case for full-pattern recursion; can't be `+0`, `-0`, `00`, etc.\n  } else if (ref === '0') {\n    ref = 0;\n  }\n  const node = createSubroutine(ref);\n  subroutines.push(node);\n  return node;\n}\n\n// -------------------------------\n// --- Node creation and types ---\n// -------------------------------\n\ntype AbsenceFunctionNode = {\n  type: 'AbsenceFunction';\n  kind: NodeAbsenceFunctionKind;\n  body: Array<AlternativeNode>;\n};\nfunction createAbsenceFunction(kind: NodeAbsenceFunctionKind, options?: {\n  body?: Array<AlternativeNode>;\n}): AbsenceFunctionNode {\n  if (kind !== 'repeater') {\n    throw new Error(`Unexpected absence function kind \"${kind}\"`);\n  }\n  return {\n    type: 'AbsenceFunction',\n    kind,\n    body: getBodyForAlternativeContainer(options?.body),\n  };\n}\n\ntype AlternativeNode = {\n  type: 'Alternative';\n  body: Array<AlternativeElementNode>;\n};\nfunction createAlternative(options?: {\n  body?: Array<AlternativeElementNode>;\n}): AlternativeNode {\n  return {\n    type: 'Alternative',\n    body: getBodyForElementContainer(options?.body) as Array<AlternativeElementNode>,\n  };\n}\n\ntype AssertionNode = {\n  type: 'Assertion';\n  kind: NodeAssertionKind;\n  negate?: boolean;\n};\nfunction createAssertion(kind: NodeAssertionKind, options?: {\n  negate?: boolean;\n}): AssertionNode {\n  const node: AssertionNode = {\n    type: 'Assertion',\n    kind,\n  };\n  if (kind === 'word_boundary' || kind === 'text_segment_boundary') {\n    node.negate = !!options?.negate;\n  }\n  return node;\n}\n\ntype BackreferenceNode = {\n  type: 'Backreference';\n  ref: string | number;\n  orphan?: boolean;\n};\nfunction createBackreference(ref: string | number, options?: {\n  orphan?: boolean;\n}): BackreferenceNode {\n  const orphan = !!options?.orphan;\n  return {\n    type: 'Backreference',\n    ref,\n    ...(orphan && {orphan}),\n  };\n}\n\ntype CapturingGroupNode = {\n  type: 'CapturingGroup';\n  kind?: never;\n  number: number;\n  name?: string;\n  // One or more subroutines in the regex reference this group\n  isSubroutined?: boolean;\n  body: Array<AlternativeNode>;\n};\nfunction createCapturingGroup(number: number, options?: {\n  name?: string;\n  isSubroutined?: boolean;\n  body?: Array<AlternativeNode>;\n}): CapturingGroupNode {\n  const opts = {\n    name: undefined,\n    isSubroutined: false,\n    ...options,\n  };\n  if (opts.name !== undefined && !isValidGroupName(opts.name)) {\n    throw new Error(`Group name \"${opts.name}\" invalid in Oniguruma`);\n  }\n  return {\n    type: 'CapturingGroup',\n    number,\n    ...(opts.name && {name: opts.name}),\n    ...(opts.isSubroutined && {isSubroutined: opts.isSubroutined}),\n    body: getBodyForAlternativeContainer(options?.body),\n  };\n}\n\ntype CharacterNode = {\n  type: 'Character';\n  value: number;\n};\nfunction createCharacter(charCode: number, options?: {\n  useLastValid?: boolean;\n}): CharacterNode {\n  const opts = {\n    useLastValid: false,\n    ...options,\n  };\n  if (charCode > 0x10FFFF) {\n    const hex = charCode.toString(16);\n    if (opts.useLastValid) {\n      charCode = 0x10FFFF;\n    } else if (charCode > 0x13FFFF) {\n      throw new Error(`Invalid code point out of range \"\\\\x{${hex}}\"`);\n    } else {\n      throw new Error(`Invalid code point out of range in JS \"\\\\x{${hex}}\"`);\n    }\n  }\n  return {\n    type: 'Character',\n    value: charCode,\n  };\n}\n\ntype CharacterClassNode = {\n  type: 'CharacterClass';\n  kind: NodeCharacterClassKind;\n  negate: boolean;\n  body: Array<CharacterClassElementNode>;\n};\nfunction createCharacterClass(options?: {\n  kind?: NodeCharacterClassKind;\n  negate?: boolean;\n  body?: Array<CharacterClassElementNode>;\n}): CharacterClassNode {\n  const opts = {\n    kind: 'union' as NodeCharacterClassKind,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: 'CharacterClass',\n    kind: opts.kind,\n    negate: opts.negate,\n    body: getBodyForElementContainer(options?.body) as Array<CharacterClassElementNode>,\n  };\n}\n\ntype CharacterClassRangeNode = {\n  type: 'CharacterClassRange';\n  min: CharacterNode;\n  max: CharacterNode;\n};\nfunction createCharacterClassRange(min: CharacterNode, max: CharacterNode): CharacterClassRangeNode {\n  if (max.value < min.value) {\n    throw new Error('Character class range out of order');\n  }\n  return {\n    type: 'CharacterClassRange',\n    min,\n    max,\n  };\n}\n\ntype NamedCharacterSetNode = {\n  type: 'CharacterSet';\n  kind: 'posix' | 'property';\n  value: string;\n  negate: boolean;\n  variableLength?: never;\n};\ntype UnnamedCharacterSetNode = {\n  type: 'CharacterSet';\n  kind: Exclude<NodeCharacterSetKind, NamedCharacterSetNode['kind']>;\n  value?: never;\n  negate?: boolean;\n  variableLength?: boolean;\n};\ntype CharacterSetNode = NamedCharacterSetNode | UnnamedCharacterSetNode;\n/**\nUse `createUnicodeProperty` and `createPosixClass` for `kind` values `'property'` and `'posix'`.\n*/\nfunction createCharacterSet(kind: UnnamedCharacterSetNode['kind'], options?: {\n  negate?: boolean;\n}): UnnamedCharacterSetNode {\n  const negate = !!options?.negate;\n  const node: UnnamedCharacterSetNode = {\n    type: 'CharacterSet',\n    kind,\n  };\n  if (\n    kind === 'digit' ||\n    kind === 'hex' ||\n    kind === 'newline' ||\n    kind === 'space' ||\n    kind === 'word'\n  ) {\n    node.negate = negate;\n  }\n  if (\n    kind === 'text_segment' ||\n    (kind === 'newline' && !negate)\n  ) {\n    node.variableLength = true;\n  }\n  return node;\n}\n\ntype DirectiveNode = {\n  type: 'Directive';\n} & ({\n  kind: 'keep';\n  flags?: never;\n} | {\n  kind: 'flags';\n  flags: FlagGroupModifiers;\n});\nfunction createDirective(kind: NodeDirectiveKind, options: {flags?: FlagGroupModifiers} = {}): DirectiveNode {\n  if (kind === 'keep') {\n    return {\n      type: 'Directive',\n      kind,\n    };\n  }\n  if (kind === 'flags') {\n    // Note: Flag effects might extend across alternation; ex: `a(?i)b|c` is equivalent to\n    // `a(?i:b)|(?i:c)`, not `a(?i:b|c)`\n    return {\n      type: 'Directive',\n      kind,\n      flags: throwIfNullish(options.flags),\n    };\n  }\n  throw new Error(`Unexpected directive kind \"${kind}\"`);\n}\n\ntype FlagsNode = {\n  type: 'Flags';\n} & FlagProperties;\nfunction createFlags(flags: FlagProperties): FlagsNode {\n  return {\n    type: 'Flags',\n    ...flags,\n  };\n}\n\ntype GroupNode = {\n  type: 'Group';\n  kind?: never;\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n  body: Array<AlternativeNode>;\n};\nfunction createGroup(options?: {\n  atomic?: boolean;\n  flags?: FlagGroupModifiers;\n  body?: Array<AlternativeNode>;\n}): GroupNode {\n  const atomic = options?.atomic;\n  const flags = options?.flags;\n  if (atomic && flags) {\n    throw new Error('Atomic group cannot have flags');\n  }\n  return {\n    type: 'Group',\n    ...(atomic && {atomic}),\n    ...(flags && {flags}),\n    body: getBodyForAlternativeContainer(options?.body),\n  };\n}\n\ntype LookaroundAssertionNode = {\n  type: 'LookaroundAssertion';\n  kind: NodeLookaroundAssertionKind;\n  negate: boolean;\n  body: Array<AlternativeNode>;\n};\nfunction createLookaroundAssertion(options?: {\n  behind?: boolean;\n  negate?: boolean;\n  body?: Array<AlternativeNode>;\n}): LookaroundAssertionNode {\n  const opts = {\n    behind: false,\n    negate: false,\n    ...options,\n  };\n  return {\n    type: 'LookaroundAssertion',\n    kind: opts.behind ? 'lookbehind' : 'lookahead',\n    negate: opts.negate,\n    body: getBodyForAlternativeContainer(options?.body),\n  };\n}\n\ntype NamedCalloutNode = {\n  type: 'NamedCallout';\n  kind: NodeNamedCalloutKind;\n  tag: string | null;\n  arguments: Array<string | number> | null;\n};\nfunction createNamedCallout(\n  kind: NodeNamedCalloutKind,\n  tag: string | null,\n  args: Array<string | number> | null\n): NamedCalloutNode {\n  return {\n    type: 'NamedCallout',\n    kind,\n    tag,\n    arguments: args,\n  };\n}\n\nfunction createPosixClass(name: string, options?: {\n  negate?: boolean;\n}): NamedCharacterSetNode & {kind: 'posix'} {\n  const negate = !!options?.negate;\n  if (!PosixClassNames.has(name)) {\n    throw new Error(`Invalid POSIX class \"${name}\"`);\n  }\n  return {\n    type: 'CharacterSet',\n    kind: 'posix',\n    value: name,\n    negate,\n  };\n}\n\ntype QuantifierNode = {\n  type: 'Quantifier';\n  kind: NodeQuantifierKind;\n  min: number;\n  max: number;\n  body: QuantifiableNode;\n};\nfunction createQuantifier(kind: NodeQuantifierKind, min: number, max: number, body: QuantifiableNode): QuantifierNode {\n  if (min > max) {\n    throw new Error('Invalid reversed quantifier range');\n  }\n  return {\n    type: 'Quantifier',\n    kind,\n    min,\n    max,\n    body,\n  };\n}\n\ntype RegexNode = {\n  type: 'Regex';\n  body: Array<AlternativeNode>;\n  flags: FlagsNode;\n};\nfunction createRegex(flags: FlagsNode, options?: {\n  body?: Array<AlternativeNode>;\n}): RegexNode {\n  return {\n    type: 'Regex',\n    body: getBodyForAlternativeContainer(options?.body),\n    flags,\n  };\n}\n\ntype SubroutineNode = {\n  type: 'Subroutine';\n  ref: string | number;\n};\nfunction createSubroutine(ref: string | number): SubroutineNode {\n  return {\n    type: 'Subroutine',\n    ref,\n  };\n}\n\ntype CreateUnicodePropertyOptions = {\n  negate?: boolean;\n  normalizeUnknownPropertyNames?: boolean;\n  skipPropertyNameValidation?: boolean;\n  unicodePropertyMap?: UnicodePropertyMap | null;\n};\nfunction createUnicodeProperty(name: string, options?: CreateUnicodePropertyOptions): NamedCharacterSetNode & {kind: 'property'} {\n  const opts: Required<CreateUnicodePropertyOptions> = {\n    negate: false,\n    normalizeUnknownPropertyNames: false,\n    skipPropertyNameValidation: false,\n    unicodePropertyMap: null,\n    ...options,\n  };\n  let normalized = opts.unicodePropertyMap?.get(slug(name));\n  if (!normalized) {\n    if (opts.normalizeUnknownPropertyNames) {\n      normalized = normalizeUnicodePropertyName(name);\n    // Let the name through as-is if no map provided and normalization not requested\n    } else if (opts.unicodePropertyMap && !opts.skipPropertyNameValidation) {\n      throw new Error(r`Invalid Unicode property \"\\p{${name}}\"`);\n    }\n  }\n  return {\n    type: 'CharacterSet',\n    kind: 'property',\n    value: normalized ?? name,\n    negate: opts.negate,\n  };\n}\n\n// ---------------\n// --- Helpers ---\n// ---------------\n\nfunction createByGroupKind({flags, kind, name, negate, number}: GroupOpenToken): AbsenceFunctionNode | CapturingGroupNode | GroupNode | LookaroundAssertionNode {\n  switch (kind) {\n    case 'absence_repeater':\n      return createAbsenceFunction('repeater');\n    case 'atomic':\n      return createGroup({atomic: true});\n    case 'capturing':\n      return createCapturingGroup(number!, {name});\n    case 'group':\n      return createGroup({flags});\n    case 'lookahead':\n    case 'lookbehind':\n      return createLookaroundAssertion({\n        behind: kind === 'lookbehind',\n        negate,\n      });\n    default:\n      throw new Error(`Unexpected group kind \"${kind}\"`);\n  }\n}\n\nfunction getBodyForAlternativeContainer(body: unknown): Array<AlternativeNode> {\n  if (body === undefined) {\n    body = [createAlternative()];\n  } else if (!Array.isArray(body) || !body.length || !body.every(node => (node as Node).type === 'Alternative')) {\n    throw new Error('Invalid body; expected array of one or more Alternative nodes');\n  }\n  return body as Array<AlternativeNode>;\n}\n\nfunction getBodyForElementContainer(body: unknown): Array<Node> {\n  if (body === undefined) {\n    body = [];\n  } else if (!Array.isArray(body) || !body.every(node => !!(node as Node).type)) {\n    throw new Error('Invalid body; expected array of nodes');\n  }\n  return body as Array<Node>;\n}\n\nfunction isLookahead(node: Node): node is (LookaroundAssertionNode & {kind: 'lookahead'}) {\n  return node.type === 'LookaroundAssertion' && node.kind === 'lookahead';\n}\n\nfunction isLookbehind(node: Node): node is (LookaroundAssertionNode & {kind: 'lookbehind'}) {\n  return node.type === 'LookaroundAssertion' && node.kind === 'lookbehind';\n}\n\nfunction isValidGroupName(name: string): boolean {\n  // Note that backrefs and subroutines might contextually use `-` and `+` to indicate relative\n  // index or recursion level\n  return /^[\\p{Alpha}\\p{Pc}][^)]*$/u.test(name);\n}\n\nfunction normalizeUnicodePropertyName(name: string): string {\n  // In Onig, Unicode property names ignore case, spaces, hyphens, and underscores. Use best effort\n  // to reformat the name to follow official values (covers a lot, but isn't able to map for all\n  // possible formatting differences)\n  return name.\n    trim().\n    replace(/[- _]+/g, '_').\n    replace(/[A-Z][a-z]+(?=[A-Z])/g, '$&_'). // `PropertyName` to `Property_Name`\n    replace(/[A-Za-z]+/g, m => m[0].toUpperCase() + m.slice(1).toLowerCase());\n}\n\n/**\nGenerates a Unicode property lookup name: lowercase, without spaces, hyphens, or underscores.\n*/\nfunction slug(name: string): string {\n  return name.replace(/[- _]+/g, '').toLowerCase();\n}\n\nfunction throwIfUnclosedCharacterClass<T>(token: T, firstClassToken?: Token): NonNullable<T> {\n  return throwIfNullish(\n    token,\n    // Easier to understand the error if it says \"empty\" when the unclosed class starts with\n    // literal `]`; ex: `[]` or `[]a`\n    `${firstClassToken?.type === 'Character' && firstClassToken.value === 93 ?\n      'Empty' : 'Unclosed'} character class`\n  );\n}\n\nfunction throwIfUnclosedGroup<T>(token: T): NonNullable<T> {\n  return throwIfNullish(token, 'Unclosed group');\n}\n\nexport {\n  type AbsenceFunctionNode,\n  type AlternativeNode,\n  type AlternativeContainerNode,\n  type AlternativeElementNode,\n  type AssertionNode,\n  type BackreferenceNode,\n  type CapturingGroupNode,\n  type CharacterClassElementNode,\n  type CharacterClassNode,\n  type CharacterClassRangeNode,\n  type CharacterNode,\n  type CharacterSetNode,\n  type DirectiveNode,\n  type FlagsNode,\n  type GroupNode,\n  type LookaroundAssertionNode,\n  type NamedCalloutNode,\n  type Node,\n  type NodeAbsenceFunctionKind,\n  type NodeAssertionKind,\n  type NodeCharacterClassKind,\n  type NodeCharacterSetKind,\n  type NodeDirectiveKind,\n  type NodeLookaroundAssertionKind,\n  type NodeQuantifierKind,\n  type OnigurumaAst,\n  type ParentNode,\n  type ParseOptions,\n  type QuantifiableNode,\n  type QuantifierNode,\n  type RegexNode,\n  type SubroutineNode,\n  type UnicodePropertyMap,\n  createAbsenceFunction,\n  createAlternative,\n  createAssertion,\n  createBackreference,\n  createCapturingGroup,\n  createCharacter,\n  createCharacterClass,\n  createCharacterClassRange,\n  createCharacterSet,\n  createDirective,\n  createFlags,\n  createGroup,\n  createLookaroundAssertion,\n  createNamedCallout,\n  createPosixClass,\n  createQuantifier,\n  createRegex,\n  createSubroutine,\n  createUnicodeProperty,\n  hasOnlyChild,\n  isAlternativeContainer,\n  isQuantifiable,\n  parse,\n  slug,\n};\n", "import type {UnicodePropertyMap} from \"./parser/parse.js\";\nimport {slug} from \"./parser/parse.js\";\n\n/**\nAll Unicode properties supported by Oniguruma 6.9.10 (Unicode 16.0.0).\nCopied from <github.com/kkos/oniguruma/blob/master/doc/UNICODE_PROPERTIES>\n*/\nconst OnigUnicodePropertyMap: UnicodePropertyMap = /* @__PURE__ */ new Map(\n`ASCII_Hex_Digit\nAdlam\nAhom\nAlphabetic\nAnatolian_Hieroglyphs\nAny\nArabic\nArmenian\nAssigned\nAvestan\nBalinese\nBamum\nBassa_Vah\nBatak\nBengali\nBhaiksuki\nBidi_Control\nBopomofo\nBrahmi\nBraille\nBuginese\nBuhid\nC\nCanadian_Aboriginal\nCarian\nCase_Ignorable\nCased\nCaucasian_Albanian\nCc\nCf\nChakma\nCham\nChanges_When_Casefolded\nChanges_When_Casemapped\nChanges_When_Lowercased\nChanges_When_Titlecased\nChanges_When_Uppercased\nCherokee\nChorasmian\nCn\nCo\nCommon\nCoptic\nCs\nCuneiform\nCypriot\nCypro_Minoan\nCyrillic\nDash\nDefault_Ignorable_Code_Point\nDeprecated\nDeseret\nDevanagari\nDiacritic\nDives_Akuru\nDogra\nDuployan\nEgyptian_Hieroglyphs\nElbasan\nElymaic\nEmoji\nEmoji_Component\nEmoji_Modifier\nEmoji_Modifier_Base\nEmoji_Presentation\nEthiopic\nExtended_Pictographic\nExtender\nGaray\nGeorgian\nGlagolitic\nGothic\nGrantha\nGrapheme_Base\nGrapheme_Extend\nGrapheme_Link\nGreek\nGujarati\nGunjala_Gondi\nGurmukhi\nGurung_Khema\nHan\nHangul\nHanifi_Rohingya\nHanunoo\nHatran\nHebrew\nHex_Digit\nHiragana\nHyphen\nIDS_Binary_Operator\nIDS_Trinary_Operator\nIDS_Unary_Operator\nID_Compat_Math_Continue\nID_Compat_Math_Start\nID_Continue\nID_Start\nIdeographic\nImperial_Aramaic\nInCB\nInherited\nInscriptional_Pahlavi\nInscriptional_Parthian\nJavanese\nJoin_Control\nKaithi\nKannada\nKatakana\nKawi\nKayah_Li\nKharoshthi\nKhitan_Small_Script\nKhmer\nKhojki\nKhudawadi\nKirat_Rai\nL\nLC\nLao\nLatin\nLepcha\nLimbu\nLinear_A\nLinear_B\nLisu\nLl\nLm\nLo\nLogical_Order_Exception\nLowercase\nLt\nLu\nLycian\nLydian\nM\nMahajani\nMakasar\nMalayalam\nMandaic\nManichaean\nMarchen\nMasaram_Gondi\nMath\nMc\nMe\nMedefaidrin\nMeetei_Mayek\nMende_Kikakui\nMeroitic_Cursive\nMeroitic_Hieroglyphs\nMiao\nMn\nModi\nModifier_Combining_Mark\nMongolian\nMro\nMultani\nMyanmar\nN\nNabataean\nNag_Mundari\nNandinagari\nNd\nNew_Tai_Lue\nNewa\nNko\nNl\nNo\nNoncharacter_Code_Point\nNushu\nNyiakeng_Puachue_Hmong\nOgham\nOl_Chiki\nOl_Onal\nOld_Hungarian\nOld_Italic\nOld_North_Arabian\nOld_Permic\nOld_Persian\nOld_Sogdian\nOld_South_Arabian\nOld_Turkic\nOld_Uyghur\nOriya\nOsage\nOsmanya\nOther_Alphabetic\nOther_Default_Ignorable_Code_Point\nOther_Grapheme_Extend\nOther_ID_Continue\nOther_ID_Start\nOther_Lowercase\nOther_Math\nOther_Uppercase\nP\nPahawh_Hmong\nPalmyrene\nPattern_Syntax\nPattern_White_Space\nPau_Cin_Hau\nPc\nPd\nPe\nPf\nPhags_Pa\nPhoenician\nPi\nPo\nPrepended_Concatenation_Mark\nPs\nPsalter_Pahlavi\nQuotation_Mark\nRadical\nRegional_Indicator\nRejang\nRunic\nS\nSamaritan\nSaurashtra\nSc\nSentence_Terminal\nSharada\nShavian\nSiddham\nSignWriting\nSinhala\nSk\nSm\nSo\nSoft_Dotted\nSogdian\nSora_Sompeng\nSoyombo\nSundanese\nSunuwar\nSyloti_Nagri\nSyriac\nTagalog\nTagbanwa\nTai_Le\nTai_Tham\nTai_Viet\nTakri\nTamil\nTangsa\nTangut\nTelugu\nTerminal_Punctuation\nThaana\nThai\nTibetan\nTifinagh\nTirhuta\nTodhri\nToto\nTulu_Tigalari\nUgaritic\nUnified_Ideograph\nUnknown\nUppercase\nVai\nVariation_Selector\nVithkuqi\nWancho\nWarang_Citi\nWhite_Space\nXID_Continue\nXID_Start\nYezidi\nYi\nZ\nZanabazar_Square\nZl\nZp\nZs\nAdlm\nAghb\nAHex\nArab\nArmi\nArmn\nAvst\nBali\nBamu\nBass\nBatk\nBeng\nBhks\nBidi_C\nBopo\nBrah\nBrai\nBugi\nBuhd\nCakm\nCans\nCari\nCased_Letter\nCher\nChrs\nCI\nClose_Punctuation\nCombining_Mark\nConnector_Punctuation\nControl\nCopt\nCpmn\nCprt\nCurrency_Symbol\nCWCF\nCWCM\nCWL\nCWT\nCWU\nCyrl\nDash_Punctuation\nDecimal_Number\nDep\nDeva\nDI\nDia\nDiak\nDogr\nDsrt\nDupl\nEBase\nEComp\nEgyp\nElba\nElym\nEMod\nEnclosing_Mark\nEPres\nEthi\nExt\nExtPict\nFinal_Punctuation\nFormat\nGara\nGeor\nGlag\nGong\nGonm\nGoth\nGran\nGr_Base\nGrek\nGr_Ext\nGr_Link\nGujr\nGukh\nGuru\nHang\nHani\nHano\nHatr\nHebr\nHex\nHira\nHluw\nHmng\nHmnp\nHung\nIDC\nIdeo\nIDS\nIDSB\nIDST\nIDSU\nInitial_Punctuation\nItal\nJava\nJoin_C\nKali\nKana\nKhar\nKhmr\nKhoj\nKits\nKnda\nKrai\nKthi\nLana\nLaoo\nLatn\nLepc\nLetter\nLetter_Number\nLimb\nLina\nLinb\nLine_Separator\nLOE\nLowercase_Letter\nLyci\nLydi\nMahj\nMaka\nMand\nMani\nMarc\nMark\nMath_Symbol\nMCM\nMedf\nMend\nMerc\nMero\nMlym\nModifier_Letter\nModifier_Symbol\nMong\nMroo\nMtei\nMult\nMymr\nNagm\nNand\nNarb\nNbat\nNChar\nNkoo\nNonspacing_Mark\nNshu\nNumber\nOAlpha\nODI\nOgam\nOGr_Ext\nOIDC\nOIDS\nOlck\nOLower\nOMath\nOnao\nOpen_Punctuation\nOrkh\nOrya\nOsge\nOsma\nOther\nOther_Letter\nOther_Number\nOther_Punctuation\nOther_Symbol\nOugr\nOUpper\nPalm\nParagraph_Separator\nPat_Syn\nPat_WS\nPauc\nPCM\nPerm\nPhag\nPhli\nPhlp\nPhnx\nPlrd\nPrivate_Use\nPrti\npunct\nPunctuation\nQaac\nQaai\nQMark\nRI\nRjng\nRohg\nRunr\nSamr\nSarb\nSaur\nSD\nSeparator\nSgnw\nShaw\nShrd\nSidd\nSind\nSinh\nSogd\nSogo\nSora\nSoyo\nSpace_Separator\nSpacing_Mark\nSTerm\nSund\nSunu\nSurrogate\nSylo\nSymbol\nSyrc\nTagb\nTakr\nTale\nTalu\nTaml\nTang\nTavt\nTelu\nTerm\nTfng\nTglg\nThaa\nTibt\nTirh\nTitlecase_Letter\nTnsa\nTodr\nTutg\nUgar\nUIdeo\nUnassigned\nUppercase_Letter\nVaii\nVith\nVS\nWara\nWcho\nWSpace\nXIDC\nXIDS\nXpeo\nXsux\nYezi\nYiii\nZanb\nZinh\nZyyy\nZzzz\nIn_Basic_Latin\nIn_Latin_1_Supplement\nIn_Latin_Extended_A\nIn_Latin_Extended_B\nIn_IPA_Extensions\nIn_Spacing_Modifier_Letters\nIn_Combining_Diacritical_Marks\nIn_Greek_and_Coptic\nIn_Cyrillic\nIn_Cyrillic_Supplement\nIn_Armenian\nIn_Hebrew\nIn_Arabic\nIn_Syriac\nIn_Arabic_Supplement\nIn_Thaana\nIn_NKo\nIn_Samaritan\nIn_Mandaic\nIn_Syriac_Supplement\nIn_Arabic_Extended_B\nIn_Arabic_Extended_A\nIn_Devanagari\nIn_Bengali\nIn_Gurmukhi\nIn_Gujarati\nIn_Oriya\nIn_Tamil\nIn_Telugu\nIn_Kannada\nIn_Malayalam\nIn_Sinhala\nIn_Thai\nIn_Lao\nIn_Tibetan\nIn_Myanmar\nIn_Georgian\nIn_Hangul_Jamo\nIn_Ethiopic\nIn_Ethiopic_Supplement\nIn_Cherokee\nIn_Unified_Canadian_Aboriginal_Syllabics\nIn_Ogham\nIn_Runic\nIn_Tagalog\nIn_Hanunoo\nIn_Buhid\nIn_Tagbanwa\nIn_Khmer\nIn_Mongolian\nIn_Unified_Canadian_Aboriginal_Syllabics_Extended\nIn_Limbu\nIn_Tai_Le\nIn_New_Tai_Lue\nIn_Khmer_Symbols\nIn_Buginese\nIn_Tai_Tham\nIn_Combining_Diacritical_Marks_Extended\nIn_Balinese\nIn_Sundanese\nIn_Batak\nIn_Lepcha\nIn_Ol_Chiki\nIn_Cyrillic_Extended_C\nIn_Georgian_Extended\nIn_Sundanese_Supplement\nIn_Vedic_Extensions\nIn_Phonetic_Extensions\nIn_Phonetic_Extensions_Supplement\nIn_Combining_Diacritical_Marks_Supplement\nIn_Latin_Extended_Additional\nIn_Greek_Extended\nIn_General_Punctuation\nIn_Superscripts_and_Subscripts\nIn_Currency_Symbols\nIn_Combining_Diacritical_Marks_for_Symbols\nIn_Letterlike_Symbols\nIn_Number_Forms\nIn_Arrows\nIn_Mathematical_Operators\nIn_Miscellaneous_Technical\nIn_Control_Pictures\nIn_Optical_Character_Recognition\nIn_Enclosed_Alphanumerics\nIn_Box_Drawing\nIn_Block_Elements\nIn_Geometric_Shapes\nIn_Miscellaneous_Symbols\nIn_Dingbats\nIn_Miscellaneous_Mathematical_Symbols_A\nIn_Supplemental_Arrows_A\nIn_Braille_Patterns\nIn_Supplemental_Arrows_B\nIn_Miscellaneous_Mathematical_Symbols_B\nIn_Supplemental_Mathematical_Operators\nIn_Miscellaneous_Symbols_and_Arrows\nIn_Glagolitic\nIn_Latin_Extended_C\nIn_Coptic\nIn_Georgian_Supplement\nIn_Tifinagh\nIn_Ethiopic_Extended\nIn_Cyrillic_Extended_A\nIn_Supplemental_Punctuation\nIn_CJK_Radicals_Supplement\nIn_Kangxi_Radicals\nIn_Ideographic_Description_Characters\nIn_CJK_Symbols_and_Punctuation\nIn_Hiragana\nIn_Katakana\nIn_Bopomofo\nIn_Hangul_Compatibility_Jamo\nIn_Kanbun\nIn_Bopomofo_Extended\nIn_CJK_Strokes\nIn_Katakana_Phonetic_Extensions\nIn_Enclosed_CJK_Letters_and_Months\nIn_CJK_Compatibility\nIn_CJK_Unified_Ideographs_Extension_A\nIn_Yijing_Hexagram_Symbols\nIn_CJK_Unified_Ideographs\nIn_Yi_Syllables\nIn_Yi_Radicals\nIn_Lisu\nIn_Vai\nIn_Cyrillic_Extended_B\nIn_Bamum\nIn_Modifier_Tone_Letters\nIn_Latin_Extended_D\nIn_Syloti_Nagri\nIn_Common_Indic_Number_Forms\nIn_Phags_pa\nIn_Saurashtra\nIn_Devanagari_Extended\nIn_Kayah_Li\nIn_Rejang\nIn_Hangul_Jamo_Extended_A\nIn_Javanese\nIn_Myanmar_Extended_B\nIn_Cham\nIn_Myanmar_Extended_A\nIn_Tai_Viet\nIn_Meetei_Mayek_Extensions\nIn_Ethiopic_Extended_A\nIn_Latin_Extended_E\nIn_Cherokee_Supplement\nIn_Meetei_Mayek\nIn_Hangul_Syllables\nIn_Hangul_Jamo_Extended_B\nIn_High_Surrogates\nIn_High_Private_Use_Surrogates\nIn_Low_Surrogates\nIn_Private_Use_Area\nIn_CJK_Compatibility_Ideographs\nIn_Alphabetic_Presentation_Forms\nIn_Arabic_Presentation_Forms_A\nIn_Variation_Selectors\nIn_Vertical_Forms\nIn_Combining_Half_Marks\nIn_CJK_Compatibility_Forms\nIn_Small_Form_Variants\nIn_Arabic_Presentation_Forms_B\nIn_Halfwidth_and_Fullwidth_Forms\nIn_Specials\nIn_Linear_B_Syllabary\nIn_Linear_B_Ideograms\nIn_Aegean_Numbers\nIn_Ancient_Greek_Numbers\nIn_Ancient_Symbols\nIn_Phaistos_Disc\nIn_Lycian\nIn_Carian\nIn_Coptic_Epact_Numbers\nIn_Old_Italic\nIn_Gothic\nIn_Old_Permic\nIn_Ugaritic\nIn_Old_Persian\nIn_Deseret\nIn_Shavian\nIn_Osmanya\nIn_Osage\nIn_Elbasan\nIn_Caucasian_Albanian\nIn_Vithkuqi\nIn_Todhri\nIn_Linear_A\nIn_Latin_Extended_F\nIn_Cypriot_Syllabary\nIn_Imperial_Aramaic\nIn_Palmyrene\nIn_Nabataean\nIn_Hatran\nIn_Phoenician\nIn_Lydian\nIn_Meroitic_Hieroglyphs\nIn_Meroitic_Cursive\nIn_Kharoshthi\nIn_Old_South_Arabian\nIn_Old_North_Arabian\nIn_Manichaean\nIn_Avestan\nIn_Inscriptional_Parthian\nIn_Inscriptional_Pahlavi\nIn_Psalter_Pahlavi\nIn_Old_Turkic\nIn_Old_Hungarian\nIn_Hanifi_Rohingya\nIn_Garay\nIn_Rumi_Numeral_Symbols\nIn_Yezidi\nIn_Arabic_Extended_C\nIn_Old_Sogdian\nIn_Sogdian\nIn_Old_Uyghur\nIn_Chorasmian\nIn_Elymaic\nIn_Brahmi\nIn_Kaithi\nIn_Sora_Sompeng\nIn_Chakma\nIn_Mahajani\nIn_Sharada\nIn_Sinhala_Archaic_Numbers\nIn_Khojki\nIn_Multani\nIn_Khudawadi\nIn_Grantha\nIn_Tulu_Tigalari\nIn_Newa\nIn_Tirhuta\nIn_Siddham\nIn_Modi\nIn_Mongolian_Supplement\nIn_Takri\nIn_Myanmar_Extended_C\nIn_Ahom\nIn_Dogra\nIn_Warang_Citi\nIn_Dives_Akuru\nIn_Nandinagari\nIn_Zanabazar_Square\nIn_Soyombo\nIn_Unified_Canadian_Aboriginal_Syllabics_Extended_A\nIn_Pau_Cin_Hau\nIn_Devanagari_Extended_A\nIn_Sunuwar\nIn_Bhaiksuki\nIn_Marchen\nIn_Masaram_Gondi\nIn_Gunjala_Gondi\nIn_Makasar\nIn_Kawi\nIn_Lisu_Supplement\nIn_Tamil_Supplement\nIn_Cuneiform\nIn_Cuneiform_Numbers_and_Punctuation\nIn_Early_Dynastic_Cuneiform\nIn_Cypro_Minoan\nIn_Egyptian_Hieroglyphs\nIn_Egyptian_Hieroglyph_Format_Controls\nIn_Egyptian_Hieroglyphs_Extended_A\nIn_Anatolian_Hieroglyphs\nIn_Gurung_Khema\nIn_Bamum_Supplement\nIn_Mro\nIn_Tangsa\nIn_Bassa_Vah\nIn_Pahawh_Hmong\nIn_Kirat_Rai\nIn_Medefaidrin\nIn_Miao\nIn_Ideographic_Symbols_and_Punctuation\nIn_Tangut\nIn_Tangut_Components\nIn_Khitan_Small_Script\nIn_Tangut_Supplement\nIn_Kana_Extended_B\nIn_Kana_Supplement\nIn_Kana_Extended_A\nIn_Small_Kana_Extension\nIn_Nushu\nIn_Duployan\nIn_Shorthand_Format_Controls\nIn_Symbols_for_Legacy_Computing_Supplement\nIn_Znamenny_Musical_Notation\nIn_Byzantine_Musical_Symbols\nIn_Musical_Symbols\nIn_Ancient_Greek_Musical_Notation\nIn_Kaktovik_Numerals\nIn_Mayan_Numerals\nIn_Tai_Xuan_Jing_Symbols\nIn_Counting_Rod_Numerals\nIn_Mathematical_Alphanumeric_Symbols\nIn_Sutton_SignWriting\nIn_Latin_Extended_G\nIn_Glagolitic_Supplement\nIn_Cyrillic_Extended_D\nIn_Nyiakeng_Puachue_Hmong\nIn_Toto\nIn_Wancho\nIn_Nag_Mundari\nIn_Ol_Onal\nIn_Ethiopic_Extended_B\nIn_Mende_Kikakui\nIn_Adlam\nIn_Indic_Siyaq_Numbers\nIn_Ottoman_Siyaq_Numbers\nIn_Arabic_Mathematical_Alphabetic_Symbols\nIn_Mahjong_Tiles\nIn_Domino_Tiles\nIn_Playing_Cards\nIn_Enclosed_Alphanumeric_Supplement\nIn_Enclosed_Ideographic_Supplement\nIn_Miscellaneous_Symbols_and_Pictographs\nIn_Emoticons\nIn_Ornamental_Dingbats\nIn_Transport_and_Map_Symbols\nIn_Alchemical_Symbols\nIn_Geometric_Shapes_Extended\nIn_Supplemental_Arrows_C\nIn_Supplemental_Symbols_and_Pictographs\nIn_Chess_Symbols\nIn_Symbols_and_Pictographs_Extended_A\nIn_Symbols_for_Legacy_Computing\nIn_CJK_Unified_Ideographs_Extension_B\nIn_CJK_Unified_Ideographs_Extension_C\nIn_CJK_Unified_Ideographs_Extension_D\nIn_CJK_Unified_Ideographs_Extension_E\nIn_CJK_Unified_Ideographs_Extension_F\nIn_CJK_Unified_Ideographs_Extension_I\nIn_CJK_Compatibility_Ideographs_Supplement\nIn_CJK_Unified_Ideographs_Extension_G\nIn_CJK_Unified_Ideographs_Extension_H\nIn_Tags\nIn_Variation_Selectors_Supplement\nIn_Supplementary_Private_Use_Area_A\nIn_Supplementary_Private_Use_Area_B\nIn_No_Block`.\n  split(/\\s/).\n  map(p => [slug(p), p])\n);\n\nexport {\n  OnigUnicodePropertyMap,\n};\n", "import type {OnigurumaAst} from './parser/parse.js';\nimport {parse} from './parser/parse.js';\nimport {OnigUnicodePropertyMap} from './unicode.js';\n\ntype ToOnigurumaAstOptions = {\n  flags?: string;\n  rules?: {\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n};\n\n/**\nReturns an Oniguruma AST generated from an Oniguruma pattern.\n*/\nfunction toOnigurumaAst(pattern: string, options: ToOnigurumaAstOptions = {}): OnigurumaAst {\n  // If `options` provided, it must be a plain object (excluding `null`, arrays, etc.)\n  if ({}.toString.call(options) !== '[object Object]') {\n    throw new Error('Unexpected options');\n  }\n  return parse(pattern, {\n    // The parser includes additional options; limit the options that can be passed\n    flags: options.flags ?? '',\n    rules: {\n      captureGroup: options.rules?.captureGroup ?? false,\n      singleline: options.rules?.singleline ?? false,\n    },\n    unicodePropertyMap: OnigUnicodePropertyMap,\n  });\n}\n\nexport {\n  type ToOnigurumaAstOptions,\n  toOnigurumaAst,\n};\n", "import type {AlternativeElementNode, AlternativeNode, CharacterClassElementNode, Node, ParentNode, RegexNode} from '../parser/parse.js';\nimport {throwIfNullish} from '../utils.js';\n\ntype ContainerElementNode =\n  // Used within the `body` container of any `AlternativeContainerNode`\n  AlternativeNode |\n  // Any node type used within the `body` container of an `AlternativeNode`\n  AlternativeElementNode |\n  // Any node type used within the `body` container of a `CharacterClassNode`\n  CharacterClassElementNode;\n\ntype Path<N = Node, Root = RegexNode> = {\n  // The current node being traversed\n  node: N;\n  // Parent node of the current node\n  parent: N extends RegexNode ? null : ParentNode;\n  // String property where the current node in held by the parent node, or numeric index in the\n  // parent's `container` array\n  key: N extends RegexNode ? null : number | string;\n  // Container array holding the current node in the parent node; `null` if the parent isn't a type\n  // that contains a list of nodes\n  container: N extends RegexNode ? null : Array<ContainerElementNode> | null;\n  // Starting node of the AST being traversed; usually a `RegexNode` but can be any node type if\n  // traversing from a midpoint\n  root: Root;\n  // Removes the current node; its kids won't be traversed\n  remove: () => void;\n  // Removes all siblings to the right of the current node, without traversing them; returns the\n  // removed nodes\n  removeAllNextSiblings: () => Array<Node>;\n  // Removes all siblings to the left of the current node, which have already been traversed;\n  // returns the removed nodes\n  removeAllPrevSiblings: () => Array<Node>;\n  // Replaces the current node with a new node; kids of the replaced node won't be traversed;\n  // optionally traverses the new node\n  replaceWith: (newNode: Node, options?: {traverse?: boolean}) => void;\n  // Replaces the current node with multiple new nodes; kids of the replaced node won't be\n  // traversed; optionally traverses the new nodes\n  replaceWithMultiple: (newNodes: Array<Node>, options?: {traverse?: boolean}) => void;\n  // Skips traversing kids of the current node\n  skip: () => void;\n};\n\n// `VisitorNodeFn() {\u2026}` is shorthand for `VisitorNodeFn: {enter() {\u2026}}`.\ntype Visitor<State extends object | null = null, Root extends Node = RegexNode> = {\n  [N in Node as N['type']]?: VisitorNodeFn<Path<N, Root>, State> | {\n    enter?: VisitorNodeFn<Path<N, Root>, State>;\n    exit?: VisitorNodeFn<Path<N, Root>, State>;\n  };\n} & {\n  '*'?: VisitorNodeFn<Path<Node, Root>, State> | {\n    enter?: VisitorNodeFn<Path<Node, Root>, State>;\n    exit?: VisitorNodeFn<Path<Node, Root>, State>;\n  };\n};\n\ntype VisitorNodeFn<P, State> = (path: P, state: State) => void;\n\n/**\nTraverses an AST and calls the provided `visitor`'s node function for each node. Returns the same\nobject, possibly modified.\n\nVisitor node functions can modify the AST in place and use methods on the `path` (provided as their\nfirst argument) to help modify the AST. Provided `state` is passed through to all visitor node\nfunctions as their second argument.\n\nVisitor node functions are called in the following order:\n1. `enter` function of the `'*'` node type (if any)\n2. `enter` function of the given node's type (if any)\n3. [The node's kids (if any) are traversed recursively, unless `skip` is called]\n4. `exit` function of the given node's type (if any)\n5. `exit` function of the `'*'` node type (if any)\n*/\nfunction traverse<State extends object | null = null, Root extends Node = RegexNode>(\n  root: Root,\n  visitor: Visitor<State, Root>,\n  state: State | null = null\n): Root {\n  function traverseArray(array: NonNullable<Path['container']>, parent: Path['parent']) {\n    for (let i = 0; i < array.length; i++) {\n      const keyShift = traverseNode(array[i], parent, i, array);\n      i = Math.max(-1, i + keyShift);\n    }\n  }\n  function traverseNode(\n    node: Path['node'],\n    parent: Path['parent'] = null,\n    key: Path['key'] = null,\n    container: Path['container'] = null\n  ): number {\n    let keyShift = 0;\n    let skipTraversingKidsOfPath = false;\n    const path: Path = {\n      node,\n      parent,\n      key,\n      container,\n      root: root as RegexNode,\n      remove() {\n        arrayContainer(container).splice(Math.max(0, numericKey(key) + keyShift), 1);\n        keyShift--;\n        skipTraversingKidsOfPath = true;\n      },\n      removeAllNextSiblings() {\n        return arrayContainer(container).splice(numericKey(key) + 1);\n      },\n      removeAllPrevSiblings() {\n        const shifted = numericKey(key) + keyShift;\n        keyShift -= shifted;\n        return arrayContainer(container).splice(0, Math.max(0, shifted));\n      },\n      replaceWith(newNode, options = {}) {\n        const traverseNew = !!options.traverse;\n        if (container) {\n          container[Math.max(0, numericKey(key) + keyShift)] = newNode as ContainerElementNode;\n        } else {\n          // `key` will be one of:\n          // - For `CharacterClassRangeNode`: 'min', 'max'\n          // - For `QuantifierNode`: 'body'\n          // - For `RegexNode`: 'flags'\n          // @ts-expect-error\n          throwIfNullish(parent, `Can't replace root node`)[key as string] = newNode;\n        }\n        if (traverseNew) {\n          traverseNode(newNode, parent, key, container);\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      replaceWithMultiple(newNodes, options = {}) {\n        const traverseNew = !!options.traverse;\n        arrayContainer(container).splice(Math.max(0, numericKey(key) + keyShift), 1, ...newNodes);\n        keyShift += newNodes.length - 1;\n        if (traverseNew) {\n          let keyShiftInLoop = 0;\n          for (let i = 0; i < newNodes.length; i++) {\n            keyShiftInLoop += traverseNode(newNodes[i], parent, numericKey(key) + i + keyShiftInLoop, container);\n          }\n        }\n        skipTraversingKidsOfPath = true;\n      },\n      skip() {\n        skipTraversingKidsOfPath = true;\n      },\n    };\n\n    const {type} = node;\n    const anyTypeVisitor = visitor['*'];\n    const thisTypeVisitor = visitor[type];\n    const enterAllFn = typeof anyTypeVisitor === 'function' ? anyTypeVisitor : anyTypeVisitor?.enter;\n    const enterThisFn = typeof thisTypeVisitor === 'function' ? thisTypeVisitor : thisTypeVisitor?.enter;\n    // Type args are too complex to avoid TS errors here, but `VisitorNodeFn`s get correct types\n    // @ts-expect-error\n    enterAllFn?.(path, state);\n    // @ts-expect-error\n    enterThisFn?.(path, state);\n\n    if (!skipTraversingKidsOfPath) {\n      switch (type) {\n        case 'AbsenceFunction':\n        case 'CapturingGroup':\n        case 'Group':\n          traverseArray(node.body, node);\n          break;\n        case 'Alternative':\n        case 'CharacterClass':\n          traverseArray(node.body, node);\n          break;\n        case 'Assertion':\n        case 'Backreference':\n        case 'Character':\n        case 'CharacterSet':\n        case 'Directive':\n        case 'Flags':\n        case 'NamedCallout':\n        case 'Subroutine':\n          break;\n        case 'CharacterClassRange':\n          traverseNode(node.min, node, 'min');\n          traverseNode(node.max, node, 'max');\n          break;\n        case 'LookaroundAssertion':\n          traverseArray(node.body, node);\n          break;\n        case 'Quantifier':\n          traverseNode(node.body, node, 'body');\n          break;\n        case 'Regex':\n          traverseArray(node.body, node);\n          traverseNode(node.flags, node, 'flags');\n          break;\n        default:\n          throw new Error(`Unexpected node type \"${type}\"`);\n      }\n    }\n\n    // @ts-expect-error\n    (thisTypeVisitor as Exclude<typeof thisTypeVisitor, Function>)?.exit?.(path, state);\n    // @ts-expect-error\n    (anyTypeVisitor as Exclude<typeof anyTypeVisitor, Function>)?.exit?.(path, state);\n    return keyShift;\n  }\n  traverseNode(root);\n  return root;\n}\n\nfunction arrayContainer(value: unknown): Array<Node> {\n  if (!Array.isArray(value)) {\n    throw new Error('Container expected');\n  }\n  return value;\n}\n\nfunction numericKey(value: unknown): number {\n  if (typeof value !== 'number') {\n    throw new Error('Numeric key expected');\n  }\n  return value;\n}\n\nexport {\n  type Path,\n  type Visitor,\n  traverse,\n};\n", "import type {AlternativeNode, CharacterClassNode, CharacterNode, CharacterSetNode, NodeCharacterSetKind} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer} from '../../parser/node-utils.js';\nimport {createAlternative, createCharacterClass} from '../../parser/parse.js';\n\n/**\nUse character classes for adjacent alternatives with single-length values.\n*/\nconst alternationToClass: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const newAlts = [];\n    let ccNodes = [];\n    for (const alt of node.body) {\n      const kid = alt.body[0];\n      if (\n        alt.body.length === 1 &&\n        ( kid.type === 'Character' ||\n          kid.type === 'CharacterClass' ||\n          (kid.type === 'CharacterSet' && universalCharacterSetKinds.has(kid.kind))\n        )\n      ) {\n        ccNodes.push(kid);\n      } else {\n        if (ccNodes.length) {\n          newAlts.push(createAlternativeWithCombinedNodes(ccNodes));\n          ccNodes = [];\n        }\n        newAlts.push(alt);\n      }\n    }\n    if (ccNodes.length) {\n      newAlts.push(createAlternativeWithCombinedNodes(ccNodes));\n    }\n    node.body = newAlts;\n  },\n};\n\nfunction createAlternativeWithCombinedNodes(nodes: Array<CharacterNode | CharacterClassNode | CharacterSetNode>): AlternativeNode {\n  const alt = createAlternative();\n  const node = nodes.length > 1 ? createCharacterClass({body: nodes}) : nodes[0];\n  if (node) {\n    alt.body.push(node);\n  }\n  return alt;\n}\n\n// Character set kinds that can appear inside and outside of character classes, and can be inverted\n// by setting `negate`. Some but not all of those excluded use `variableLength: true`\nconst universalCharacterSetKinds = new Set<NodeCharacterSetKind>([\n  'digit',\n  'hex',\n  'posix',\n  'property',\n  'space',\n  'word',\n]);\n\nexport {\n  alternationToClass,\n};\n", "import type {Node} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\n\n/**\nPull leading and trailing assertions out of capturing groups when possible; helps group unwrapping.\nEx: `(^abc$)` -> `^(abc)$`.\nEx: `(\\b(?:a|bc)\\b)` -> `\\b((?:a|bc))\\b`. The inner group can subsequently be unwrapped.\n*/\nconst exposeAnchors: Visitor = {\n  // Done for capturing groups only because they can't be unwrapped like noncapturing groups (done\n  // via `unwrapUselessGroups` combined with `removeUselessFlags`; the latter also avoids hazards\n  // from flags that modify word boundary and text segment boundary assertions that would need to\n  // be handled here since noncapturing groups can specify flags to change). Pulling anchors out\n  // can subsequently enable unwrapping multi-alternative noncapturing groups within the capturing\n  // group, and has the side benefit that exposed anchors also improve readability\n  CapturingGroup({node, parent, replaceWithMultiple}) {\n    if (\n      parent.type === 'Quantifier' ||\n      node.body.length > 1 || // Multiple alts\n      node.isSubroutined\n    ) {\n      return;\n    }\n    const firstAlt = node.body[0];\n    const firstAltEls = firstAlt.body;\n    // Despite only pulling one assertion at a time, multiple can be extracted through multiple\n    // rounds of running this optimization\n    const leading = firstAltEls[0];\n    const trailing = firstAltEls.length > 1 ? firstAltEls.at(-1)! : null;\n    const hasLeadingAssertion = leading && leading.type === 'Assertion';\n    const hasTrailingAssertion = trailing && trailing.type === 'Assertion';\n    const clippedStart = hasLeadingAssertion ? 1 : 0;\n    const clippedEnd = firstAltEls.length - (hasTrailingAssertion ? 1 : 0);\n    if (hasLeadingAssertion || hasTrailingAssertion) {\n      firstAlt.body = firstAltEls.slice(clippedStart, clippedEnd);\n      const nodes: Array<Node> = [];\n      if (hasLeadingAssertion) {\n        // Could use `insertBefore` if the traverser supported it\n        nodes.push(leading);\n      }\n      nodes.push(node);\n      if (hasTrailingAssertion) {\n        // Could use `insertAfter` if the traverser supported it\n        nodes.push(trailing);\n      }\n      replaceWithMultiple(nodes, {traverse: true});\n    }\n  },\n};\n\nexport {\n  exposeAnchors,\n};\n", "import type {AssertionNode, CharacterNode, CharacterSetNode, Node} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\n\n/**\nExtract nodes at the start of every alternative into a prefix.\nEx: `^aa|^abb|^ac` -> `^a(?:a|bb|c)`.\nAlso works within groups.\n*/\nconst extractPrefix: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const prefixNodes = [];\n    let passedSharedPrefix = false;\n    let i = 0;\n    while (!passedSharedPrefix) {\n      prefixNodes.push(node.body[0].body[i]);\n      for (const alt of node.body) {\n        const kid = alt.body[i];\n        if (!kid || !isAllowedSimpleNode(kid) || !isNodeEqual(kid, prefixNodes[i])) {\n          passedSharedPrefix = true;\n          break;\n        }\n      }\n      i++;\n    }\n    prefixNodes.pop();\n    if (!prefixNodes.length) {\n      return;\n    }\n\n    for (const alt of node.body) {\n      alt.body = alt.body.slice(prefixNodes.length);\n    }\n    const newContentsAlt = createAlternative({body: prefixNodes});\n    const suffixGroup = createGroup({body: node.body});\n    if (!suffixGroup.body.every(alt => !alt.body.length)) {\n      newContentsAlt.body.push(suffixGroup);\n    }\n    node.body = [newContentsAlt];\n  },\n};\n\nfunction isAllowedSimpleNode(node: Node) {\n  return (\n    node.type === 'Assertion' ||\n    node.type === 'Character' ||\n    node.type === 'CharacterSet'\n  );\n}\n\n// TODO: Add support for more node types and move to `src/parser/node-utils.ts`\nfunction isNodeEqual(a: Node, b: Node): boolean {\n  if (a.type !== b.type) {\n    // TS doesn't understand that this makes `a` and `b` always have the same type, so we'll still\n    // need to cast, later\n    return false;\n  }\n  if (a.type === 'Assertion' || a.type === 'CharacterSet') {\n    return (\n      a.kind === (b as AssertionNode | CharacterSetNode).kind &&\n      a.negate === (b as AssertionNode | CharacterSetNode).negate\n    );\n  }\n  if (a.type === 'Character') {\n    return a.value === (b as CharacterNode).value;\n  }\n  // Only supports types from `isAllowedSimpleNode`\n  throw new Error(`Unexpected node type \"${a.type}\"`);\n}\n\nexport {\n  extractPrefix,\n  isAllowedSimpleNode,\n  isNodeEqual,\n};\n", "import type {AlternativeElementNode, AlternativeNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\nimport {isAllowedSimpleNode, isNodeEqual} from './extract-prefix.js';\n\n/**\nExtract alternating prefixes if patterns are repeated for each prefix.\nEx: `^a|!a|^bb|!bb|^c|!c` -> `(?:^|!)(?:a|bb|c)`.\nAlso works within groups.\n*/\nconst extractPrefix2: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node)) {\n      return;\n    }\n    const numDiffPrefixes = 2;\n    const numAlts = node.body.length;\n    if (numAlts < (numDiffPrefixes * 2) || numAlts % numDiffPrefixes) {\n      return;\n    }\n    const prefixAltElsByI = [...node.body.slice(0, numDiffPrefixes).map(alt => alt.body)];\n    const prefixNodesByI = Array.from({length: numDiffPrefixes}, (): Array<AlternativeElementNode> => []);\n    const prefixIsFinishedByI = Array(numDiffPrefixes).fill(false);\n    const longestOf = Math.max(...prefixAltElsByI.map(els => els.length));\n    for (let nodeI = 0; nodeI < longestOf; nodeI++) {\n      for (let prefixI = 0; prefixI < numDiffPrefixes; prefixI++) {\n        if (!prefixIsFinishedByI[prefixI]) {\n          const nextNode = prefixAltElsByI[prefixI][nodeI];\n          if (\n            !nextNode ||\n            !isAllowedSimpleNode(nextNode) ||\n            !isPrefixNodeShared(nextNode, node.body, prefixI, nodeI, numDiffPrefixes)\n          ) {\n            prefixIsFinishedByI[prefixI] = true;\n          } else {\n            prefixNodesByI[prefixI].push(nextNode);\n          }\n        }\n      }\n    }\n    if (!prefixNodesByI.some(nodes => nodes.length)) {\n      return;\n    }\n    const strippedAlts = [];\n    let counter = 0;\n    for (let i = 0; i < numAlts; i++) {\n      strippedAlts.push(createAlternative({\n        body: node.body[i].body.slice(prefixNodesByI[counter].length),\n      }));\n      counter = counter < (numDiffPrefixes - 1) ? counter + 1 : 0;\n    }\n    // Check that each set of alts now use the same value after having had their prefixes removed\n    for (let i = 0; i < (numAlts / numDiffPrefixes); i++) {\n      const altComparisonSet = strippedAlts.slice(i * numDiffPrefixes, (i * numDiffPrefixes) + numDiffPrefixes);\n      for (let j = 1; j < altComparisonSet.length; j++) {\n        const els = altComparisonSet[j].body;\n        if (els.length !== altComparisonSet[0].body.length) {\n          return;\n        }\n        if (!els.every((el, k) => (\n          isAllowedSimpleNode(el) &&\n          isNodeEqual(el, altComparisonSet[0].body[k])\n        ))) {\n          return;\n        }\n      }\n    }\n    const prefixAlts = [];\n    for (let i = 0; i < numDiffPrefixes; i++) {\n      prefixAlts.push(createAlternative({body: prefixNodesByI[i]}));\n    }\n    const prefixGroup = createGroup({body: prefixAlts});\n    const newContentsAlt = createAlternative({body: [prefixGroup]});\n    // Only take one (unique) alt from each set of stripped alts\n    const suffixGroup = createGroup({body: strippedAlts.filter((_, i) => i % numDiffPrefixes)});\n    if (suffixGroup.body.every(alt => !alt.body.length)) {\n      node.body = prefixGroup.body;\n    } else {\n      newContentsAlt.body.push(suffixGroup);\n      node.body = [newContentsAlt];\n    }\n  },\n};\n\nfunction isPrefixNodeShared(\n  node: AlternativeElementNode,\n  alts: Array<AlternativeNode>,\n  prefixI: number,\n  nodeI: number,\n  numDiffPrefixes: number\n): boolean {\n  for (let i = prefixI; i < alts.length; i += numDiffPrefixes) {\n    const alt = alts[i];\n    const bNode = alt.body[nodeI];\n    if (!bNode || !isNodeEqual(bNode, node)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {\n  extractPrefix2,\n};\n", "import type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer} from '../../parser/node-utils.js';\nimport {createAlternative, createGroup} from '../../parser/parse.js';\nimport {isAllowedSimpleNode, isNodeEqual} from './extract-prefix.js';\n\n/**\nExtract nodes at the end of every alternative into a suffix.\nEx: `aa$|bba$|ca$` -> `(?:a|bb|c)a$`.\nAlso works within groups.\n*/\nconst extractSuffix: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const firstAltEls = node.body[0].body;\n    const suffixNodes = [];\n    let passedSharedSuffix = false;\n    let i = 0;\n    while (!passedSharedSuffix) {\n      const inverseI = firstAltEls.length - 1 - i;\n      suffixNodes.push(firstAltEls[inverseI]);\n      for (const alt of node.body) {\n        const inverseIOfAlt = alt.body.length - 1 - i;\n        const kid = alt.body[inverseIOfAlt];\n        if (!kid || !isAllowedSimpleNode(kid) || !isNodeEqual(kid, suffixNodes[i])) {\n          passedSharedSuffix = true;\n          break;\n        }\n      }\n      i++;\n    }\n    suffixNodes.pop();\n    if (\n      !suffixNodes.length ||\n      // Avoid applying in cases when it would lengthen the pattern without any benefit; ex:\n      // `true|false` -> `(?:tru|fals)e`, or `if|elseif` -> `(?:|else)if`\n      ( suffixNodes.length < 3 &&\n        // Always extract the suffix if it ends with an assertion, since that provides a\n        // readability benefit and is more likely to trigger follow-on optimizations\n        suffixNodes[0].type !== 'Assertion' &&\n        // Four chars are added by the `(?:)` wrapper and one instance of the suffix is added back\n        // at the end, so avoid if the result could be longer\n        (suffixNodes.length * (node.body.length - 1)) < 4 &&\n        // Adjacent alts reduced to 0 or 1 node after extracting the suffix can possibly be\n        // collapsed in follow-on optimizations, providing a performance and/or minification\n        // benefit\n        !node.body.some((alt, i, arr) => {\n          const lastAlt = arr[i - 1];\n          const removed = suffixNodes.length;\n          return alt.body.length - removed < 2 && lastAlt && lastAlt.body.length - removed < 2;\n        })\n      )\n    ) {\n      return;\n    }\n    suffixNodes.reverse();\n\n    for (const alt of node.body) {\n      alt.body = alt.body.slice(0, -suffixNodes.length);\n    }\n    const newContentsAlt = createAlternative();\n    const prefixGroup = createGroup({body: node.body});\n    if (!prefixGroup.body.every(alt => !alt.body.length)) {\n      newContentsAlt.body.push(prefixGroup);\n    }\n    newContentsAlt.body.push(...suffixNodes);\n    node.body = [newContentsAlt];\n  },\n};\n\nexport {\n  extractSuffix,\n};\n", "import type {CharacterClassElementNode, CharacterClassRangeNode, CharacterNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {createCharacter, createCharacterClassRange} from '../../parser/parse.js';\n\n/**\nMerge, dedupe, and sort ranges and characters in character classes.\n*/\nconst mergeRanges: Visitor = {\n  CharacterClass({node}) {\n    if (node.kind !== 'union' || !node.body.length) {\n      return;\n    }\n\n    // ## Since characters and ranges will be deduped by merging, might as well dedupe sets too\n    const withoutDupeSets: Array<CharacterClassElementNode> = [];\n    for (const el of node.body) {\n      if (\n        el.type === 'CharacterSet' &&\n        withoutDupeSets.some(k => (\n          k.type === el.type &&\n          k.kind === el.kind &&\n          k.negate === el.negate &&\n          k.value === el.value\n        ))\n      ) {\n        continue;\n      }\n      // Keep non-duplicate sets (first instance) and any non-set nodes\n      withoutDupeSets.push(el);\n    }\n    node.body = withoutDupeSets;\n\n    // ## Now merge characters and ranges\n    const keep: Array<Exclude<CharacterClassElementNode, HandledNode>> = [];\n    const candidates: Array<HandledNode> = [];\n    for (const el of node.body) {\n      if (el.type === 'Character' || el.type === 'CharacterClassRange') {\n        candidates.push(el);\n      } else {\n        keep.push(el);\n      }\n    }\n    if (!candidates.length) {\n      return;\n    }\n    candidates.sort((a, b) => {\n      const aValue = a.type === 'Character' ? a.value : a.min.value;\n      const bValue = b.type === 'Character' ? b.value : b.min.value;\n      return aValue - bValue;\n    });\n    const merged: Array<HandledNode> = [candidates[0]];\n    for (let i = 1; i < candidates.length; i++) {\n      const el = candidates[i];\n      const last = merged.at(-1)!;\n      const elMin = el.type === 'Character' ? el.value : el.min.value;\n      const lastMax = last.type === 'Character' ? last.value : last.max.value;\n      if (elMin <= lastMax + 1) {\n        if (last.type === 'Character' && el.type === 'Character') {\n          if (last.value !== el.value) {\n            merged[merged.length - 1] = createCharacterClassRange(last, el);\n          }\n        } else if (last.type === 'Character' && el.type === 'CharacterClassRange') {\n          merged[merged.length - 1] = createCharacterClassRange(createCharacter(last.value), el.max);\n        } else if (last.type === 'CharacterClassRange' && el.type === 'Character') {\n          last.max.value = Math.max(el.value, last.max.value);\n        } else if (last.type === 'CharacterClassRange' && el.type === 'CharacterClassRange') {\n          last.max.value = Math.max(el.max.value, last.max.value);\n        } else {\n          throw new Error('Unexpected merge case');\n        }\n      } else {\n        merged.push(el);\n      }\n    }\n    // Replace any ranges with fewer than four (sometimes three) chars with character nodes\n    const final = merged.flatMap(el => {\n      if (el.type === 'CharacterClassRange') {\n        const diff = el.max.value - el.min.value;\n        // More aggressively use ranges for U+40000+, since they're rendered in long form like\n        // `\\x{40000}` rather than as single-length characters\n        if (el.min.value > 0x3FFFF && diff > 1) {\n          return el;\n        } else if (!diff) {\n          return el.min;\n        } else if (diff === 1) {\n          return [el.min, el.max];\n        } else if (diff === 2) {\n          // Ex: `a-c` -> `abc`\n          return [el.min, createCharacter(el.min.value + 1), el.max];\n        }\n        // `diff > 2`\n      }\n      return el;\n    });\n    // Always replace `body` to avoid skipping things like `[a-a]` -> `[a]` where both classes\n    // contain the same number of nodes; means we always sort characters/ranges by their values\n    node.body = [\n      // Pull chars to the front that don't need to be escaped in first position\n      ...final.filter(el => firstPosChar(el)),\n      ...final.filter(el => !firstPosChar(el)),\n      ...keep\n    ];\n  },\n};\n\ntype HandledNode = CharacterNode | CharacterClassRangeNode;\n\nfunction firstPosChar(node: HandledNode): boolean {\n  // Is `-` or `]`\n  return node.type === 'Character' && (node.value === 45 || node.value === 93);\n}\n\nexport {\n  mergeRanges,\n};\n", "import type {AlternativeElementNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer, isQuantifiable} from '../../parser/node-utils.js';\nimport {createQuantifier} from '../../parser/parse.js';\nimport {throwIfNullish} from '../../utils.js';\nimport {isAllowedSimpleNode, isNodeEqual} from './extract-prefix.js';\n\n/**\nCombine adjacent alternatives with only an added last node as the difference.\n*/\nconst optionalize: Visitor = {\n  '*'({node}) {\n    if (!isAlternativeContainer(node) || node.body.length < 2) {\n      return;\n    }\n    const {body} = node;\n    const newAlts = [body[0]];\n    let lastAltKept = body[0];\n    for (let i = 1; i < body.length; i++) {\n      // NOTE: Anytime we `continue` we don't keep this alt\n      const alt = body[i];\n      const altKids = alt.body;\n      const prevAltKids = lastAltKept.body;\n      const lengthDiff = Math.abs(altKids.length - prevAltKids.length);\n      if (!lengthDiff) {\n        if (isNodeArrayEqual(altKids, prevAltKids)) {\n          continue;\n        }\n      } else if (lengthDiff === 1) {\n        const isPrevAltLonger = !!(prevAltKids.length > altKids.length);\n        const altKidsToCompare = isPrevAltLonger ? altKids : altKids.slice(0, -1);\n        const prevAltKidsToCompare = isPrevAltLonger ? prevAltKids.slice(0, -1) : prevAltKids;\n        if (isNodeArrayEqual(altKidsToCompare, prevAltKidsToCompare)) {\n          if (isPrevAltLonger) {\n            const prevAltLastKid = throwIfNullish(prevAltKids.at(-1));\n            if (isQuantifiable(prevAltLastKid)) {\n              // Avoid chaining quantifiers since e.g. chained greedy `?` is `?{0,1}` and can\n              // lengthen the pattern\n              if (prevAltLastKid.type === 'Quantifier') {\n                if (!prevAltLastKid.min) {\n                  continue;\n                } else if (prevAltLastKid.min === 1 && prevAltLastKid.kind !== 'lazy') {\n                  prevAltLastKid.min = 0;\n                  continue;\n                }\n              } else {\n                // Put the prev alt's extra last node in a greedy `?`\n                prevAltKids.pop();\n                prevAltKids.push(createQuantifier('greedy', 0, 1, prevAltLastKid));\n                continue;\n              }\n            }\n          } else if (\n            // Don't apply if last alt empty since that would lengthen e.g. `(|a|b)` to `(a??|b)`\n            prevAltKids.length > 0 ||\n            // Unless there are two alts since e.g. `(?:|a)` to `(?:a??)` enables group unwrapping\n            body.length === 2\n          ) {\n            const altLastKid = throwIfNullish(altKids.at(-1));\n            if (isQuantifiable(altLastKid)) {\n              if (altLastKid.type === 'Quantifier') {\n                if (altLastKid.kind === 'possessive') {\n                  // No-op since possessive quantifiers can't also be lazy\n                } else if (altLastKid.min <= 1 && altLastKid.kind === 'lazy') {\n                  altLastKid.min = 0;\n                  prevAltKids.push(altLastKid);\n                  continue;\n                } else if (!altLastKid.min && altLastKid.max === 1) {\n                  altLastKid.kind = 'lazy';\n                  prevAltKids.push(altLastKid);\n                  continue;\n                }\n              } else {\n                // Put this alt's extra last node in a lazy `??` then add it to the prev alt\n                prevAltKids.push(createQuantifier('lazy', 0, 1, altLastKid));\n                continue;\n              }\n            }\n          }\n        }\n      }\n      newAlts.push(alt);\n      lastAltKept = alt;\n    }\n    node.body = newAlts;\n  },\n};\n\n// Returns `false` if the arrays contain a node type it doesn't know how to compare, or doesn't\n// want to compare (e.g. with capturing groups, which can't be removed)\nfunction isNodeArrayEqual(a: Array<AlternativeElementNode>, b: Array<AlternativeElementNode>) {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (!isAllowedSimpleNode(a[i]) || !isAllowedSimpleNode(b[i])) {\n      return false;\n    }\n    if (!isNodeEqual(a[i], b[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport {\n  optionalize,\n};\n", "import type {QuantifierNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {hasOnlyChild} from '../../parser/node-utils.js';\n\n/**\nRemove identified ReDoS vulnerabilities without changing matches.\n*/\nconst preventReDoS: Visitor = {\n  Quantifier({node}) {\n    // Prevent a common cause of catastrophic backtracking by removing an unneeded nested\n    // quantifier from the first alternative of infinitely-quantified groups. Can't remove nested\n    // quantifiers from other alternatives or when the first alternative contains more than one\n    // node, because that might change the match\n    // TODO: It's safe to skip this transform if the quantified group is the last node in the\n    // pattern, since there's no backtracking trigger if there's no following node\n    const {body, max} = node;\n    if (\n      max !== Infinity ||\n      // Can't operate on capturing groups because that could change the captured value\n      body.type !== 'Group' ||\n      // No benefit with atomic groups\n      body.atomic\n    ) {\n      return;\n    }\n    const firstAlt = body.body[0];\n    if (!hasOnlyChild(firstAlt, {type: 'Quantifier'})) {\n      return;\n    }\n    const nestedQuantifier = firstAlt.body[0] as QuantifierNode;\n    if (\n      // No benefit with possessive quantifiers\n      nestedQuantifier.kind === 'possessive' ||\n      nestedQuantifier.min > 1 ||\n      nestedQuantifier.max < 2\n    ) {\n      return;\n    }\n    if (!nestedQuantifier.min) {\n      // Ex: Change `*` or `{0,2}` to `?`; preserve laziness\n      nestedQuantifier.max = 1;\n    } else if (nestedQuantifier.min === 1) {\n      // Ex: Remove `+` or `{1,2}`\n      firstAlt.body[0] = nestedQuantifier.body;\n    }\n  },\n};\n\nexport {\n  preventReDoS,\n};\n", "import type {AlternativeContainerNode, Node} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\n\n/**\nRemove empty noncapturing, atomic, and flag groups, even if quantified.\n*/\nconst removeEmptyGroups: Visitor = {\n  AbsenceFunction({node, remove}) {\n    if (isQualifiedAndEmpty(node)) {\n      remove();\n    }\n  },\n\n  Group({node, remove}) {\n    if (isQualifiedAndEmpty(node)) {\n      remove();\n    }\n  },\n\n  LookaroundAssertion({node, remove}) {\n    if (isQualifiedAndEmpty(node)) {\n      remove();\n    }\n  },\n\n  Quantifier({node, remove}) {\n    let kid = node.body;\n    while (kid.type === 'Quantifier') {\n      kid = kid.body;\n    }\n    if (isQualifiedAndEmpty(kid)) {\n      remove();\n    }\n  },\n};\n\nfunction hasOnlyEmptyAlts(node: AlternativeContainerNode): boolean {\n  return node.body.every(alt => !alt.body.length);\n}\n\nfunction isQualifiedAndEmpty(node: Node): boolean {\n  switch (node.type) {\n    case 'AbsenceFunction':\n      return node.kind === 'repeater' && hasOnlyEmptyAlts(node);\n    case 'Group':\n      return hasOnlyEmptyAlts(node);\n    case 'LookaroundAssertion':\n      return !node.negate && hasOnlyEmptyAlts(node);\n    default:\n      return false;\n  }\n}\n\nexport {\n  removeEmptyGroups,\n};\n", "import type {DirectiveNode, GroupNode} from '../../parser/parse.js';\nimport type {FlagGroupModifiers} from '../../tokenizer/tokenize.js';\nimport type {Visitor} from '../../traverser/traverse.js';\n\n/**\nRemove flags (from top-level and modifiers) that have no effect.\n*/\nconst removeUselessFlags: Visitor = {\n  // TODO: Support removing additional flags\n\n  Flags({node}) {\n    // Effects of flag x are already applied during parsing\n    node.extended = false;\n    // Text segment handling uses grapheme mode by default, so it doesn't need to be set\n    if (node.textSegmentMode === 'grapheme') {\n      node.textSegmentMode = null;\n    }\n  },\n\n  Directive({node, remove}) {\n    if (node.kind !== 'flags') {\n      return;\n    }\n    removeFlagX(node);\n    if (removeEmptyFlagsObj(node)) {\n      remove();\n    }\n  },\n\n  Group({node}) {\n    if (!node.flags) {\n      return;\n    }\n    removeFlagX(node);\n    removeEmptyFlagsObj(node);\n  },\n};\n\nfunction removeEmptyFlagsObj(node: DirectiveNode | GroupNode): boolean {\n  const {flags} = node;\n  if (flags && !flags.enable && !flags.disable) {\n    delete node.flags;\n    return true;\n  }\n  return false;\n}\n\nfunction removeFlagX({flags}: DirectiveNode | GroupNode) {\n  if (!flags) {\n    throw new Error('Expected flags');\n  }\n  flags.enable && delete flags.enable.extended;\n  flags.disable && delete flags.disable.extended;\n  cleanupFlagsObj(flags);\n}\n\nfunction cleanupFlagsObj(flags: FlagGroupModifiers) {\n  flags.enable && !Object.keys(flags.enable).length && delete flags.enable;\n  flags.disable && !Object.keys(flags.disable).length && delete flags.disable;\n}\n\nexport {\n  removeUselessFlags,\n};\n", "import type {Visitor} from '../../traverser/traverse.js';\nimport {createLookaroundAssertion} from '../../parser/parse.js';\n\n/**\nCleanup callout arguments, removing redundant commas, leading zeros, and empty braces.\n*/\nconst simplifyCallouts: Visitor = {\n  NamedCallout({node, replaceWith}) {\n    const {arguments: args, kind} = node;\n\n    // Special case: `(*FAIL)` -> `(?!)`\n    if (kind === 'fail') {\n      replaceWith(createLookaroundAssertion({negate: true}));\n      return;\n    }\n\n    if (!args) {\n      return;\n    }\n    const newArgs: Array<string | number> = args.\n      filter(arg => arg !== '').\n      // TODO: If supporting custom callout names in the future, add `kind !== 'custom'` to this\n      // condition, since custom named callouts might treat e.g. `+05` as a string\n      map(arg => (typeof arg === 'string' && /^[+-]?\\d+$/.test(arg)) ? +arg : arg);\n    node.arguments = newArgs.length ? newArgs : null;\n  },\n};\n\nexport {\n  simplifyCallouts,\n};\n", "import type {CharacterClassNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {hasOnlyChild} from '../../parser/node-utils.js';\n\n/**\nUnnest character classes when possible.\nSee also `unwrapNegationWrappers`.\n*/\nconst unnestUselessClasses: Visitor = {\n  CharacterClass({node, parent, replaceWith, replaceWithMultiple}) {\n    const {body, kind, negate} = node;\n    if (\n      // Don't use this to unwrap outermost classes; see `unwrapUselessClasses` for that\n      parent.type !== 'CharacterClass' ||\n      kind !== 'union' ||\n      !body.length\n    ) {\n      return;\n    }\n    const firstEl = body[0];\n    // Special case to unnest classes that are an only-kid of their parent, since it might flip\n    // `negate` on the parent; ex:\n    // `[[a]]` -> `[a]`; `[[^a]]` -> `[^a]`; `[^[a]]` -> `[^a]`; `[^[^a]]` -> `[a]`\n    if (hasOnlyChild(parent, {\n      type: 'CharacterClass',\n      kind: 'union',\n    })) {\n      parent.negate = parent.negate !== negate;\n      replaceWithMultiple(body, {traverse: true});\n      return;\n    }\n    // Remainder of options apply only if the class is non-negated\n    if (negate) {\n      return;\n    }\n    // Unnest all kids into a union class\n    if (parent.kind === 'union') {\n      replaceWithMultiple(body, {traverse: true});\n    // Can unnest any one kid into an intersection class\n    // TODO: After supporting `format` for classes (see <github.com/slevithan/oniguruma-parser/issues/1>),\n    // can visually unnest any number of kids into intersection by flipping this class's `format`\n    // from `'explicit'` to `'implicit'`, rather than replacing it\n    } else if (hasOnlyChild(node)) {\n      replaceWith(firstEl, {traverse: true});\n    }\n  },\n};\n\nexport {\n  unnestUselessClasses,\n};\n", "import type {Visitor} from '../../traverser/traverse.js';\nimport {createCharacterSet} from '../../parser/parse.js';\n\n/**\nUnwrap negated classes used to negate an individual character set.\nAllows independently controlling this behavior, and avoids logic duplication in\n`unwrapUselessClasses` and `unnestUselessClasses`.\n*/\nconst unwrapNegationWrappers: Visitor = {\n  CharacterClass({node, parent, replaceWith}) {\n    const {body, kind, negate} = node;\n    if (!negate || kind !== 'union' || body.length !== 1) {\n      return;\n    }\n    const kid = body[0];\n    if (kid.type === 'CharacterSet') {\n      kid.negate = !kid.negate;\n      // Might unnest into a class or unwrap into a non-class. All character set kinds valid in a\n      // class are also valid outside of a class, though the inverse isn't true\n      replaceWith(kid);\n    } else if (\n      parent.type !== 'CharacterClass' &&\n      kid.type === 'Character' &&\n      kid.value === 10 // '\\n'\n    ) {\n      if (parent.type === 'Quantifier' && parent.kind !== 'lazy') {\n        // Avoid introducing a trigger for a `vscode-oniguruma` bug (v2.0.1 tested); see\n        // <github.com/kkos/oniguruma/issues/347>\n        return;\n      }\n      // `[^\\n]` -> `\\N`; can only use `\\N` if not in a class\n      replaceWith(createCharacterSet('newline', {negate: true}));\n    }\n  },\n};\n\nexport {\n  unwrapNegationWrappers,\n};\n", "import type {Visitor} from '../../traverser/traverse.js';\n\n/**\nUnwrap outermost non-negated character classes containing a single character or character set.\nSee also `unwrapNegationWrappers`.\n*/\nconst unwrapUselessClasses: Visitor = {\n  CharacterClass({node, parent, replaceWith}) {\n    const {body, kind, negate} = node;\n    const kid = body[0];\n    if (\n      parent.type === 'CharacterClass' ||\n      negate ||\n      kind !== 'union' ||\n      body.length !== 1 ||\n      (kid.type !== 'Character' && kid.type !== 'CharacterSet')\n    ) {\n      return;\n    }\n    replaceWith(kid, {traverse: true});\n  },\n};\n\nexport {\n  unwrapUselessClasses,\n};\n", "import type {AlternativeContainerNode, AlternativeElementNode, GroupNode, Node, QuantifiableNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {isAlternativeContainer, isQuantifiable} from '../../parser/node-utils.js';\n\n/**\nUnwrap nonbeneficial noncapturing and atomic groups.\n*/\nconst unwrapUselessGroups: Visitor = {\n  // Unwrap kid from the outside in, since the traverser doesn't support stepping multiple levels\n  // up the tree\n  '*'({node}) {\n    if (!isAlternativeContainer(node)) {\n      return;\n    }\n    if (hasMultiAltNoncapturingGroupOnlyChild(node)) {\n      // Isn't needed in some cases like if `node` is itself a basic noncapturing group (since\n      // there's already handling in `Group`), but it doesn't hurt to handle it here instead\n      node.body = (node.body[0].body[0] as GroupNode).body;\n    }\n  },\n\n  Group({node, parent, replaceWithMultiple}) {\n    const {atomic, body, flags} = node;\n    const firstAltEls = body[0].body;\n    if (body.length > 1 || parent.type === 'Quantifier') {\n      return;\n    }\n    let unwrap = false;\n    if (atomic) {\n      if (firstAltEls.every(({type}: AlternativeElementNode) => atomicTypes.has(type))) {\n        unwrap = true;\n      }\n    // For flag groups, rely on `removeUselessFlags`, after which the group can be unwrapped in a\n    // subsequent pass\n    } else if (!flags) {\n      unwrap = true;\n    }\n    if (unwrap) {\n      replaceWithMultiple(firstAltEls, {traverse: true});\n    }\n  },\n\n  // Unwrap quantified groups that contain a single quantifiable node\n  Quantifier({node}) {\n    if (node.body.type !== 'Group') {\n      return;\n    }\n    const quantifiedGroup = node.body;\n    if (quantifiedGroup.body.length > 1) {\n      return;\n    }\n    const groupKids = quantifiedGroup.body[0].body;\n    if (groupKids.length !== 1) {\n      return;\n    }\n    const candidate = groupKids[0];\n    if (\n      !isQuantifiable(candidate) ||\n      // Some atomic types have already been ruled out as not quantifiable\n      (quantifiedGroup.atomic && !atomicTypes.has(candidate.type)) ||\n      quantifiedGroup.flags\n    ) {\n      return;\n    }\n    // Make the only child of the group the new `body` of the quantifier\n    node.body = candidate;\n  },\n};\n\nconst atomicTypes = new Set<Node['type']>([\n  'Assertion',\n  'Backreference',\n  'Character',\n  'CharacterClass',\n  'CharacterSet',\n  'Directive',\n  'NamedCallout',\n]);\n\nfunction hasMultiAltNoncapturingGroupOnlyChild({body}: AlternativeContainerNode): boolean {\n  const firstAltEls = body[0].body;\n  return (\n    body.length === 1 &&\n    firstAltEls.length === 1 &&\n    firstAltEls[0].type === 'Group' &&\n    !firstAltEls[0].atomic &&\n    !firstAltEls[0].flags &&\n    firstAltEls[0].body.length > 1\n  );\n}\n\nexport {\n  unwrapUselessGroups,\n};\n", "import type {CharacterSetNode, Node} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {createCharacterSet} from '../../parser/parse.js';\nimport {cpOf} from '../../utils.js';\n\n/**\nUse shorthands (`\\d`, `\\h`, `\\s`, etc.) when possible.\n- `\\d` from `\\p{Decimal_Number}`, `\\p{Nd}`, `\\p{digit}`, `[[:digit:]]`\n- `\\h` from `\\p{ASCII_Hex_Digit}`, `\\p{AHex}`, `\\p{xdigit}`, `[[:xdigit:]]`, `[0-9A-Fa-f]`\n- `\\s` from `\\p{White_Space}`, `\\p{WSpace}`, `\\p{space}`, `[[:space:]]`\n- `\\w` from `[\\p{L}\\p{M}\\p{N}\\p{Pc}]` - Not the same as POSIX `\\p{word}`, `[[:word:]]`!\n- `\\O` from `\\p{Any}` if not in class\nSee also `useUnicodeProps`.\n*/\nconst useShorthands: Visitor = {\n  CharacterSet({node, parent, root, replaceWith}) {\n    const {kind, negate, value} = node;\n    let newNode: CharacterSetNode | null = null;\n    if (\n      ( kind === 'property' &&\n        (value === 'Decimal_Number' || value === 'Nd') &&\n        // TODO: Also check local context when the parser supports these flags on pattern modifiers\n        !root.flags.digitIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === 'posix' &&\n        value === 'digit'\n      )\n    ) {\n      newNode = createCharacterSet('digit', {negate});\n    } else if (\n      ( kind === 'property' &&\n        (value === 'ASCII_Hex_Digit' || value === 'AHex')\n      ) ||\n      ( kind === 'posix' &&\n        value === 'xdigit'\n      )\n    ) {\n      newNode = createCharacterSet('hex', {negate});\n    } else if (\n      ( kind === 'property' &&\n        (value === 'White_Space' || value === 'WSpace') &&\n        // TODO: Also check local context when the parser supports these flags on pattern modifiers\n        !root.flags.spaceIsAscii &&\n        !root.flags.posixIsAscii\n      ) ||\n      ( kind === 'posix' &&\n        value === 'space'\n      )\n    ) {\n      newNode = createCharacterSet('space', {negate});\n    } else if (\n      parent.type !== 'CharacterClass' &&\n      kind === 'property' &&\n      !negate &&\n      value === 'Any'\n    ) {\n      newNode = createCharacterSet('any');\n    }\n    if (newNode) {\n      replaceWith(newNode);\n    }\n  },\n\n  CharacterClass({node, root}) {\n    if (node.kind !== 'union') {\n      return;\n    }\n    const has = {\n      rangeDigit0To9: false,\n      rangeAToFLower: false,\n      rangeAToFUpper: false,\n      unicodeL: false,\n      unicodeM: false,\n      unicodeN: false,\n      unicodePc: false,\n    };\n    for (const kid of node.body) {\n      if (kid.type === 'CharacterClassRange') {\n        has.rangeDigit0To9 ||= isRange(kid, cp.n0, cp.n9);\n        has.rangeAToFLower ||= isRange(kid, cp.a, cp.f);\n        has.rangeAToFUpper ||= isRange(kid, cp.A, cp.F);\n      } else if (kid.type === 'CharacterSet') {\n        has.unicodeL ||= isUnicode(kid, 'L');\n        has.unicodeM ||= isUnicode(kid, 'M');\n        has.unicodeN ||= isUnicode(kid, 'N');\n        has.unicodePc ||= isUnicode(kid, 'Pc', {includeSupercategories: true});\n      }\n    }\n    // TODO: Only need one of A-F or a-f if flag i is active in local context; relies on\n    // <github.com/slevithan/oniguruma-parser/issues/14>\n    if (has.rangeDigit0To9 && has.rangeAToFUpper && has.rangeAToFLower) {\n      node.body = node.body.filter(kid => !(\n        isRange(kid, cp.n0, cp.n9) || isRange(kid, cp.a, cp.f) || isRange(kid, cp.A, cp.F)\n      ));\n      node.body.push(createCharacterSet('hex'));\n    }\n    if (\n      (has.unicodeL && has.unicodeM && has.unicodeN && has.unicodePc) &&\n      // TODO: Also check local context when the parser supports these flags on pattern modifiers\n      !root.flags.wordIsAscii &&\n      !root.flags.posixIsAscii\n    ) {\n      node.body = node.body.filter(kid => !isUnicode(kid, ['L', 'M', 'N', 'Pc'], {\n        includeSubcategories: true,\n      }));\n      node.body.push(createCharacterSet('word'));\n    }\n  },\n};\n\nconst cp = {\n  n0: cpOf('0'),\n  n9: cpOf('9'),\n  A: cpOf('A'),\n  F: cpOf('F'),\n  a: cpOf('a'),\n  f: cpOf('f'),\n};\n\nfunction isRange(node: Node, min: number, max: number): boolean {\n  return (\n    node.type === 'CharacterClassRange' &&\n    node.min.value === min &&\n    node.max.value === max\n  );\n}\n\nfunction isUnicode(\n  node: Node,\n  value: string | Array<string>,\n  options: {includeSupercategories?: boolean; includeSubcategories?: boolean} = {}\n): boolean {\n  if (\n    node.type !== 'CharacterSet' ||\n    node.kind !== 'property' ||\n    node.negate\n  ) {\n    return false;\n  }\n  const names = Array.isArray(value) ? value : [value];\n  const expanded: Array<string> = [];\n  for (const v of names) {\n    expanded.push(v);\n    const supercategoryFullName = categories[v as SupercategoryShortName]?.full;\n    const supercategoryShortName = supercategories[v as SubcategoryShortName];\n    const subcategoryShortNames = categories[v as SupercategoryShortName]?.sub;\n    if (supercategoryFullName) {\n      expanded.push(supercategoryFullName);\n    }\n    if (options.includeSupercategories && supercategoryShortName) {\n      expanded.push(supercategoryShortName);\n      expanded.push(categories[supercategoryShortName].full);\n    }\n    if (options.includeSubcategories && subcategoryShortNames) {\n      expanded.push(...subcategoryShortNames);\n    }\n  }\n  return expanded.includes(node.value);\n}\n\ntype SupercategoryShortName = 'L' | 'M' | 'N' | 'P';\ntype SubcategoryShortName = typeof subL[number] | typeof subM[number] | typeof subN[number] | typeof subP[number];\nconst subL = ['Ll', 'Lm', 'Lo', 'Lt', 'Lu'] as const;\nconst subM = ['Mc', 'Me', 'Mn'] as const;\nconst subN = ['Nd', 'Nl', 'No'] as const;\nconst subP = ['Pc', 'Pd', 'Pe', 'Pf', 'Pi', 'Po', 'Ps'] as const;\nconst categories: {[key in SupercategoryShortName]: {full: string; sub: ReadonlyArray<SubcategoryShortName>}} = {\n  L: {full: 'Letter', sub: subL},\n  M: {full: 'Mark', sub: subM},\n  N: {full: 'Number', sub: subN},\n  P: {full: 'Punctuation', sub: subP},\n};\nconst supercategories = {} as {[key in SubcategoryShortName]: SupercategoryShortName};\nfor (const key of Object.keys(categories) as Array<SupercategoryShortName>) {\n  for (const sub of categories[key].sub) {\n    supercategories[sub] = key;\n  }\n}\n\nexport {\n  isRange,\n  useShorthands,\n};\n", "import type {Visitor} from '../../traverser/traverse.js';\n\n/**\nUse Unicode property aliases.\n*/\nconst useUnicodeAliases: Visitor = {\n  CharacterSet({node}) {\n    if (node.kind !== 'property') {\n      return;\n    }\n    const alias = OnigUnicodeAliasMap.get(node.value);\n    if (alias) {\n      node.value = alias;\n    }\n  },\n};\n\n// Oniguruma doesn't include all Unicode property aliases; some are treated as POSIX class names\n// and are excluded (see `PosixClassNames`)\nconst OnigUnicodeAliasMap = /* @__PURE__ */ new Map([\n  // ## General category aliases\n  ['Other', 'C'],\n    ['Control', 'Cc'],\n    ['Format', 'Cf'],\n    ['Unassigned', 'Cn'],\n    ['Private_Use', 'Co'],\n    ['Surrogate', 'Cs'],\n  ['Letter', 'L'],\n    ['Cased_Letter', 'LC'],\n    ['Lowercase_Letter', 'Ll'],\n    ['Modifier_Letter', 'Lm'],\n    ['Other_Letter', 'Lo'],\n    ['Titlecase_Letter', 'Lt'],\n    ['Uppercase_Letter', 'Lu'],\n  ['Mark', 'M'],\n  ['Combining_Mark', 'M'],\n    ['Spacing_Mark', 'Mc'],\n    ['Enclosing_Mark', 'Me'],\n    ['Nonspacing_Mark', 'Mn'],\n  ['Number', 'N'],\n    ['Decimal_Number', 'Nd'],\n    ['Letter_Number', 'Nl'],\n    ['Other_Number', 'No'],\n  ['Punctuation', 'P'],\n  // `punct` is also a POSIX class name, but it's included in the Oniguruma property list since the\n  // POSIX class version uses a different value starting with Oniguruma 6.9.9\n  ['punct', 'P'],\n    ['Connector_Punctuation', 'Pc'],\n    ['Dash_Punctuation', 'Pd'],\n    ['Close_Punctuation', 'Pe'],\n    ['Final_Punctuation', 'Pf'],\n    ['Initial_Punctuation', 'Pi'],\n    ['Other_Punctuation', 'Po'],\n    ['Open_Punctuation', 'Ps'],\n  ['Symbol', 'S'],\n    ['Currency_Symbol', 'Sc'],\n    ['Modifier_Symbol', 'Sk'],\n    ['Math_Symbol', 'Sm'],\n    ['Other_Symbol', 'So'],\n  ['Separator', 'Z'],\n    ['Line_Separator', 'Zl'],\n    ['Paragraph_Separator', 'Zp'],\n    ['Space_Separator', 'Zs'],\n\n  // ## Binary property aliases\n  ['ASCII_Hex_Digit', 'AHex'],\n  ['Bidi_Control', 'Bidi_C'],\n  ['Case_Ignorable', 'CI'],\n  ['Changes_When_Casefolded', 'CWCF'],\n  ['Changes_When_Casemapped', 'CWCM'],\n  ['Changes_When_Lowercased', 'CWL'],\n  ['Changes_When_Titlecased', 'CWT'],\n  ['Changes_When_Uppercased', 'CWU'],\n  ['Default_Ignorable_Code_Point', 'DI'],\n  ['Deprecated', 'Dep'],\n  ['Diacritic', 'Dia'],\n  ['Emoji_Component', 'EComp'],\n  ['Emoji_Modifier', 'EMod'],\n  ['Emoji_Modifier_Base', 'EBase'],\n  ['Emoji_Presentation', 'EPres'],\n  ['Extended_Pictographic', 'ExtPict'],\n  ['Extender', 'Ext'],\n  ['Grapheme_Base', 'Gr_Base'],\n  ['Grapheme_Extend', 'Gr_Ext'],\n  ['Grapheme_Link', 'Gr_Link'],\n  ['Hex_Digit', 'Hex'],\n  ['IDS_Binary_Operator', 'IDSB'],\n  ['IDS_Trinary_Operator', 'IDST'],\n  ['IDS_Unary_Operator', 'IDSU'],\n  ['ID_Continue', 'IDC'],\n  ['ID_Start', 'IDS'],\n  ['Ideographic', 'Ideo'],\n  ['Join_Control', 'Join_C'],\n  ['Logical_Order_Exception', 'LOE'],\n  ['Noncharacter_Code_Point', 'NChar'],\n  ['Other_Alphabetic', 'OAlpha'],\n  ['Other_Default_Ignorable_Code_Point', 'ODI'],\n  ['Other_Grapheme_Extend', 'OGr_Ext'],\n  ['Other_ID_Continue', 'OIDC'],\n  ['Other_ID_Start', 'OIDS'],\n  ['Other_Lowercase', 'OLower'],\n  ['Other_Math', 'OMath'],\n  ['Other_Uppercase', 'OUpper'],\n  ['Pattern_Syntax', 'Pat_Syn'],\n  ['Pattern_White_Space', 'Pat_WS'],\n  ['Prepended_Concatenation_Mark', 'PCM'],\n  ['Quotation_Mark', 'QMark'],\n  ['Regional_Indicator', 'RI'],\n  ['Sentence_Terminal', 'STerm'],\n  ['Soft_Dotted', 'SD'],\n  ['Terminal_Punctuation', 'Term'],\n  ['Unified_Ideograph', 'UIdeo'],\n  ['Variation_Selector', 'VS'],\n  ['White_Space', 'WSpace'],\n  ['XID_Continue', 'XIDC'],\n  ['XID_Start', 'XIDS'],\n\n  // ## Script aliases\n  // TODO: Add script aliases\n]);\n\nexport {\n  useUnicodeAliases,\n};\n", "import type {CharacterSetNode} from '../../parser/parse.js';\nimport type {Visitor} from '../../traverser/traverse.js';\nimport {createUnicodeProperty} from '../../parser/parse.js';\nimport {isRange} from './use-shorthands.js';\n\n/**\nUse Unicode properties when possible.\n- `\\p{Any}` from `[\\0-\\x{10FFFF}]`\n- `\\p{Cc}` from POSIX `\\p{cntrl}`, `[[:cntrl:]]`\nSee also `useShorthands`.\n*/\nconst useUnicodeProps: Visitor = {\n  CharacterSet({node, root, replaceWith}) {\n    const {kind, negate, value} = node;\n    let newNode: CharacterSetNode | null = null;\n    if (\n      kind === 'posix' &&\n      value === 'cntrl' &&\n      // TODO: Also check local context when the parser supports this flag on pattern modifiers\n      !root.flags.posixIsAscii\n    ) {\n      newNode = createUnicodeProperty('Cc', {negate});\n    }\n    if (newNode) {\n      replaceWith(newNode);\n    }\n  },\n\n  CharacterClassRange({node, replaceWith}) {\n    if (isRange(node, 0, 0x10FFFF)) {\n      replaceWith(createUnicodeProperty('Any'));\n    }\n  },\n};\n\nexport {\n  useUnicodeProps,\n};\n", "import type {Visitor} from '../traverser/traverse.js';\nimport {alternationToClass} from './transforms/alternation-to-class.js';\nimport {exposeAnchors} from './transforms/expose-anchors.js';\nimport {extractPrefix} from './transforms/extract-prefix.js';\nimport {extractPrefix2} from './transforms/extract-prefix-2.js';\nimport {extractSuffix} from './transforms/extract-suffix.js';\nimport {mergeRanges} from './transforms/merge-ranges.js';\nimport {optionalize} from './transforms/optionalize.js';\nimport {preventReDoS} from './transforms/prevent-redos.js';\nimport {removeEmptyGroups} from './transforms/remove-empty-groups.js';\nimport {removeUselessFlags} from './transforms/remove-useless-flags.js';\nimport {simplifyCallouts} from './transforms/simplify-callouts.js';\nimport {unnestUselessClasses} from './transforms/unnest-useless-classes.js';\nimport {unwrapNegationWrappers} from './transforms/unwrap-negation-wrappers.js';\nimport {unwrapUselessClasses} from './transforms/unwrap-useless-classes.js';\nimport {unwrapUselessGroups} from './transforms/unwrap-useless-groups.js';\nimport {useShorthands} from './transforms/use-shorthands.js';\nimport {useUnicodeAliases} from './transforms/use-unicode-aliases.js';\nimport {useUnicodeProps} from './transforms/use-unicode-props.js';\n\ntype OptimizationName =\n  'alternationToClass' |\n  'exposeAnchors' |\n  'extractPrefix' |\n  'extractPrefix2' |\n  'extractSuffix' |\n  'mergeRanges' |\n  'optionalize' |\n  'preventReDoS' |\n  'removeEmptyGroups' |\n  'removeUselessFlags' |\n  'simplifyCallouts' |\n  'unnestUselessClasses' |\n  'unwrapNegationWrappers' |\n  'unwrapUselessClasses' |\n  'unwrapUselessGroups' |\n  'useShorthands' |\n  'useUnicodeAliases' |\n  'useUnicodeProps';\n\nconst optimizations = new Map<OptimizationName, Visitor>([\n  ['alternationToClass', alternationToClass],\n  ['exposeAnchors', exposeAnchors],\n  ['extractPrefix', extractPrefix],\n  ['extractPrefix2', extractPrefix2],\n  ['extractSuffix', extractSuffix],\n  ['optionalize', optionalize],\n  ['preventReDoS', preventReDoS],\n  ['removeEmptyGroups', removeEmptyGroups],\n  ['removeUselessFlags', removeUselessFlags],\n  ['simplifyCallouts', simplifyCallouts],\n  ['unnestUselessClasses', unnestUselessClasses],\n  ['unwrapNegationWrappers', unwrapNegationWrappers],\n  ['unwrapUselessClasses', unwrapUselessClasses],\n  ['unwrapUselessGroups', unwrapUselessGroups],\n  ['useShorthands', useShorthands],\n  ['useUnicodeAliases', useUnicodeAliases],\n  ['useUnicodeProps', useUnicodeProps],\n  // Run last to let shorthands, etc. be found from ranges first\n  ['mergeRanges', mergeRanges],\n]);\n\nexport {\n  type OptimizationName,\n  optimizations,\n};\n", "import type {OnigurumaRegex} from '../generator/generate.js';\nimport type {OptimizationName} from './optimizations.js';\nimport {generate} from '../generator/generate.js';\nimport {parse} from '../parser/parse.js';\nimport {traverse} from '../traverser/traverse.js';\nimport {OnigUnicodePropertyMap} from '../unicode.js';\nimport {optimizations} from './optimizations.js';\n\ntype OptimizationStates = {[key in OptimizationName]: boolean};\n\ntype OptimizeOptions = {\n  flags?: string;\n  override?: Partial<OptimizationStates>;\n  rules?: {\n    allowOrphanBackrefs?: boolean;\n    captureGroup?: boolean;\n    singleline?: boolean;\n  };\n};\n\n/**\nReturns an optimized Oniguruma pattern and flags.\n*/\nfunction optimize(pattern: string, options?: OptimizeOptions): OnigurumaRegex {\n  const opts = getOptions(options);\n  const ast = parse(pattern, {\n    flags: opts.flags,\n    rules: {\n      captureGroup: opts.rules.captureGroup,\n      singleline: opts.rules.singleline,\n    },\n    skipBackrefValidation: opts.rules.allowOrphanBackrefs,\n    unicodePropertyMap: OnigUnicodePropertyMap,\n  });\n  const active = Object.assign(getOptionalOptimizations(), opts.override);\n  for (const key of optimizations.keys()) {\n    if (!active[key]) {\n      delete active[key];\n    }\n  }\n  const names = Object.keys(active) as Array<OptimizationName>;\n  let optimized: OnigurumaRegex = {pattern, flags: opts.flags};\n  let counter = 0;\n  do {\n    if (++counter > 200) {\n      throw new Error('Optimization exceeded maximum iterations; possible infinite loop');\n    }\n    pattern = optimized.pattern;\n    for (const name of names) {\n      traverse(ast, optimizations.get(name)!);\n    }\n    optimized = generate(ast);\n  } while (\n    // Continue until no further optimization progress is made\n    pattern !== optimized.pattern\n  );\n  return optimized;\n}\n\nfunction getOptions(options: OptimizeOptions = {}): Required<OptimizeOptions> {\n  return {\n    // Oniguruma flags; a string with `imxDPSW` in any order (all optional). Oniguruma's `m` is\n    // equivalent to JavaScript's `s` (`dotAll`).\n    flags: '',\n    // Enable or disable individual, optional optimizations to change their default state.\n    override: {},\n    ...options,\n    rules: {\n      // Useful with TextMate grammars that merge backreferences across patterns. Maps to the\n      // parser's `skipBackrefValidation` option, but placed/named differently to match its use\n      // in `oniguruma-to-es`, which offers it for the same purpose that the optimizer does.\n      allowOrphanBackrefs: false,\n      // Allow unnamed captures and numbered calls (backreferences and subroutines) when using\n      // named capture. This is Oniguruma option `ONIG_OPTION_CAPTURE_GROUP`; on by default in\n      // `vscode-oniguruma`.\n      captureGroup: false,\n      // `^` as `\\A`; `$` as`\\Z`. This is Oniguruma option `ONIG_OPTION_SINGLELINE`.\n      singleline: false,\n      ...options.rules,\n    },\n  };\n}\n\nfunction getOptionalOptimizations(options: {disable?: boolean} = {}): OptimizationStates {\n  const obj = {} as OptimizationStates;\n  for (const key of optimizations.keys()) {\n    obj[key] = !options.disable;\n  }\n  return obj;\n}\n\nexport {\n  type OptimizeOptions,\n  getOptionalOptimizations,\n  optimize,\n};\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["bundle_exports", "__export", "OnigUnicodePropertyMap", "generate", "getOptionalOptimizations", "optimize", "parse", "toOnigurumaAst", "traverse", "cpOf", "char", "getOrInsert", "map", "key", "defaultValue", "PosixClassNames", "r", "throwIfNullish", "value", "msg", "generate", "ast", "parentStack", "lastNode", "state", "gen", "node", "getFirstChild", "result", "throwIfNullish", "generator", "getLastChild", "body", "kind", "_", "negate", "r", "ref", "name", "inCharClass", "parent", "value", "CharCodeEscapeMap", "escDigit", "isDigitCharCode", "char", "escape", "isDirectClassKid", "isFirst", "isLast", "CharClassEscapeChars", "BaseEscapeChars", "genClass", "min", "max", "flags", "enable", "disable", "enableStr", "getFlagsStr", "disableStr", "atomic", "contents", "getGroupPrefix", "tag", "args", "kidIsGreedyQuantifier", "parentIsPossessivePlus", "forcedInterval", "base", "isSymbolQuantifierCandidate", "isIntervalQuantifier", "suffix", "ignoreCase", "dotAll", "extended", "digitIsAscii", "posixIsAscii", "spaceIsAscii", "wordIsAscii", "textSegmentMode", "mods", "charClassOpenPattern", "r", "sharedEscapesPattern", "quantifierRe", "tokenRe", "charClassTokenRe", "tokenize", "pattern", "options", "opts", "flagProperties", "getFlagProperties", "xStack", "context", "isXOn", "tokens", "match", "result", "getTokenWithDetails", "potentialUnnamedCaptureTokens", "numNamedAndOptInUnnamedCaptures", "t", "i", "numCaptures", "splitEscapedNumberToken", "m", "lastIndex", "m0", "m1", "getAllTokensForCharClass", "createAssertionToken", "createSubroutineToken", "createBackreferenceToken", "createDirectiveToken", "createCharacterSetToken", "tokenizeSharedEscape", "tokenizeNamedCallout", "tokenizeFlagModifier", "createGroupOpenToken", "createGroupCloseToken", "end", "re", "kind", "createAlternatorToken", "splitQuantifierMatch", "createCharacterToken", "cpOf", "opener", "createCharacterClassOpenToken", "numCharClassesOpen", "createCharacterClassCloseToken", "tokenizeAnyTokenWithinCharClass", "raw", "posix", "PosixClassNames", "createCharacterClassHyphenToken", "createCharacterClassIntersectorToken", "inCharClass", "char1", "tokenizeControlCharacter", "tokenizeShorthand", "tokenizeUnicodeProperty", "bytes", "hex", "decoded", "encoder", "char", "byte", "getValidatedHexCharCode", "EscapeCharCodes", "createEscapedNumberToken", "value", "negate", "throwIfNullish", "createNamedCalloutToken", "tag", "args", "createQuantifierToken", "min", "max", "CalloutNames", "on", "off", "enabledFlags", "getFlagGroupSwitches", "disabledFlags", "flagChanges", "callout", "name", "argsArray", "arg", "arg0", "arg1", "arg2", "tokenizeQuantifier", "minStr", "maxStr", "limit", "lower", "p", "neg", "flags", "obj", "token", "matches", "str", "withG", "parts", "hasOnlyChild", "node", "props", "kid", "key", "isAlternativeContainer", "alternativeContainerTypes", "isQuantifiable", "quantifiableTypes", "parse", "pattern", "options", "opts", "tokenized", "tokenize", "walk", "parent", "state", "token", "context", "createAlternative", "parseAssertion", "parseBackreference", "createCharacter", "parseCharacterClassHyphen", "parseCharacterClassOpen", "parseCharacterSet", "createDirective", "parseGroupOpen", "createNamedCallout", "parseQuantifier", "parseSubroutine", "ast", "createRegex", "createFlags", "top", "node", "capturingGroups", "hasNumberedRef", "namedGroupsByName", "subroutines", "ref", "r", "kind", "createAssertion", "throwIfNullish", "raw", "hasKWrapper", "fromNum", "num", "isRelative", "numCapturesToLeft", "orphan", "createBackreference", "numberedRef", "_", "tokens", "prevSiblingNode", "nextToken", "nextNode", "createCharacterClassRange", "cpOf", "negate", "firstClassToken", "intersections", "createCharacterClass", "throwIfUnclosedCharacterClass", "cc", "value", "normalizeUnknownPropertyNames", "skipPropertyNameValidation", "unicodePropertyMap", "normalized", "slug", "PosixClassNames", "createUnicodeProperty", "createPosixClass", "createCharacterSet", "skipLookbehindValidation", "createByGroupKind", "isThisAbsenceFunction", "isThisLookbehind", "isLookbehind", "isThisNegLookbehind", "getOrInsert", "throwIfUnclosedGroup", "alt", "child", "msg", "isLookahead", "min", "max", "quantifiedNode", "isQuantifiable", "createQuantifier", "createSubroutine", "createAbsenceFunction", "getBodyForAlternativeContainer", "getBodyForElementContainer", "createCapturingGroup", "number", "isValidGroupName", "charCode", "hex", "flags", "createGroup", "atomic", "createLookaroundAssertion", "tag", "args", "name", "body", "normalizeUnicodePropertyName", "m", "OnigUnicodePropertyMap", "p", "slug", "toOnigurumaAst", "pattern", "options", "parse", "OnigUnicodePropertyMap", "traverse", "root", "visitor", "state", "traverseArray", "array", "parent", "i", "keyShift", "traverseNode", "node", "key", "container", "skipTraversingKidsOfPath", "path", "arrayContainer", "numericKey", "shifted", "newNode", "options", "traverseNew", "throwIfNullish", "newNodes", "keyShiftInLoop", "type", "anyTypeVisitor", "thisTypeVisitor", "enterAllFn", "enterThisFn", "value", "alternationToClass", "node", "isAlternativeContainer", "newAlts", "ccNodes", "alt", "kid", "universalCharacterSetKinds", "createAlternativeWithCombinedNodes", "nodes", "createAlternative", "createCharacterClass", "exposeAnchors", "node", "parent", "replaceWithMultiple", "firstAlt", "firstAltEls", "leading", "trailing", "hasLeadingAssertion", "hasTrailingAssertion", "clippedStart", "clippedEnd", "nodes", "extractPrefix", "node", "isAlternativeContainer", "prefixNodes", "passedSharedPrefix", "i", "alt", "kid", "isAllowedSimpleNode", "isNodeEqual", "newContentsAlt", "createAlternative", "suffixGroup", "createGroup", "a", "b", "extractPrefix2", "node", "isAlternativeContainer", "numDiffPrefixes", "numAlts", "prefixAltElsByI", "alt", "prefixNodesByI", "prefixIsFinishedByI", "longestOf", "els", "nodeI", "prefixI", "nextNode", "isAllowedSimpleNode", "isPrefixNodeShared", "nodes", "strippedAlts", "counter", "i", "createAlternative", "altComparisonSet", "j", "el", "k", "isNodeEqual", "prefixAlts", "prefixGroup", "createGroup", "newContentsAlt", "suffixGroup", "_", "alts", "bNode", "extractSuffix", "node", "isAlternativeContainer", "firstAltEls", "suffixNodes", "passedSharedSuffix", "inverseI", "alt", "inverseIOfAlt", "kid", "isAllowedSimpleNode", "isNodeEqual", "i", "arr", "lastAlt", "removed", "newContentsAlt", "createAlternative", "prefixGroup", "createGroup", "mergeRanges", "node", "withoutDupeSets", "el", "k", "keep", "candidates", "a", "b", "aValue", "bValue", "merged", "i", "last", "elMin", "lastMax", "createCharacterClassRange", "createCharacter", "final", "diff", "firstPosChar", "optionalize", "node", "isAlternativeContainer", "body", "newAlts", "lastAltKept", "alt", "altKids", "prevAltKids", "lengthDiff", "isPrevAltLonger", "altKidsToCompare", "prevAltKidsToCompare", "isNodeArrayEqual", "prevAltLastKid", "throwIfNullish", "isQuantifiable", "createQuantifier", "altLastKid", "a", "b", "i", "isAllowedSimpleNode", "isNodeEqual", "preventReDoS", "node", "body", "max", "firstAlt", "hasOnlyChild", "nestedQuantifier", "removeEmptyGroups", "node", "remove", "isQualifiedAndEmpty", "kid", "hasOnlyEmptyAlts", "alt", "removeUselessFlags", "node", "remove", "removeFlagX", "removeEmptyFlagsObj", "flags", "cleanupFlagsObj", "simplifyCallouts", "node", "replaceWith", "args", "kind", "createLookaroundAssertion", "newArgs", "arg", "unnestUselessClasses", "node", "parent", "replaceWith", "replaceWithMultiple", "body", "kind", "negate", "firstEl", "hasOnlyChild", "unwrapNegationWrappers", "node", "parent", "replaceWith", "body", "kind", "negate", "kid", "createCharacterSet", "unwrapUselessClasses", "node", "parent", "replaceWith", "body", "kind", "negate", "kid", "unwrapUselessGroups", "node", "isAlternativeContainer", "hasMultiAltNoncapturingGroupOnlyChild", "parent", "replaceWithMultiple", "atomic", "body", "flags", "firstAltEls", "unwrap", "type", "atomicTypes", "quantifiedGroup", "groupKids", "candidate", "isQuantifiable", "useShorthands", "node", "parent", "root", "replaceWith", "kind", "negate", "value", "newNode", "createCharacterSet", "has", "kid", "isRange", "cp", "isUnicode", "cpOf", "min", "max", "options", "names", "expanded", "v", "supercategoryFullName", "categories", "supercategoryShortName", "supercategories", "subcategoryShortNames", "subL", "subM", "subN", "subP", "key", "sub", "useUnicodeAliases", "node", "alias", "OnigUnicodeAliasMap", "useUnicodeProps", "node", "root", "replaceWith", "kind", "negate", "value", "newNode", "createUnicodeProperty", "isRange", "optimizations", "alternationToClass", "exposeAnchors", "extractPrefix", "extractPrefix2", "extractSuffix", "optionalize", "preventReDoS", "removeEmptyGroups", "removeUselessFlags", "simplifyCallouts", "unnestUselessClasses", "unwrapNegationWrappers", "unwrapUselessClasses", "unwrapUselessGroups", "useShorthands", "useUnicodeAliases", "useUnicodeProps", "mergeRanges", "optimize", "pattern", "options", "opts", "getOptions", "ast", "parse", "OnigUnicodePropertyMap", "active", "getOptionalOptimizations", "key", "optimizations", "names", "optimized", "counter", "name", "traverse", "generate", "obj"]
}
