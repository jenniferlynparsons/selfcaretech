{
  "version": 3,
  "sources": ["../src/index.js", "../node_modules/.pnpm/regex-utilities@2.3.0/node_modules/regex-utilities/src/index.js"],
  "sourcesContent": ["import {Context, forEachUnescaped, getGroupContents, hasUnescaped, replaceUnescaped} from 'regex-utilities';\n\nconst r = String.raw;\nconst gRToken = r`\\\\g<(?<gRNameOrNum>[^>&]+)&R=(?<gRDepth>[^>]+)>`;\nconst recursiveToken = r`\\(\\?R=(?<rDepth>[^\\)]+)\\)|${gRToken}`;\nconst namedCaptureDelim = r`\\(\\?<(?![=!])(?<captureName>[^>]+)>`;\nconst captureDelim = r`${namedCaptureDelim}|(?<unnamed>\\()(?!\\?)`;\nconst token = new RegExp(r`${namedCaptureDelim}|${recursiveToken}|\\(\\?|\\\\?.`, 'gsu');\nconst overlappingRecursionMsg = 'Cannot use multiple overlapping recursions';\n\n/**\n@param {string} pattern\n@param {{\n  flags?: string;\n  captureTransfers?: Map<number, Array<number>>;\n  hiddenCaptures?: Array<number>;\n  mode?: 'plugin' | 'external';\n}} [data]\n@returns {{\n  pattern: string;\n  captureTransfers: Map<number, Array<number>>;\n  hiddenCaptures: Array<number>;\n}}\n*/\nfunction recursion(pattern, data) {\n  const {hiddenCaptures, mode} = {\n    hiddenCaptures: [],\n    mode: 'plugin',\n    ...data,\n  };\n  // Capture transfer is used by <github.com/slevithan/oniguruma-to-es>\n  let captureTransfers = data?.captureTransfers ?? new Map();\n  // Keep the initial fail-check (which avoids unneeded processing) as fast as possible by testing\n  // without the accuracy improvement of using `hasUnescaped` with `Context.DEFAULT`\n  if (!(new RegExp(recursiveToken, 'su').test(pattern))) {\n    return {\n      pattern,\n      captureTransfers,\n      hiddenCaptures,\n    };\n  }\n  if (mode === 'plugin' && hasUnescaped(pattern, r`\\(\\?\\(DEFINE\\)`, Context.DEFAULT)) {\n    throw new Error('DEFINE groups cannot be used with recursion');\n  }\n\n  const addedHiddenCaptures = [];\n  const hasNumberedBackref = hasUnescaped(pattern, r`\\\\[1-9]`, Context.DEFAULT);\n  const groupContentsStartPos = new Map();\n  const openGroups = [];\n  let hasRecursed = false;\n  let numCharClassesOpen = 0;\n  let numCapturesPassed = 0;\n  let match;\n  token.lastIndex = 0;\n  while ((match = token.exec(pattern))) {\n    const {0: m, groups: {captureName, rDepth, gRNameOrNum, gRDepth}} = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n\n      // `(?R=N)`\n      if (rDepth) {\n        assertMaxInBounds(rDepth);\n        if (hasRecursed) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        if (hasNumberedBackref) {\n          // Could add support for numbered backrefs with extra effort, but it's probably not worth\n          // it. To trigger this error, the regex must include recursion and one of the following:\n          // - An interpolated regex that contains a numbered backref (since other numbered\n          //   backrefs are prevented by implicit flag n).\n          // - A numbered backref, when flag n is explicitly disabled.\n          // Note that Regex+'s extended syntax (atomic groups and sometimes subroutines) can also\n          // add numbered backrefs, but those work fine because external plugins like this one run\n          // *before* the transformation of built-in syntax extensions\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with global recursion`\n          );\n        }\n        const left = pattern.slice(0, match.index);\n        const right = pattern.slice(token.lastIndex);\n        if (hasUnescaped(right, recursiveToken, Context.DEFAULT)) {\n          throw new Error(overlappingRecursionMsg);\n        }\n        const reps = +rDepth - 1;\n        pattern = makeRecursive(\n          left,\n          right,\n          reps,\n          false,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          left,\n          reps,\n          addedHiddenCaptures.length,\n          0,\n          numCapturesPassed\n        );\n        // No need to parse further\n        break;\n      // `\\g<name&R=N>`, `\\g<number&R=N>`\n      } else if (gRNameOrNum) {\n        assertMaxInBounds(gRDepth);\n        let isWithinReffedGroup = false;\n        for (const g of openGroups) {\n          if (g.name === gRNameOrNum || g.num === +gRNameOrNum) {\n            isWithinReffedGroup = true;\n            if (g.hasRecursedWithin) {\n              throw new Error(overlappingRecursionMsg);\n            }\n            break;\n          }\n        }\n        if (!isWithinReffedGroup) {\n          throw new Error(r`Recursive \\g cannot be used outside the referenced group \"${\n            mode === 'external' ? gRNameOrNum : r`\\g<${gRNameOrNum}&R=${gRDepth}>`\n          }\"`);\n        }\n        const startPos = groupContentsStartPos.get(gRNameOrNum);\n        const groupContents = getGroupContents(pattern, startPos);\n        if (\n          hasNumberedBackref &&\n          hasUnescaped(groupContents, r`${namedCaptureDelim}|\\((?!\\?)`, Context.DEFAULT)\n        ) {\n          throw new Error(\n            // When used in `external` mode by transpilers other than Regex+, backrefs might have\n            // gone through conversion from named to numbered, so avoid a misleading error\n            `${mode === 'external' ? 'Backrefs' : 'Numbered backrefs'} cannot be used with recursion of capturing groups`\n          );\n        }\n        const groupContentsLeft = pattern.slice(startPos, match.index);\n        const groupContentsRight = groupContents.slice(groupContentsLeft.length + m.length);\n        const numAddedHiddenCapturesPreExpansion = addedHiddenCaptures.length;\n        const reps = +gRDepth - 1;\n        const expansion = makeRecursive(\n          groupContentsLeft,\n          groupContentsRight,\n          reps,\n          true,\n          hiddenCaptures,\n          addedHiddenCaptures,\n          numCapturesPassed\n        );\n        captureTransfers = mapCaptureTransfers(\n          captureTransfers,\n          groupContentsLeft,\n          reps,\n          addedHiddenCaptures.length - numAddedHiddenCapturesPreExpansion,\n          numAddedHiddenCapturesPreExpansion,\n          numCapturesPassed\n        );\n        const pre = pattern.slice(0, startPos);\n        const post = pattern.slice(startPos + groupContents.length);\n        // Modify the string we're looping over\n        pattern = `${pre}${expansion}${post}`;\n        // Step forward for the next loop iteration\n        token.lastIndex += expansion.length - m.length - groupContentsLeft.length - groupContentsRight.length;\n        openGroups.forEach(g => g.hasRecursedWithin = true);\n        hasRecursed = true;\n      } else if (captureName) {\n        numCapturesPassed++;\n        groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        groupContentsStartPos.set(captureName, token.lastIndex);\n        openGroups.push({\n          num: numCapturesPassed,\n          name: captureName,\n        });\n      } else if (m[0] === '(') {\n        const isUnnamedCapture = m === '(';\n        if (isUnnamedCapture) {\n          numCapturesPassed++;\n          groupContentsStartPos.set(String(numCapturesPassed), token.lastIndex);\n        }\n        openGroups.push(isUnnamedCapture ? {num: numCapturesPassed} : {});\n      } else if (m === ')') {\n        openGroups.pop();\n      }\n\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n\n  hiddenCaptures.push(...addedHiddenCaptures);\n\n  return {\n    pattern,\n    captureTransfers,\n    hiddenCaptures,\n  };\n}\n\n/**\n@param {string} max\n*/\nfunction assertMaxInBounds(max) {\n  const errMsg = `Max depth must be integer between 2 and 100; used ${max}`;\n  if (!/^[1-9]\\d*$/.test(max)) {\n    throw new Error(errMsg);\n  }\n  max = +max;\n  if (max < 2 || max > 100) {\n    throw new Error(errMsg);\n  }\n}\n\n/**\n@param {string} left\n@param {string} right\n@param {number} reps\n@param {boolean} isSubpattern\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction makeRecursive(\n  left,\n  right,\n  reps,\n  isSubpattern,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const namesInRecursed = new Set();\n  // Can skip this work if not needed\n  if (isSubpattern) {\n    forEachUnescaped(left + right, namedCaptureDelim, ({groups: {captureName}}) => {\n      namesInRecursed.add(captureName);\n    }, Context.DEFAULT);\n  }\n  const rest = [\n    reps,\n    isSubpattern ? namesInRecursed : null,\n    hiddenCaptures,\n    addedHiddenCaptures,\n    numCapturesPassed,\n  ];\n  // Depth 2: 'left(?:left(?:)right)right'\n  // Depth 3: 'left(?:left(?:left(?:)right)right)right'\n  // Empty group in the middle separates tokens and absorbs a following quantifier if present\n  return `${left}${\n    repeatWithDepth(`(?:${left}`, 'forward', ...rest)\n  }(?:)${\n    repeatWithDepth(`${right})`, 'backward', ...rest)\n  }${right}`;\n}\n\n/**\n@param {string} pattern\n@param {'forward' | 'backward'} direction\n@param {number} reps\n@param {Set<string> | null} namesInRecursed\n@param {Array<number>} hiddenCaptures\n@param {Array<number>} addedHiddenCaptures\n@param {number} numCapturesPassed\n@returns {string}\n*/\nfunction repeatWithDepth(\n  pattern,\n  direction,\n  reps,\n  namesInRecursed,\n  hiddenCaptures,\n  addedHiddenCaptures,\n  numCapturesPassed\n) {\n  const startNum = 2;\n  const getDepthNum = i => direction === 'forward' ? (i + startNum) : (reps - i + startNum - 1);\n  let result = '';\n  for (let i = 0; i < reps; i++) {\n    const depthNum = getDepthNum(i);\n    result += replaceUnescaped(\n      pattern,\n      r`${captureDelim}|\\\\k<(?<backref>[^>]+)>`,\n      ({0: m, groups: {captureName, unnamed, backref}}) => {\n        if (backref && namesInRecursed && !namesInRecursed.has(backref)) {\n          // Don't alter backrefs to groups outside the recursed subpattern\n          return m;\n        }\n        const suffix = `_$${depthNum}`;\n        if (unnamed || captureName) {\n          const addedCaptureNum = numCapturesPassed + addedHiddenCaptures.length + 1;\n          addedHiddenCaptures.push(addedCaptureNum);\n          incrementIfAtLeast(hiddenCaptures, addedCaptureNum);\n          return unnamed ? m : `(?<${captureName}${suffix}>`;\n        }\n        return r`\\k<${backref}${suffix}>`;\n      },\n      Context.DEFAULT\n    );\n  }\n  return result;\n}\n\n/**\nUpdates the array in place by incrementing each value greater than or equal to the threshold.\n@param {Array<number>} arr\n@param {number} threshold\n*/\nfunction incrementIfAtLeast(arr, threshold) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] >= threshold) {\n      arr[i]++;\n    }\n  }\n}\n\n/**\n@param {Map<number, Array<number>>} captureTransfers\n@param {string} left\n@param {number} reps\n@param {number} numCapturesAddedInExpansion\n@param {number} numAddedHiddenCapturesPreExpansion\n@param {number} numCapturesPassed\n@returns {Map<number, Array<number>>}\n*/\nfunction mapCaptureTransfers(captureTransfers, left, reps, numCapturesAddedInExpansion, numAddedHiddenCapturesPreExpansion, numCapturesPassed) {\n  if (captureTransfers.size && numCapturesAddedInExpansion) {\n    let numCapturesInLeft = 0;\n    forEachUnescaped(left, captureDelim, () => numCapturesInLeft++, Context.DEFAULT);\n    // Is 0 for global recursion\n    const recursionDelimCaptureNum = numCapturesPassed - numCapturesInLeft + numAddedHiddenCapturesPreExpansion;\n    const newCaptureTransfers = new Map();\n    captureTransfers.forEach((from, to) => {\n      const numCapturesInRight = (numCapturesAddedInExpansion - (numCapturesInLeft * reps)) / reps;\n      const numCapturesAddedInLeft = numCapturesInLeft * reps;\n      const newTo = to > (recursionDelimCaptureNum + numCapturesInLeft) ? to + numCapturesAddedInExpansion : to;\n      const newFrom = [];\n      for (const f of from) {\n        // Before the recursed subpattern\n        if (f <= recursionDelimCaptureNum) {\n          newFrom.push(f);\n        // After the recursed subpattern\n        } else if (f > (recursionDelimCaptureNum + numCapturesInLeft + numCapturesInRight)) {\n          newFrom.push(f + numCapturesAddedInExpansion);\n        // Within the recursed subpattern, on the left of the recursion token\n        } else if (f <= (recursionDelimCaptureNum + numCapturesInLeft)) {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + (numCapturesInLeft * i));\n          }\n        // Within the recursed subpattern, on the right of the recursion token\n        } else {\n          for (let i = 0; i <= reps; i++) {\n            newFrom.push(f + numCapturesAddedInLeft + (numCapturesInRight * i));\n          }\n        }\n      }\n      newCaptureTransfers.set(newTo, newFrom);\n    });\n    return newCaptureTransfers;\n  }\n  return captureTransfers;\n}\n\nexport {\n  recursion,\n};\n", "// Constant properties for tracking regex syntax context\nexport const Context = Object.freeze({\n  DEFAULT: 'DEFAULT',\n  CHAR_CLASS: 'CHAR_CLASS',\n});\n\n/**\nReplaces all unescaped instances of a regex pattern in the given context, using a replacement\nstring or callback.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {string | (match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => string} replacement\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {string} Updated expression\n@example\nconst str = '.\\\\.\\\\\\\\.[[\\\\.].].';\nreplaceUnescaped(str, '\\\\.', '@');\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.]@]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.DEFAULT);\n// \u2192 '@\\\\.\\\\\\\\@[[\\\\.].]@'\nreplaceUnescaped(str, '\\\\.', '@', Context.CHAR_CLASS);\n// \u2192 '.\\\\.\\\\\\\\.[[\\\\.]@].'\n*/\nexport function replaceUnescaped(expression, needle, replacement, context) {\n  const re = new RegExp(String.raw`${needle}|(?<$skip>\\[\\^?|\\\\?.)`, 'gsu');\n  const negated = [false];\n  let numCharClassesOpen = 0;\n  let result = '';\n  for (const match of expression.matchAll(re)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      if (replacement instanceof Function) {\n        result += replacement(match, {\n          context: numCharClassesOpen ? Context.CHAR_CLASS : Context.DEFAULT,\n          negated: negated[negated.length - 1],\n        });\n      } else {\n        result += replacement;\n      }\n      continue;\n    }\n    if (m[0] === '[') {\n      numCharClassesOpen++;\n      negated.push(m[1] === '^');\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n      negated.pop();\n    }\n    result += m;\n  }\n  return result;\n}\n\n/**\nRuns a callback for each unescaped instance of a regex pattern in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {(match: RegExpExecArray, details: {\n  context: 'DEFAULT' | 'CHAR_CLASS';\n  negated: boolean;\n}) => void} callback\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n*/\nexport function forEachUnescaped(expression, needle, callback, context) {\n  // Do this the easy way\n  replaceUnescaped(expression, needle, callback, context);\n}\n\n/**\nReturns a match object for the first unescaped instance of a regex pattern in the given context, or\n`null`.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {number} [pos] Offset to start the search\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {RegExpExecArray | null}\n*/\nexport function execUnescaped(expression, needle, pos = 0, context) {\n  // Quick partial test; avoid the loop if not needed\n  if (!(new RegExp(needle, 'su').test(expression))) {\n    return null;\n  }\n  const re = new RegExp(`${needle}|(?<$skip>\\\\\\\\?.)`, 'gsu');\n  re.lastIndex = pos;\n  let numCharClassesOpen = 0;\n  let match;\n  while (match = re.exec(expression)) {\n    const {0: m, groups: {$skip}} = match;\n    if (!$skip && (!context || (context === Context.DEFAULT) === !numCharClassesOpen)) {\n      return match;\n    }\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (m === ']' && numCharClassesOpen) {\n      numCharClassesOpen--;\n    }\n    // Avoid an infinite loop on zero-length matches\n    if (re.lastIndex == match.index) {\n      re.lastIndex++;\n    }\n  }\n  return null;\n}\n\n/**\nChecks whether an unescaped instance of a regex pattern appears in the given context.\n\nDoesn't skip over complete multicharacter tokens (only `\\` plus its folowing char) so must be used\nwith knowledge of what's safe to do given regex syntax. Assumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {string} needle Search as a regex pattern, with flags `su` applied\n@param {'DEFAULT' | 'CHAR_CLASS'} [context] All contexts if not specified\n@returns {boolean} Whether the pattern was found\n*/\nexport function hasUnescaped(expression, needle, context) {\n  // Do this the easy way\n  return !!execUnescaped(expression, needle, 0, context);\n}\n\n/**\nExtracts the full contents of a group (subpattern) from the given expression, accounting for\nescaped characters, nested groups, and character classes. The group is identified by the position\nwhere its contents start (the string index just after the group's opening delimiter). Returns the\nrest of the string if the group is unclosed.\n\nAssumes UnicodeSets-mode syntax.\n@param {string} expression Search target\n@param {number} contentsStartPos\n@returns {string}\n*/\nexport function getGroupContents(expression, contentsStartPos) {\n  const token = /\\\\?./gsu;\n  token.lastIndex = contentsStartPos;\n  let contentsEndPos = expression.length;\n  let numCharClassesOpen = 0;\n  // Starting search within an open group, after the group's opening\n  let numGroupsOpen = 1;\n  let match;\n  while (match = token.exec(expression)) {\n    const [m] = match;\n    if (m === '[') {\n      numCharClassesOpen++;\n    } else if (!numCharClassesOpen) {\n      if (m === '(') {\n        numGroupsOpen++;\n      } else if (m === ')') {\n        numGroupsOpen--;\n        if (!numGroupsOpen) {\n          contentsEndPos = match.index;\n          break;\n        }\n      }\n    } else if (m === ']') {\n      numCharClassesOpen--;\n    }\n  }\n  return expression.slice(contentsStartPos, contentsEndPos);\n}\n"],
  "mappings": "icAAA,IAAAA,GAAA,GAAAC,EAAAD,GAAA,eAAAE,ICCO,IAAMC,EAAU,OAAO,OAAO,CACnC,QAAS,UACT,WAAY,YACd,CAAC,EAyBM,SAASC,EAAiBC,EAAYC,EAAQC,EAAaC,EAAS,CACzE,IAAMC,EAAK,IAAI,OAAO,OAAO,MAAMH,CAAM,wBAAyB,KAAK,EACjEI,EAAU,CAAC,EAAK,EAClBC,EAAqB,EACrBC,EAAS,GACb,QAAWC,KAASR,EAAW,SAASI,CAAE,EAAG,CAC3C,GAAM,CAAC,EAAGK,EAAG,OAAQ,CAAC,MAAAC,CAAK,CAAC,EAAIF,EAChC,GAAI,CAACE,IAAU,CAACP,GAAYA,IAAYL,EAAQ,SAAa,CAACQ,GAAqB,CAC7EJ,aAAuB,SACzBK,GAAUL,EAAYM,EAAO,CAC3B,QAASF,EAAqBR,EAAQ,WAAaA,EAAQ,QAC3D,QAASO,EAAQA,EAAQ,OAAS,CAAC,CACrC,CAAC,EAEDE,GAAUL,EAEZ,QACF,CACIO,EAAE,CAAC,IAAM,KACXH,IACAD,EAAQ,KAAKI,EAAE,CAAC,IAAM,GAAG,GAChBA,IAAM,KAAOH,IACtBA,IACAD,EAAQ,IAAI,GAEdE,GAAUE,CACZ,CACA,OAAOF,CACT,CAeO,SAASI,EAAiBX,EAAYC,EAAQW,EAAUT,EAAS,CAEtEJ,EAAiBC,EAAYC,EAAQW,EAAUT,CAAO,CACxD,CAcO,SAASU,EAAcb,EAAYC,EAAQa,EAAM,EAAGX,EAAS,CAElE,GAAI,CAAE,IAAI,OAAOF,EAAQ,IAAI,EAAE,KAAKD,CAAU,EAC5C,OAAO,KAET,IAAMI,EAAK,IAAI,OAAO,GAAGH,CAAM,oBAAqB,KAAK,EACzDG,EAAG,UAAYU,EACf,IAAIR,EAAqB,EACrBE,EACJ,KAAOA,EAAQJ,EAAG,KAAKJ,CAAU,GAAG,CAClC,GAAM,CAAC,EAAGS,EAAG,OAAQ,CAAC,MAAAC,CAAK,CAAC,EAAIF,EAChC,GAAI,CAACE,IAAU,CAACP,GAAYA,IAAYL,EAAQ,SAAa,CAACQ,GAC5D,OAAOE,EAELC,IAAM,IACRH,IACSG,IAAM,KAAOH,GACtBA,IAGEF,EAAG,WAAaI,EAAM,OACxBJ,EAAG,WAEP,CACA,OAAO,IACT,CAYO,SAASW,EAAaf,EAAYC,EAAQE,EAAS,CAExD,MAAO,CAAC,CAACU,EAAcb,EAAYC,EAAQ,EAAGE,CAAO,CACvD,CAaO,SAASa,EAAiBhB,EAAYiB,EAAkB,CAC7D,IAAMC,EAAQ,UACdA,EAAM,UAAYD,EAClB,IAAIE,EAAiBnB,EAAW,OAC5BM,EAAqB,EAErBc,EAAgB,EAChBZ,EACJ,KAAOA,EAAQU,EAAM,KAAKlB,CAAU,GAAG,CACrC,GAAM,CAACS,CAAC,EAAID,EACZ,GAAIC,IAAM,IACRH,YACUA,EAUDG,IAAM,KACfH,YAVIG,IAAM,IACRW,YACSX,IAAM,MACfW,IACI,CAACA,GAAe,CAClBD,EAAiBX,EAAM,MACvB,KACF,CAKN,CACA,OAAOR,EAAW,MAAMiB,EAAkBE,CAAc,CAC1D,CDvKA,IAAME,EAAI,OAAO,IACXC,EAAUD,mDACVE,EAAiBF,8BAA8BC,CAAO,GACtDE,EAAoBH,uCACpBI,EAAeJ,IAAIG,CAAiB,wBACpCE,EAAQ,IAAI,OAAOL,IAAIG,CAAiB,IAAID,CAAc,aAAc,KAAK,EAC7EI,EAA0B,6CAgBhC,SAASC,EAAUC,EAASC,EAAM,CAChC,GAAM,CAAC,eAAAC,EAAgB,KAAAC,CAAI,EAAI,CAC7B,eAAgB,CAAC,EACjB,KAAM,SACN,GAAGF,CACL,EAEIG,EAAmBH,GAAM,kBAAoB,IAAI,IAGrD,GAAI,CAAE,IAAI,OAAOP,EAAgB,IAAI,EAAE,KAAKM,CAAO,EACjD,MAAO,CACL,QAAAA,EACA,iBAAAI,EACA,eAAAF,CACF,EAEF,GAAIC,IAAS,UAAYE,EAAaL,EAASR,kBAAmBc,EAAQ,OAAO,EAC/E,MAAM,IAAI,MAAM,6CAA6C,EAG/D,IAAMC,EAAsB,CAAC,EACvBC,EAAqBH,EAAaL,EAASR,WAAYc,EAAQ,OAAO,EACtEG,EAAwB,IAAI,IAC5BC,EAAa,CAAC,EAChBC,EAAc,GACdC,EAAqB,EACrBC,EAAoB,EACpBC,EAEJ,IADAjB,EAAM,UAAY,EACViB,EAAQjB,EAAM,KAAKG,CAAO,GAAI,CACpC,GAAM,CAAC,EAAGe,EAAG,OAAQ,CAAC,YAAAC,EAAa,OAAAC,EAAQ,YAAAC,EAAa,QAAAC,CAAO,CAAC,EAAIL,EACpE,GAAIC,IAAM,IACRH,YACUA,EA8HDG,IAAM,KACfH,YA5HIK,EAAQ,CAEV,GADAG,EAAkBH,CAAM,EACpBN,EACF,MAAM,IAAI,MAAMb,CAAuB,EAEzC,GAAIU,EASF,MAAM,IAAI,MAGR,GAAGL,IAAS,WAAa,WAAa,mBAAmB,uCAC3D,EAEF,IAAMkB,EAAOrB,EAAQ,MAAM,EAAGc,EAAM,KAAK,EACnCQ,EAAQtB,EAAQ,MAAMH,EAAM,SAAS,EAC3C,GAAIQ,EAAaiB,EAAO5B,EAAgBY,EAAQ,OAAO,EACrD,MAAM,IAAI,MAAMR,CAAuB,EAEzC,IAAMyB,EAAO,CAACN,EAAS,EACvBjB,EAAUwB,EACRH,EACAC,EACAC,EACA,GACArB,EACAK,EACAM,CACF,EACAT,EAAmBqB,EACjBrB,EACAiB,EACAE,EACAhB,EAAoB,OACpB,EACAM,CACF,EAEA,KAEF,SAAWK,EAAa,CACtBE,EAAkBD,CAAO,EACzB,IAAIO,EAAsB,GAC1B,QAAWC,KAAKjB,EACd,GAAIiB,EAAE,OAAST,GAAeS,EAAE,MAAQ,CAACT,EAAa,CAEpD,GADAQ,EAAsB,GAClBC,EAAE,kBACJ,MAAM,IAAI,MAAM7B,CAAuB,EAEzC,KACF,CAEF,GAAI,CAAC4B,EACH,MAAM,IAAI,MAAMlC,8DACdW,IAAS,WAAae,EAAc1B,OAAO0B,CAAW,MAAMC,CAAO,GACrE,GAAG,EAEL,IAAMS,EAAWnB,EAAsB,IAAIS,CAAW,EAChDW,EAAgBC,EAAiB9B,EAAS4B,CAAQ,EACxD,GACEpB,GACAH,EAAawB,EAAerC,IAAIG,CAAiB,YAAaW,EAAQ,OAAO,EAE7E,MAAM,IAAI,MAGR,GAAGH,IAAS,WAAa,WAAa,mBAAmB,oDAC3D,EAEF,IAAM4B,EAAoB/B,EAAQ,MAAM4B,EAAUd,EAAM,KAAK,EACvDkB,EAAqBH,EAAc,MAAME,EAAkB,OAAShB,EAAE,MAAM,EAC5EkB,EAAqC1B,EAAoB,OACzDgB,EAAO,CAACJ,EAAU,EAClBe,EAAYV,EAChBO,EACAC,EACAT,EACA,GACArB,EACAK,EACAM,CACF,EACAT,EAAmBqB,EACjBrB,EACA2B,EACAR,EACAhB,EAAoB,OAAS0B,EAC7BA,EACApB,CACF,EACA,IAAMsB,EAAMnC,EAAQ,MAAM,EAAG4B,CAAQ,EAC/BQ,EAAOpC,EAAQ,MAAM4B,EAAWC,EAAc,MAAM,EAE1D7B,EAAU,GAAGmC,CAAG,GAAGD,CAAS,GAAGE,CAAI,GAEnCvC,EAAM,WAAaqC,EAAU,OAASnB,EAAE,OAASgB,EAAkB,OAASC,EAAmB,OAC/FtB,EAAW,QAAQiB,GAAKA,EAAE,kBAAoB,EAAI,EAClDhB,EAAc,EAChB,SAAWK,EACTH,IACAJ,EAAsB,IAAI,OAAOI,CAAiB,EAAGhB,EAAM,SAAS,EACpEY,EAAsB,IAAIO,EAAanB,EAAM,SAAS,EACtDa,EAAW,KAAK,CACd,IAAKG,EACL,KAAMG,CACR,CAAC,UACQD,EAAE,CAAC,IAAM,IAAK,CACvB,IAAMsB,EAAmBtB,IAAM,IAC3BsB,IACFxB,IACAJ,EAAsB,IAAI,OAAOI,CAAiB,EAAGhB,EAAM,SAAS,GAEtEa,EAAW,KAAK2B,EAAmB,CAAC,IAAKxB,CAAiB,EAAI,CAAC,CAAC,CAClE,MAAWE,IAAM,KACfL,EAAW,IAAI,CAMrB,CAEA,OAAAR,EAAe,KAAK,GAAGK,CAAmB,EAEnC,CACL,QAAAP,EACA,iBAAAI,EACA,eAAAF,CACF,CACF,CAKA,SAASkB,EAAkBkB,EAAK,CAC9B,IAAMC,EAAS,qDAAqDD,CAAG,GACvE,GAAI,CAAC,aAAa,KAAKA,CAAG,EACxB,MAAM,IAAI,MAAMC,CAAM,EAGxB,GADAD,EAAM,CAACA,EACHA,EAAM,GAAKA,EAAM,IACnB,MAAM,IAAI,MAAMC,CAAM,CAE1B,CAYA,SAASf,EACPH,EACAC,EACAC,EACAiB,EACAtC,EACAK,EACAM,EACA,CACA,IAAM4B,EAAkB,IAAI,IAExBD,GACFE,EAAiBrB,EAAOC,EAAO3B,EAAmB,CAAC,CAAC,OAAQ,CAAC,YAAAqB,CAAW,CAAC,IAAM,CAC7EyB,EAAgB,IAAIzB,CAAW,CACjC,EAAGV,EAAQ,OAAO,EAEpB,IAAMqC,EAAO,CACXpB,EACAiB,EAAeC,EAAkB,KACjCvC,EACAK,EACAM,CACF,EAIA,MAAO,GAAGQ,CAAI,GACZuB,EAAgB,MAAMvB,CAAI,GAAI,UAAW,GAAGsB,CAAI,CAClD,OACEC,EAAgB,GAAGtB,CAAK,IAAK,WAAY,GAAGqB,CAAI,CAClD,GAAGrB,CAAK,EACV,CAYA,SAASsB,EACP5C,EACA6C,EACAtB,EACAkB,EACAvC,EACAK,EACAM,EACA,CAEA,IAAMiC,EAAcC,GAAKF,IAAc,UAAaE,EAAI,EAAaxB,EAAOwB,EAAI,EAAW,EACvFC,EAAS,GACb,QAASD,EAAI,EAAGA,EAAIxB,EAAMwB,IAAK,CAC7B,IAAME,EAAWH,EAAYC,CAAC,EAC9BC,GAAUE,EACRlD,EACAR,IAAII,CAAY,0BAChB,CAAC,CAAC,EAAGmB,EAAG,OAAQ,CAAC,YAAAC,EAAa,QAAAmC,EAAS,QAAAC,CAAO,CAAC,IAAM,CACnD,GAAIA,GAAWX,GAAmB,CAACA,EAAgB,IAAIW,CAAO,EAE5D,OAAOrC,EAET,IAAMsC,EAAS,KAAKJ,CAAQ,GAC5B,GAAIE,GAAWnC,EAAa,CAC1B,IAAMsC,EAAkBzC,EAAoBN,EAAoB,OAAS,EACzE,OAAAA,EAAoB,KAAK+C,CAAe,EACxCC,GAAmBrD,EAAgBoD,CAAe,EAC3CH,EAAUpC,EAAI,MAAMC,CAAW,GAAGqC,CAAM,GACjD,CACA,OAAO7D,OAAO4D,CAAO,GAAGC,CAAM,GAChC,EACA/C,EAAQ,OACV,CACF,CACA,OAAO0C,CACT,CAOA,SAASO,GAAmBC,EAAKC,EAAW,CAC1C,QAASV,EAAI,EAAGA,EAAIS,EAAI,OAAQT,IAC1BS,EAAIT,CAAC,GAAKU,GACZD,EAAIT,CAAC,GAGX,CAWA,SAAStB,EAAoBrB,EAAkBiB,EAAME,EAAMmC,EAA6BzB,EAAoCpB,EAAmB,CAC7I,GAAIT,EAAiB,MAAQsD,EAA6B,CACxD,IAAIC,EAAoB,EACxBjB,EAAiBrB,EAAMzB,EAAc,IAAM+D,IAAqBrD,EAAQ,OAAO,EAE/E,IAAMsD,EAA2B/C,EAAoB8C,EAAoB1B,EACnE4B,EAAsB,IAAI,IAChC,OAAAzD,EAAiB,QAAQ,CAAC0D,EAAMC,IAAO,CACrC,IAAMC,GAAsBN,EAA+BC,EAAoBpC,GAASA,EAClF0C,EAAyBN,EAAoBpC,EAC7C2C,EAAQH,EAAMH,EAA2BD,EAAqBI,EAAKL,EAA8BK,EACjGI,EAAU,CAAC,EACjB,QAAWC,KAAKN,EAEd,GAAIM,GAAKR,EACPO,EAAQ,KAAKC,CAAC,UAELA,EAAKR,EAA2BD,EAAoBK,EAC7DG,EAAQ,KAAKC,EAAIV,CAA2B,UAEnCU,GAAMR,EAA2BD,EAC1C,QAASZ,EAAI,EAAGA,GAAKxB,EAAMwB,IACzBoB,EAAQ,KAAKC,EAAKT,EAAoBZ,CAAE,MAI1C,SAASA,EAAI,EAAGA,GAAKxB,EAAMwB,IACzBoB,EAAQ,KAAKC,EAAIH,EAA0BD,EAAqBjB,CAAE,EAIxEc,EAAoB,IAAIK,EAAOC,CAAO,CACxC,CAAC,EACMN,CACT,CACA,OAAOzD,CACT",
  "names": ["index_exports", "__export", "recursion", "Context", "replaceUnescaped", "expression", "needle", "replacement", "context", "re", "negated", "numCharClassesOpen", "result", "match", "m", "$skip", "forEachUnescaped", "callback", "execUnescaped", "pos", "hasUnescaped", "getGroupContents", "contentsStartPos", "token", "contentsEndPos", "numGroupsOpen", "r", "gRToken", "recursiveToken", "namedCaptureDelim", "captureDelim", "token", "overlappingRecursionMsg", "recursion", "pattern", "data", "hiddenCaptures", "mode", "captureTransfers", "hasUnescaped", "Context", "addedHiddenCaptures", "hasNumberedBackref", "groupContentsStartPos", "openGroups", "hasRecursed", "numCharClassesOpen", "numCapturesPassed", "match", "m", "captureName", "rDepth", "gRNameOrNum", "gRDepth", "assertMaxInBounds", "left", "right", "reps", "makeRecursive", "mapCaptureTransfers", "isWithinReffedGroup", "g", "startPos", "groupContents", "getGroupContents", "groupContentsLeft", "groupContentsRight", "numAddedHiddenCapturesPreExpansion", "expansion", "pre", "post", "isUnnamedCapture", "max", "errMsg", "isSubpattern", "namesInRecursed", "forEachUnescaped", "rest", "repeatWithDepth", "direction", "getDepthNum", "i", "result", "depthNum", "replaceUnescaped", "unnamed", "backref", "suffix", "addedCaptureNum", "incrementIfAtLeast", "arr", "threshold", "numCapturesAddedInExpansion", "numCapturesInLeft", "recursionDelimCaptureNum", "newCaptureTransfers", "from", "to", "numCapturesInRight", "numCapturesAddedInLeft", "newTo", "newFrom", "f"]
}
